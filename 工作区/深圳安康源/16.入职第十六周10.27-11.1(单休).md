
##### PWM 简单讲解

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_1.png]]

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_2.png]]

PWM 最重要的参数一个是占空比，就是周期内高电平持续的时间。
第二个就是频率，就是 1 秒产生多少个周期

蜂鸣器上，频率主要调节音调高低，占空比调节音量大小
雾化器这个上面，电机驱动的话，占空比控制出雾量，频率好像控制转动产生的噪声
不过理论上可以用代码让他一直快速翻转电平，模拟实现 PWM

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_3.jpg]]


AXD-303A,我之前试着用软件去模拟输出 PWM，发现直接驱动不了，主要原因就是这玩意本质就是高速开关电路，但是303A 是继电器开关，继电器不支持 us 级别高速开关，所以直接就用不了。一般好像用 mos 管


##### 雾化器 N300修改为 2 个触摸按键，并增加 1个 LED 灯
雾化器 N300 由3 个触摸按键修改为 2 个触摸按键，并增加了一个电源通电的 LED 灯
该 LED 灯在第 3 个地址处，所以一直没能点亮，方法也用错了。
给所有地址赋值后全亮 (全显函数可亮)，应该通过位偏移逐个点亮 LED 灯的方式去推断新增的 LED 灯所处的地址是哪里。

```
for(i=0x01;i<16;i++)
{
	ShowIcon2(a,1);
	ShowIcon2(a,2);
	ShowIcon2(a,3);
	ShowIcon2(a,4);
	//ShowIcon(i,2);
	a<<=1;
	Delay_ms(200);
}
```

```
uint8 testi=0;
unsigned char a=0x01;
unsigned char b = 0;
void main(void)
{	
	asm("nop");
	asm("clrwdt");
	OSCCON = 0X70;
	OPTION_REG = 0;
	SysInit();
	GIE=1;  //全局中断
	InitialLed();
	TouchKeyInit_System();
	delay(10);
	//uart_init();
	//Pwm4Enable(); //test
	Buzzertime=0;
	WorkState=0;
	FreshLEDFlag=1;
	
	Pwm1Enable();
	Delay_ms(200);
	Pwm1Disable();
	//TRISA1 = 0;
	//Pwm1Enable();
	
	if(b==0) {b++;ShowIcon2(0xFF,3);}
	
	while(1)
	{	
		//asm("CLR PORTB");
		//SendNumx(0);
		// 1，实现按键功能（触摸）
		// 2，串口打印
		// 3，加入pwm
		
		/*Pwm1Enable();
		Delay_ms(200);
		Pwm1Disable();
		Delay_ms(200);*/
		//ShowIcon(0x80,1);
		//Delay_ms(200);
		
		/*for(i=0x01;i<16;i++)
		{
			ShowIcon2(a,1);
			ShowIcon2(a,2);
			ShowIcon2(a,3);
			ShowIcon2(a,4);
			//ShowIcon(i,2);
			a<<=1;
			Delay_ms(200);
		}*/
		
		/*ShowAllIcon();
		Delay_ms(500);
		DarkAllIcon();
		Delay_ms(500);*/
		
		/*Pwm1Enable();
		Pwm4Enable();*/
		
		if (B_MainLoop) {
			B_MainLoop = 0;
		//	CLRWDT();
			CheckTouchKey();

			Refurbish_Sfr();
			KeyServer();
			
			if(FreshLEDFlag==1) {ShowRealTime(SetRealTime);FreshLEDFlag=0;}
			
			if(WorkState!=0) Pwm4Enable();
			else if(WorkState==0) Pwm4Disable();			
		}
		if(WorkState==0) Pwm4Disable();	
		if(b!=0) {b=0;ShowIcon2(0xFF,3);}	
	}
}
```
实际上原理图上也已经写明了，L15 灯在 R3 上，R1、R2、R3 分别对应第 1、2、3 地址（0x68、0x6A、0x6D）
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_4.png]]





##### AXD-840 E

```

#define R 4  (300 ul)     //500 K  分压电阻
#define R 5  (240 ul)     //100 K
#define SARADC_FULLRANGE  (4095 ul) //adc 最大量程
#define SARADC_REFV     (180 ul)  //参考电压 avddr 2.4 v - acm 1.2 v = 1.8 v
#define V_OFFSET  ((g_s_func. E_power_type == DRY_BAT) ? ((uint 32_t) 282 ul) : ((uint 32_t) 267 ul)) //补偿 
#define V_OFFSET  ((g_s_func. E_power_type == DRY_BAT) ? ((uint 32_t) 292 ul) : ((uint 32_t) 267 ul)) //补偿 
#define V_OFFSET  ((g_s_func. E_power_type == DRY_BAT) ? ((uint 32_t) 296 ul) : ((uint 32_t) 267 ul)) //补偿 


#define CHECK_LIMIT (10 ul) //最小检测次数即取平均次数


//低电压触发阈值
#define LOW_BAT_VAL ((g_s_func. E_power_type == DRY_BAT) ? ((uint 32_t) 420) : ((uint 32_t) 340))
```


```
//BAT
//uint16  bat_val_table_BAT[] = {425, 490 , 575 ,0xffff};//最大 - 最小 / (格数 - 1) =  每格电压
uint16  bat_val_table_BAT[] = {425, 485 , 570 ,0xffff};//最大 - 最小 / (格数 - 1) =  每格电压
uint16  bat_val_table_BAT[] = {425, 485 , 565 ,0xffff};//最大 - 最小 / (格数 - 1) =  每格电压
//LI
uint16  bat_val_table[] = {300, 360 , 395 ,0xffff};//最大 - 最小 / (格数 - 1) =  每格电压
```


##### AXD-846 E, 修改记忆索引
遇到的现象：静音时，记忆只能查看平均记忆以及第一组记忆内容，索引值无法进行更新；声音开启时能够正常索引所有记忆内容。

爱芯达 AXD-846 E 改屏幕中文带房颤项目-BP 004C
修改内容：
1、修改上笔记忆显示中，脉搏的百位数据不显示的问题。
2、修改记忆组数为 4 组数据时长按记忆键显示第五组数据，高压 255，低压 255，心率 Hi 的问题。
3、修改记忆组数为 90 时长按记忆键记忆组数显示为 91，不会切换到第一组数据的问题。
4、修改记忆索引越界时，停留在第 1 笔记忆的问题。



![[../../annex/16.入职第十六周10.27-11.1(单休)_image_5.png]] 


Test
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_6.png]]

###### 01
```
/*BB=PUMP | VALVE;	
				iocontroloff();	
					IsAlgoEnd=1;
					testii++;
				SystolicValuew = 110+testii;
				//SystolicValue1b++;
				DiastolicValue = 60+testii;	
					
				PulseRate = 60+testii;
				ResultCode=0;
				AFFlag = 1;		*/
```


![[../../annex/16.入职第十六周10.27-11.1(单休)_image_7.png]]

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_8.png]]

###### 02
```
if(VoiceEnable==1)
	{
		//tomemorykeyinX(MemoryEndIndex);
		if(KEY_MEMORYUP)  SoundMemory();
		//if(VoiceStop) goto ChangeMemoryIndex2;	
	}

if(flag_tomemory_long_press==1)
{
	flag_tomemory_long_press = 0;
	goto ChangeMemoryIndex2;
}
```

###### 03
```tomemorykeyin
void tomemorykeyinX(unsigned char MemoryIndex)
{
//	unsigned char i;
	MemoryMode=1;
	if(last_memory_flag == 0)
	DarkAllIcon();
	last_memory_flag = 1;
	EEPROMin= MemoryIndex;
	readM24L16();
	PulseRam[1].b[0] = inbyte[0];  	/*systolic  pressure*/
	PulseRam[2].b[0] = inbyte[1];  	/*diastolic  pressure*/
	PulseRam[3].b[0] = inbyte[2];  	/*heart rate*/
    PulseRam[9].b[0] = inbyte[3];  	/*M0_data*/
	PulseRam[6].b[0] = inbyte[4];  	/*M1_hour*/
//	PulseRam[7].b[0] = inbyte[5];  	/*Minute*/
 	PulseRam[7].b[0] = (inbyte[5]&0x3f);  	/*Minute ?PAD????*/
	PulseRam[8].b[0] = (inbyte[6]&0x80);
	PulseRam[4].b[0] = (PulseRam[9].b[0]&0xc0)/64 + (PulseRam[6].b[0]&0xc0)/16;/*month*/
	PulseRam[5].b[0] = PulseRam[9].b[0]&0x1f;    /*date*/
	PulseRam[6].b[0] &= 0x1f;  	/*hour*/

	MemoryIconOn;//MarkMEMORY = 1;			//MR icon display
//	DIAIconOn;SYSIconOn;
	if (CuffDetect)
    {
        if((inbyte[5] & 0x40)==0x40)//CuffOKFlag 存放位置
            CuffOKFlag = 1;
        else
            CuffOKFlag = 0;
    }

    if (MoveDetect)
    {
        if((inbyte[3] & 0x20)==0x20)//MoveFlag 存放位置
            MoveFlag = 1;
        else
            MoveFlag = 0;
    }
	
	if((inbyte[4] & 0x20)==0x20)
		{AFFlag=1;}
	else
		{AFFlag=0;}	
	
	if((inbyte[5] & 0x80)==0x80)
		{PADFlag=1;}
	else
		{PADFlag=0;}

}

/**********************************************************/
void tomemorykeyin(void)
{
	unsigned char	i;
//Again:
	MemoryMode=1;

	Vioce_LBT_Flag = 1;
	last_memory_flag=0;
	HaveMemoryAvg=0;
	HaveMemoryAvg1=0;
	HaveMemoryFirst=1;
	MemoryClredFlag=0;
	Start_mmHgKpaFlag = 0;

	checkmemorybankAB();
	MemoryMode=1;
	EEPROMin = 0;
	readM24L16();
//**********************************************20110503????��??��????????����??????��??��??.
	MemoryEndIndex = inbyte[0]-1;		//reload first address	//??????��??��????????????index

	if(MemoryFull)	{MemoryIndex = MemorySet;}	//load memory count //???????��???? ????full,?��????.
	else			{MemoryIndex = MemoryEndIndex;}	//????????full,?����??��????????????????.

	if((MemoryEndIndex==0 && MemoryFull==0)||(ReadEepromError==1)||(MemoryEndIndex>MemorySet)) // No memory display "No M"
	{
		DarkAllIcon();
		AutoOffTimew=0;
		DisplayHalfByte(0x16,MemorySetTen); //n
		DisplayHalfByte(0x14,MemorySetSingle);//o
		MemoryIconOn;//MarkMEMORY = 1;			//MR icon display
		UserABDisplay();
		parting_line_off;
		
		do{}while(!KEY_MEMORYUP);
		delay(4);
		do{}while((AutoOffTimew <= 350)&&KEY_TIME&&KEY_POWER&&KEY_MEMORYUP);
		do{}while(!KEY_MEMORYUP||!KEY_TIME);
		delay(2);
		do{}while(!KEY_MEMORYUP||!KEY_TIME);
		goto TimeOver;
	}

	SysMeanEnd=DiaMeanEnd=PulseMeanEnd=0;
	if(MemoryFull==0)
		{
			if(AverageSet>MemoryEndIndex)
			{AverageSet=MemoryEndIndex;}
		}
		
//	if((MemoryEndIndex<3) && (!MemoryFull))
//	{
//		ShowMean = 0;
//	}				
		
	if(((MemoryEndIndex>0)||(MemoryFull==1))&&ShowMean)		//?????????????��??1,??????????????????,
		{
			DarkAllIcon();
			DisplayHalfByte(0x0a,MemorySetTen);  //????AV
			DisplayHalfByte(0x18,MemorySetSingle);
			for(i=0;i<AverageSet;i++)
				{
					EEPROMin = MemoryEndIndex;
					readM24L16();
					SysMeanEnd += inbyte[0];
					DiaMeanEnd += inbyte[1];
					PulseMeanEnd += inbyte[2];

                    MemoryEndIndex--;
                    if(MemoryEndIndex==0){MemoryEndIndex = MemorySet;}
                }

			SysMeanEnd /=AverageSet;
			DiaMeanEnd /= AverageSet;
			PulseMeanEnd /= AverageSet;
		}

//	while(KEY_TIME && KEY_POWER)		//????power or time key??��???,?��????????????
	while(KEY_POWER)					//20111211????power?��????????????
	{
//NextMem:
		if(HaveMemoryAvg==0)
		{
			HaveMemoryAvg1=1;

			EEPROMin = 0;
			readM24L16();
			MemoryEndIndex = inbyte[0]-1;		//reload first address	//??????��??��????????????index

			if(MemoryFull) 	MemoryIndex = MemorySet;	//load memory count //???????��???? ????full,?��????.
			else		MemoryIndex = MemoryEndIndex;	//????????full,?����??��????????????????.

			MemoryIndexBackup=MemoryIndex;
			MemoryEndIndexBackup=MemoryEndIndex;

			if(MemoryEndIndex >=1)
			{
				HaveMemoryAvg = 1;
				MemoryClredFlag=0;
				if(!ShowMean && MemoryIndex || HaveMemoryFirst==0) goto NoAverage;	//no display average
			}

            if ((unsigned char)PulseMeanEnd > MAX_PULSERATE)
            {
                DisplayHalfByte(0x11,PulseTen);          /* 'H' */
                DisplayHalfByte(0x12,PulseSingle);          /* 'I' */
                PulseMeanEnd = 0;
            }
            else if((unsigned char)PulseMeanEnd < MIN_PULSERATE)
            {
                DisplayHalfByte(0x13,PulseTen);          /* 'L' */
                DisplayHalfByte(0x14,PulseSingle);          /* 'O' */
                PulseMeanEnd = 0;
            }
            else 	DisplayToPUL((unsigned char)PulseMeanEnd);

			// DisplayToPUL((unsigned char)PulseMeanEnd);
			mmHgKpaDisplay((unsigned char)SysMeanEnd,(unsigned char)DiaMeanEnd);
			MemoryIconOn;					//MR icon display
//			DIAIconOn;SYSIconOn;
			UserABDisplay();
			if(WithWHO==1){ShowWHO(SysMeanEnd,DiaMeanEnd);}//20120317

//			DPDetect(SysMeanEnd,DiaMeanEnd);

			while(!KEY_MEMORYUP||!KEY_TIME);
			delay(8);
			while(!KEY_MEMORYUP||!KEY_TIME);
//*****************************************??????��?
			if(VoiceEnable==1)
				{
					SoundMemoryAVG();
					if(VoiceStop) goto ChangeMemoryIndex2;
				}
		}
//*****************************************??????��?
		else
		{
NoAverage:	HaveMemoryAvg1=0;
			DarkAllIcon();
//			DisplayToPUL(MemoryIndex);	//??????????????X??.

FastChangeLCD:
			DarkAllIcon();
			tomemorykeyinX(MemoryEndIndex);
            if (PulseRam[3].b[0] > MAX_PULSERATE)
            {
                DisplayHalfByte(0x11,PulseTen);          /* 'H' */
                DisplayHalfByte(0x12,PulseSingle);          /* 'I' */
            }
            else if(PulseRam[3].b[0] < MIN_PULSERATE)
            {
                DisplayHalfByte(0x13,PulseTen);          /* 'L' */
                DisplayHalfByte(0x14,PulseSingle);          /* 'O' */
            }
            else 	DisplayToPUL(PulseRam[3].b[0]);
            mmHgKpaDisplay(PulseRam[1].b[0],PulseRam[2].b[0]);
			
			DisplayToMemorySet(MemoryIndexBackup-MemoryIndex+1);	//记忆正翻1 2 3...
			
			
			
			// DisplayToMemorySet(MemoryIndex);
			UserABDisplay();
			if(!HaveMemoryAvg1 && !NoTimer)
				{ShowMemoryDate(PulseRam[4].b[0],PulseRam[5].b[0]);ShowMemoryTime(PulseRam[6].b[0],PulseRam[7].b[0]);}	//HH:MM

			if(WithWHO==1)
			{ShowWHO(PulseRam[1].b[0],PulseRam[2].b[0]);}	//20101226????WHO????
//			DPDetect(PulseRam[1].b[0],PulseRam[2].b[0]);
			if(PADEnable==1)
				{
					if(PADFlag==1)
						{PADIconOn;PADIconOn1;}
				}
				
			if (CuffDetect)
            {
                CuffIconOn;
                if(CuffOKFlag==1) 		//20221026 add
                {
					CuffIconOff;
                    OKIconOn;
                }
            }
            if (MoveDetect)
            {
                if(MoveFlag == 1)//MoveFlag
                    MoveIconOn;
            }	
						
				if(AFFlag)
				{
					 AFIconOn; 
				}
				else
				{
						AFIconOff;
				}
				
			Last_memory();
			last_memory_flag = 1;
				
//			while(!KEY_MEMORYUP||!KEY_TIME);
//			delay(3);
//*************************??????��?
			if(VoiceEnable==1)
				{
					if(KEY_MEMORYUP)  SoundMemory();	
				}
			
			if(flag_tomemory_long_press==1)
			{
				flag_tomemory_long_press = 0;
				goto ChangeMemoryIndex2;
			}
//*************************??????��?
		}

		AutoOffTimew=0;
		mtemp0c.b=0;
		mtemp1c.b=0;
		SecondFlag = 0;
		while(KEY_POWER)
		{
			while(KEY_MEMORYUP && KEY_TIME && KEY_POWER)
			{
				if(AutoOffTimew>AutoOffTimew_1_S_COUNT * 120) goto TimeOver;//查询记忆后无操作自动灭屏时间为3分59秒左右，和规定的4分钟灭屏只差1秒有点危险，需要调整，改为120s
				// if(AutoOffTimew>OFFTIME) goto TimeOver;
			}
//			delay(3);
			// if(!KEY_MEMORYUP || !KEY_POWER||!KEY_TIME) break;
			if(!KEY_MEMORYUP || !KEY_POWER) break;//20230404 bug_check_the_memory_and_press_the_set_button_replay_the_message
		}
ChangeMemoryIndex2:
		if(!KEY_POWER) goto TimeOver;

				if(HaveMemoryFirst==1 && ShowMean==1&&!KEY_MEMORYUP){goto 	NoChangeMemoryIndex;}

				// AutoOffTimew=0;
				if(!KEY_MEMORYUP)
				{
					// while(!KEY_MEMORYUP&&(AutoOffTimew<125));
					// if(AutoOffTimew>124)
					// 	{
					// 		DelOneMemory();
					// 		if(EmptyFlSag)	{EmptyFlag=0;goto Again;}
					// 		HaveMemoryFirst=0;
					// 		goto NextMem;
					// 	}
					
					MemoryIndex--;
					if(MemoryIndex > 250) MemoryIndex = 0;
					MemoryEndIndex--;
					if(MemoryEndIndex > 250) MemoryEndIndex = 0;

					//if(MemoryEndIndex == 0) MemoryEndIndex = MemorySet;
					//if(MemoryIndex == 0) HaveMemoryAvg=0;
					
					if(MemoryFull == 0)
					{
						if(MemoryIndex ==0) MemoryIndex = MemoryIndexBackup;
						if(MemoryEndIndex  ==0) MemoryEndIndex = MemoryEndIndexBackup;
					}
					else
					{
						if(MemoryIndex ==0) MemoryIndex = MemorySet;
						if(MemoryEndIndex  ==0) MemoryEndIndex = MemorySet;
					}
					
					delay(15);
					while(!KEY_MEMORYUP)
					{
							if ( AutoOffTimew >TWO)
							{
								flag_tomemory_long_press=1;
								goto FastChangeLCD;
							}
							else
							{
								flag_tomemory_long_press=0;
								goto FastChangeLCD;
							}
					}
				}

				// if(!KEY_MEMORYUP)
				// 	{
				// 		MemoryIndex++;
				// 		if(MemoryIndex >MemoryIndexBackup) MemoryIndex=1;
				// 		MemoryEndIndex++;
				// 		if(MemoryFull==0)
				// 			{
				// 				if(MemoryEndIndex >MemoryEndIndexBackup) MemoryEndIndex = 1;
				// 			}
				// 		else{if(MemoryEndIndex >MemorySet) MemoryEndIndex = 1;}
				// 	//	if(MemoryEndIndex == 0) MemoryEndIndex = MemorySet;
				// 	//	if(MemoryIndex == 0) HaveMemoryAvg=0;
				// 	}

NoChangeMemoryIndex:
		HaveMemoryFirst=0;  //???????��??????,????????????.
		ShowMean = 0;
		while(!KEY_MEMORYUP ||!KEY_TIME);
		delay(3);
		while(!KEY_MEMORYUP ||!KEY_TIME);
	}
	HaveMemoryAvg=0;

TimeOver:
	DarkAllIcon();
	MemoryMode=0;
	Vioce_LBT_Flag = 0;
}
```

###### 04
```
void totimekeyin(void)
{
	unsigned char i=0;
	IsPowerOn = 1;
	AutoOffTimew = 0;
	UserABDisplay();
	parting_line_off;
	
	CheckBatteryADC();
	delay(2);
	ShowBTBar();
	// while(!KEY_TIME);
	// delay(2);
	// while(!KEY_TIME);
/*
	do									//??mmHg?Kpa??
		{
			mmHgKpaSetDisplay();
			AutoOffTimew = 0;
			do{
				if(AutoOffTimew > OFFTIME){goto ToTimeOver;}
			  }while( KEY_MEMORYUP&& KEY_TIME && KEY_POWER);


					if( !KEY_MEMORYUP)
						{
							if(mmHgkPaFlag==1)
								{
									mmHgkPaFlag=0;
								}
							else{mmHgkPaFlag=1;}
							mmHgKpaSetDisplay();
							while( !KEY_MEMORYUP);
							delay(4);
						}




					if(!KEY_POWER) {IsPowerOn=0; goto ToTimeOver;}


		}while(KEY_TIME);

	while(!KEY_TIME);
	delay(2);
	while(!KEY_TIME);
*/
	
	if(flag_first_power_up == 1)  goto SET_TIME;

	DarkAllIcon();

  ShowBTBar();
	Voice_Display();
goto SET_VOICE;
		do								//??UserA?userB
		{
            while (!KEY_TIME)
            {
                flash_UserAB();
								parting_line_off;
            }
			AutoOffTimew = 0;
			do{
                flash_UserAB();
								parting_line_off;
				if(AutoOffTimew > OFFTIME){goto ToTimeOver;}
			  }
			while( KEY_MEMORYUP&& KEY_TIME && KEY_POWER);


					if(  !KEY_MEMORYUP)
						{
							if(UserA==1)
								{
									UserA=0;
								}
							else{UserA=1;}
							UserABDisplay();
							parting_line_off;
							while(  !KEY_MEMORYUP);
							delay(4);
						}

					if(!KEY_POWER) {IsPowerOn=0; goto ToTimeOver;}
		}while(KEY_TIME);
		Flash_SET_Flag = 0;
SET_TIME:
		
		TimeSetThreeKey();
		

		if(KEY_POWER==0||!IsPowerOn){goto ToTimeOver;}
SET_VOICE:			
		if(VoiceType>NO)
		{
		DarkAllIcon();
		AutoOffTimew = 0;
		ShowVoice();
		while(!KEY_TIME);
		delay(2);
		while(!KEY_TIME);
	ShowBTBar();
	Voice_Display();
		do									//????
			{				
				AutoOffTimew = 0;
				do{
					flash_voiceonoff();
					parting_line_off;
					if(AutoOffTimew > OFFTIME){goto ToTimeOver;}
					}while( KEY_MEMORYUP&& KEY_TIME && KEY_POWER);
			
						if( !KEY_MEMORYUP)
						{
							if(VoiceEnable==1)
							{
								VoiceEnable=0;
							}
							else{VoiceEnable=1;}
							ShowVoice();				
							while(!KEY_MEMORYUP);
							delay(2);
						}
						if(KEY_POWER==0){goto ToTimeOver;}
			}while(KEY_TIME);		

		while(!KEY_TIME);
		delay(4);
		}		

		DarkAllIcon();
		while(!KEY_TIME);
		delay(2);
		while(!KEY_TIME);
	ShowBTBar();
	Voice_Display();
		do									//??mmHg?Kpa??
		{
			mmHgKpaSetDisplay();
			AutoOffTimew = 0;
			do{
				flash_mmghkpa();
				parting_line_off;
				if(AutoOffTimew > OFFTIME){goto ToTimeOver;}
			  }while( KEY_MEMORYUP&& KEY_TIME && KEY_POWER);


					if( !KEY_MEMORYUP)
						{
							if(mmHgkPaFlag==1)
								{
									mmHgkPaFlag=0;
								}
							else{mmHgkPaFlag=1;}
							mmHgKpaSetDisplay();
							while( !KEY_MEMORYUP);
							delay(4);
						}
					if(!KEY_POWER) {IsPowerOn=0; goto ToTimeOver;}
		}while(KEY_TIME);

//************************************************????????
/*
		AutoOffTimew = 0;
		DarkAllIcon();
		do{
				DisplayHalfByte(0x0c,DIATen);		// 'C'
	    	DisplayHalfByte(0x13,DIASingle);	// 'L'
	    	if(AutoOffTimew > OFFTIME){goto ToTimeOver;}
	    	delay(2);
	    	}while(KEY_POWER&&KEY_TIME);
		if(!KEY_POWER)
			{
				CLRMemoryBank();
				flashCL();		//CL flash
			}
		while(!KEY_TIME);
		delay(4);
*/
ToTimeOver:
		IsPowerOn=0;
		DarkAllIcon();
		for(i=0;i<3;i++)
			{
				EEPROMin = 0xFB+i;
				readM24L16();
				outbyte[0]=inbyte[0];
				outbyte[1]=inbyte[1];
				outbyte[2]=inbyte[2];
				if(mmHgkPaFlag==1){outbyte[3]=inbyte[3]|0x01;}
				else{outbyte[3]=inbyte[3]&0xfe;}

				if(UserA==1){outbyte[4]=inbyte[4]|0x08;}
				else{outbyte[4]=inbyte[4]&0xf7;}

				if(VoiceEnable) outbyte[4]=outbyte[4]|0x10;
				else outbyte[4]=outbyte[4]&0xEF;

				outbyte[5]=volume_value; //save volume
				outbyte[6]=inbyte[6]; //NC
				writeM24L16();
			}
}
```

###### 05
```
//if(MemoryIndex == 0) HaveMemoryAvg=0;  //索引越界后重新索引,并停留在松开按键时索引的记忆位置;取消注释则越界后停留在第1笔记忆
```













































































































































