
##### PWM 简单讲解

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_1.png]]

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_2.png]]

PWM 最重要的参数一个是占空比，就是周期内高电平持续的时间。
第二个就是频率，就是 1 秒产生多少个周期

蜂鸣器上，频率主要调节音调高低，占空比调节音量大小
雾化器这个上面，电机驱动的话，占空比控制出雾量，频率好像控制转动产生的噪声
不过理论上可以用代码让他一直快速翻转电平，模拟实现 PWM

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_3.jpg]]


AXD-303A,我之前试着用软件去模拟输出 PWM，发现直接驱动不了，主要原因就是这玩意本质就是高速开关电路，但是303A 是继电器开关，继电器不支持 us 级别高速开关，所以直接就用不了。一般好像用 mos 管


##### 雾化器 N300修改为 2 个触摸按键，并增加 1个 LED 灯
雾化器 N300 由3 个触摸按键修改为 2 个触摸按键，并增加了一个电源通电的 LED 灯
该 LED 灯在第 3 个地址处，所以一直没能点亮，方法也用错了。
给所有地址赋值后全亮 (全显函数可亮)，应该通过位偏移逐个点亮 LED 灯的方式去推断新增的 LED 灯所处的地址是哪里。

```
for(i=0x01;i<16;i++)
{
	ShowIcon2(a,1);
	ShowIcon2(a,2);
	ShowIcon2(a,3);
	ShowIcon2(a,4);
	//ShowIcon(i,2);
	a<<=1;
	Delay_ms(200);
}
```

```
uint8 testi=0;
unsigned char a=0x01;
unsigned char b = 0;
void main(void)
{	
	asm("nop");
	asm("clrwdt");
	OSCCON = 0X70;
	OPTION_REG = 0;
	SysInit();
	GIE=1;  //全局中断
	InitialLed();
	TouchKeyInit_System();
	delay(10);
	//uart_init();
	//Pwm4Enable(); //test
	Buzzertime=0;
	WorkState=0;
	FreshLEDFlag=1;
	
	Pwm1Enable();
	Delay_ms(200);
	Pwm1Disable();
	//TRISA1 = 0;
	//Pwm1Enable();
	
	if(b==0) {b++;ShowIcon2(0xFF,3);}
	
	while(1)
	{	
		//asm("CLR PORTB");
		//SendNumx(0);
		// 1，实现按键功能（触摸）
		// 2，串口打印
		// 3，加入pwm
		
		/*Pwm1Enable();
		Delay_ms(200);
		Pwm1Disable();
		Delay_ms(200);*/
		//ShowIcon(0x80,1);
		//Delay_ms(200);
		
		/*for(i=0x01;i<16;i++)
		{
			ShowIcon2(a,1);
			ShowIcon2(a,2);
			ShowIcon2(a,3);
			ShowIcon2(a,4);
			//ShowIcon(i,2);
			a<<=1;
			Delay_ms(200);
		}*/
		
		/*ShowAllIcon();
		Delay_ms(500);
		DarkAllIcon();
		Delay_ms(500);*/
		
		/*Pwm1Enable();
		Pwm4Enable();*/
		
		if (B_MainLoop) {
			B_MainLoop = 0;
		//	CLRWDT();
			CheckTouchKey();

			Refurbish_Sfr();
			KeyServer();
			
			if(FreshLEDFlag==1) {ShowRealTime(SetRealTime);FreshLEDFlag=0;}
			
			if(WorkState!=0) Pwm4Enable();
			else if(WorkState==0) Pwm4Disable();			
		}
		if(WorkState==0) Pwm4Disable();	
		if(b!=0) {b=0;ShowIcon2(0xFF,3);}	
	}
}
```
实际上原理图上也已经写明了，L15 灯在 R3 上，R1、R2、R3 分别对应第 1、2、3 地址（0x68、0x6A、0x6D）
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_4.png]]

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_5.png]]





##### AXD-840 E

g_s_set.flag_spk_on_off

###### 电量格数显示问题
```

#define R 4  (300 ul)     //500 K  分压电阻
#define R 5  (240 ul)     //100 K
#define SARADC_FULLRANGE  (4095 ul) //adc 最大量程
#define SARADC_REFV     (180 ul)  //参考电压 avddr 2.4 v - acm 1.2 v = 1.8 v
#define V_OFFSET  ((g_s_func. E_power_type == DRY_BAT) ? ((uint 32_t) 282 ul) : ((uint 32_t) 267 ul)) //补偿 
#define V_OFFSET  ((g_s_func. E_power_type == DRY_BAT) ? ((uint 32_t) 292 ul) : ((uint 32_t) 267 ul)) //补偿 
#define V_OFFSET  ((g_s_func. E_power_type == DRY_BAT) ? ((uint 32_t) 296 ul) : ((uint 32_t) 267 ul)) //补偿 


#define CHECK_LIMIT (10 ul) //最小检测次数即取平均次数


//低电压触发阈值
#define LOW_BAT_VAL ((g_s_func. E_power_type == DRY_BAT) ? ((uint 32_t) 420) : ((uint 32_t) 340))
```


```
//BAT
//uint16  bat_val_table_BAT[] = {425, 490 , 575 ,0xffff};//最大 - 最小 / (格数 - 1) =  每格电压
uint16  bat_val_table_BAT[] = {425, 485 , 570 ,0xffff};//最大 - 最小 / (格数 - 1) =  每格电压
uint16  bat_val_table_BAT[] = {425, 485 , 565 ,0xffff};//最大 - 最小 / (格数 - 1) =  每格电压
//LI
uint16  bat_val_table[] = {300, 360 , 395 ,0xffff};//最大 - 最小 / (格数 - 1) =  每格电压
```

AXD-840 E 锂电款，20251101 测量结果（实际电压与测量结果的数据对比）
可通过调节补偿值、实际电阻值去调整计算公式
实际电压值    --  测量计算结果
335 (3.35 V)--  330 (3.30 V) 
338 (3.38 V)--  331 (3.31 V)
340 (3.40 V)--  333 (3.33 V)
345 (3.45 V)--  335 (3.35 V)
360 (3.60 V)--  356 (3.56 V)
390 (3.90 V)--  385/382 (3.85 V/3.82 V)

调整补偿值后：
344-341 报低电
345--347 一格
358--360 两格
387--390 三格

###### 晶华微烧录器烧录时，电压为3.26V
晶华微烧录器烧录时，电压为 3.26 V。即，烧录时工作电压为 3.26 V ，待机（接线，但未点击软件进行烧录时，电压为 0 V，估计是直接不输出，识别到有烧录通信、需要烧录程序到机器上时才会输出电压进行烧录）


###### AXD-840 E 的 LCD 屏参数
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_6.png]]

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_7.png]]

爱芯达 AXD-840 E 下降式干锂电共 PCB 中文语音-BP 00 B（锂电款）
修改内容：
1、记忆模式下，增加按 SET 键进行向下索引记忆、长按 SET 键快翻向下索引。
2、低影重、频闪，修改了 LCD 的配置（改为 3 V 3，64 分频）。
3、修改了电压补偿值和电量显示阈值。
4、修改、增加了充电情况下，开关键不测量、其他按键有对应功能。

待修改内容：
1、心率不齐和房颤需要分开显示（同时测出时只显示房颤）。
2、测试反馈说，还是有概率同时测量出心律不齐和房颤。

###### SET 键记忆索引问题

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_8.png]]



```
if (KEY_MEM == 0)
        {
            if (flag_first_single_mem == 0)
            {
                //平均记忆跳转查第一组不需要改变下标
                flag_first_single_mem = 1;
							Fresh_timecolon_flag = 2;
                if (KEY_MEM == 0)//清除记忆
			    {
                    off_time_tick_clr();
                    while (KEY_MEM == 0)	//MEM键长按检测(快翻功能)
				    {
                        if (KEY_MEM == 0 && KEY_POWER == 1)
                        {
                            if (get_cur_off_time_tick() > OFF_TIME_TICK_1S_COUNT * 2)
						    {
                                // sys_icon_off;
                                // sys_mmhg_icon_off;
                                // sys_point_icon_off;
                                aky_disp_clear_all();
                                line_icon_on;
                                avg_mid_new_on;
                                show_voice();
                                disp_user_icon(g_s_set.e_user);
						    	goto men_next2;
						    }
                        }
                    }
                    wait_all_key_release();
                }
            }
            else
            {
                if (KEY_MEM == 0)//清除记忆
			    {
                    off_time_tick_clr();
                    while (KEY_MEM == 0)	//MEM键长按检测(快翻功能)
                    {
                        if(KEY_MEM == 0 && KEY_POWER == 1)
					    {
					    	if (get_cur_off_time_tick() > OFF_TIME_TICK_1S_COUNT * 2)
					    	{
                                aky_disp_clear_all();
                                line_icon_on;
                                avg_mid_new_on;
                                show_voice();
                                disp_user_icon(g_s_set.e_user);
					    		goto men_next;
					    	}
					    }
                    }
                    
                }
men_next:
                //正向查记忆
                s_mem_index_temp.cur_mem_index--;
                if (s_mem_index_temp.cur_mem_index == 0)	//边界检查与处理
                {
                    if (s_mem_index_const.flag_mem_overwrite == 1)
                    {
                        s_mem_index_temp.cur_mem_index = s_mem_index_const.mem_set;	//记忆已满
                    }
                    else
                    {
                        s_mem_index_temp.cur_mem_index = s_mem_index_const.cur_mem_index;	//记忆未满
                    }
                }
            }
            while (KEY_POWER == 0 || KEY_MEM == 0)	//等待按键释放,同时检测快翻
            {
                while (KEY_MEM == 0)
                {
                    if (get_cur_off_time_tick() > OFF_TIME_TICK_1S_COUNT * 1)
					{
                        men_next2:
                        // aky_disp_clear_all();
						g_s_mem = flash_get_mem_data(g_s_set.e_user, s_mem_index_temp.cur_mem_index, &g_e_flash_err, MAIN_ADDR);	// 快翻模式：快速显示下一条记忆
						// disp_result_sys_dia(g_s_mem);
						// show_who(g_s_mem);

						// disp_to_pul(g_s_mem.pul, 1);
                        // if(g_s_mem.flag_AFF ==1)
			            // {
			            // 	AFIconOn;
			            // }
			            // else
			            // {
			            // 	AFIconOff;
			            // }	
                        // pad_icon_off;
						// flash_disp_pad_cuff_move_control(g_s_mem, 1); // 显示pad ，不显示cuff move
						// flash_disp_pul_hight_low_control(g_s_mem, 1); //
						// if (g_s_func.e_time_sys != NO_TIME_DISP)
						// {
						// 	disp_mon_day(g_s_mem.s_time, 1);
						// 	disp_hour_min(g_s_mem.s_time, 1);
						// }
						if (s_mem_index_const.flag_mem_overwrite == 1)	// 计算并显示记忆序号
						{
							if (s_mem_index_temp.cur_mem_index <= s_mem_index_const.cur_mem_index)
							{
								disp_to_mem_set((s_mem_index_const.cur_mem_index - s_mem_index_temp.cur_mem_index) + 1, 1);
							}
							else
							{
								disp_to_mem_set(s_mem_index_const.mem_set - ((s_mem_index_temp.cur_mem_index - s_mem_index_const.cur_mem_index) - 1), 1);
							}
						}
						else
						{
							disp_to_mem_set((s_mem_index_const.cur_mem_index - s_mem_index_temp.cur_mem_index) + 1, 1);
						}
						aky_tick_delay_ms(300);
						goto men_next;			// 继续快翻		
					}
                }
                off_time_tick_clr();
                    
            }
        }
        else if (KEY_SET == 0)
				{
            if (flag_first_single_mem == 0)
            {
                flag_first_single_mem = 1;
							Fresh_timecolon_flag = 2;
							s_mem_index_temp.cur_mem_index=1;		//平均记忆跳转查第一组需要改变下标
                if (KEY_SET == 0)
			    {
                    off_time_tick_clr();
                    while (KEY_SET == 0)	//SET键长按检测(快翻功能)
				    {
                        if (KEY_SET == 0 && KEY_POWER == 1)
                        {
                            if (get_cur_off_time_tick() > OFF_TIME_TICK_1S_COUNT * 2)
						    {
                                // sys_icon_off;
                                // sys_mmhg_icon_off;
                                // sys_point_icon_off;
                                aky_disp_clear_all();
                                line_icon_on;
                                avg_mid_new_on;
                                show_voice();
                                disp_user_icon(g_s_set.e_user);
						    	goto men_next4;
						    }
                        }
                    }
                    wait_all_key_release();
                }
            }
            else
            {
                if (KEY_SET == 0)//清除记忆
			    {
                    off_time_tick_clr();
                    while (KEY_SET == 0)	//SET键长按检测(快翻功能)
                    {
                        if(KEY_SET == 0 && KEY_POWER == 1)
					    {
					    	if (get_cur_off_time_tick() > OFF_TIME_TICK_1S_COUNT * 2)
					    	{
                                aky_disp_clear_all();
                                line_icon_on;
                                avg_mid_new_on;
                                show_voice();
                                disp_user_icon(g_s_set.e_user);
					    		goto men_next3;
					    	}
					    }
                    }
                    
                }
men_next3:
                //反向查记忆
                s_mem_index_temp.cur_mem_index++;
                if (s_mem_index_temp.cur_mem_index > s_mem_index_const.cur_mem_index)	//边界检查与处理
                {
                    if (s_mem_index_const.flag_mem_overwrite == 1)
                    {
                        if(s_mem_index_temp.cur_mem_index > s_mem_index_const.mem_set)//记忆已满
												{
													s_mem_index_temp.cur_mem_index = 1;
												}													
                    }
                    else
                    {
                        s_mem_index_temp.cur_mem_index = 1;	//记忆未满
                    }
                }
            }
            while (KEY_POWER == 0 || KEY_SET == 0)	//等待按键释放,同时检测快翻
            {
                while (KEY_SET == 0)
                {
                    if (get_cur_off_time_tick() > OFF_TIME_TICK_1S_COUNT * 1)
					{
                        men_next4:
                        // aky_disp_clear_all();
						g_s_mem = flash_get_mem_data(g_s_set.e_user, s_mem_index_temp.cur_mem_index, &g_e_flash_err, MAIN_ADDR);	// 快翻模式：快速显示下一条记忆
						// disp_result_sys_dia(g_s_mem);
						// show_who(g_s_mem);

						// disp_to_pul(g_s_mem.pul, 1);
                        // if(g_s_mem.flag_AFF ==1)
			            // {
			            // 	AFIconOn;
			            // }
			            // else
			            // {
			            // 	AFIconOff;
			            // }	
                        // pad_icon_off;
						// flash_disp_pad_cuff_move_control(g_s_mem, 1); // 显示pad ，不显示cuff move
						// flash_disp_pul_hight_low_control(g_s_mem, 1); //
						// if (g_s_func.e_time_sys != NO_TIME_DISP)
						// {
						// 	disp_mon_day(g_s_mem.s_time, 1);
						// 	disp_hour_min(g_s_mem.s_time, 1);
						// }
						if (s_mem_index_const.flag_mem_overwrite == 1)	// 计算并显示记忆序号
						{
							if (s_mem_index_temp.cur_mem_index <= s_mem_index_const.cur_mem_index)
							{
								disp_to_mem_set((s_mem_index_const.cur_mem_index - s_mem_index_temp.cur_mem_index) + 1, 1);
							}
							else
							{
								disp_to_mem_set(s_mem_index_const.mem_set - ((s_mem_index_temp.cur_mem_index - s_mem_index_const.cur_mem_index) - 1), 1);
							}
						}
						else
						{
							disp_to_mem_set((s_mem_index_const.cur_mem_index - s_mem_index_temp.cur_mem_index) + 1, 1);
						}
						aky_tick_delay_ms(300);
						goto men_next3;			// 继续快翻		
					}
                }
                off_time_tick_clr();
                    
            }
        }
```




##### AXD-846 E, 修改记忆索引
遇到的现象：静音时，记忆只能查看平均记忆以及第一组记忆内容，索引值无法进行更新；声音开启时能够正常索引所有记忆内容。

爱芯达 AXD-846 E 改屏幕中文带房颤项目-BP 004C
修改内容：
1、修改上笔记忆显示中，脉搏的百位数据不显示的问题。
2、修改记忆组数为 4 组数据时长按记忆键显示第五组数据，高压 255，低压 255，心率 Hi 的问题。
3、修改记忆组数为 90 时长按记忆键记忆组数显示为 91，不会切换到第一组数据的问题。
4、修改记忆索引越界时，停留在第 1 笔记忆的问题。



![[../../annex/16.入职第十六周10.27-11.1(单休)_image_9.png]] 


Test
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_10.png]]

###### 01
```
/*BB=PUMP | VALVE;	
				iocontroloff();	
					IsAlgoEnd=1;
					testii++;
				SystolicValuew = 110+testii;
				//SystolicValue1b++;
				DiastolicValue = 60+testii;	
					
				PulseRate = 60+testii;
				ResultCode=0;
				AFFlag = 1;		*/
```


![[../../annex/16.入职第十六周10.27-11.1(单休)_image_11.png]]

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_12.png]]

###### 02
```
if(VoiceEnable==1)
	{
		//tomemorykeyinX(MemoryEndIndex);
		if(KEY_MEMORYUP)  SoundMemory();
		//if(VoiceStop) goto ChangeMemoryIndex2;	
	}

if(flag_tomemory_long_press==1)
{
	flag_tomemory_long_press = 0;
	goto ChangeMemoryIndex2;
}
```

###### 03
```tomemorykeyin
void tomemorykeyinX(unsigned char MemoryIndex)
{
//	unsigned char i;
	MemoryMode=1;
	if(last_memory_flag == 0)
	DarkAllIcon();
	last_memory_flag = 1;
	EEPROMin= MemoryIndex;
	readM24L16();
	PulseRam[1].b[0] = inbyte[0];  	/*systolic  pressure*/
	PulseRam[2].b[0] = inbyte[1];  	/*diastolic  pressure*/
	PulseRam[3].b[0] = inbyte[2];  	/*heart rate*/
    PulseRam[9].b[0] = inbyte[3];  	/*M0_data*/
	PulseRam[6].b[0] = inbyte[4];  	/*M1_hour*/
//	PulseRam[7].b[0] = inbyte[5];  	/*Minute*/
 	PulseRam[7].b[0] = (inbyte[5]&0x3f);  	/*Minute ?PAD????*/
	PulseRam[8].b[0] = (inbyte[6]&0x80);
	PulseRam[4].b[0] = (PulseRam[9].b[0]&0xc0)/64 + (PulseRam[6].b[0]&0xc0)/16;/*month*/
	PulseRam[5].b[0] = PulseRam[9].b[0]&0x1f;    /*date*/
	PulseRam[6].b[0] &= 0x1f;  	/*hour*/

	MemoryIconOn;//MarkMEMORY = 1;			//MR icon display
//	DIAIconOn;SYSIconOn;
	if (CuffDetect)
    {
        if((inbyte[5] & 0x40)==0x40)//CuffOKFlag 存放位置
            CuffOKFlag = 1;
        else
            CuffOKFlag = 0;
    }

    if (MoveDetect)
    {
        if((inbyte[3] & 0x20)==0x20)//MoveFlag 存放位置
            MoveFlag = 1;
        else
            MoveFlag = 0;
    }
	
	if((inbyte[4] & 0x20)==0x20)
		{AFFlag=1;}
	else
		{AFFlag=0;}	
	
	if((inbyte[5] & 0x80)==0x80)
		{PADFlag=1;}
	else
		{PADFlag=0;}

}

/**********************************************************/
void tomemorykeyin(void)
{
	unsigned char	i;
//Again:
	MemoryMode=1;

	Vioce_LBT_Flag = 1;
	last_memory_flag=0;
	HaveMemoryAvg=0;
	HaveMemoryAvg1=0;
	HaveMemoryFirst=1;
	MemoryClredFlag=0;
	Start_mmHgKpaFlag = 0;

	checkmemorybankAB();
	MemoryMode=1;
	EEPROMin = 0;
	readM24L16();
//**********************************************20110503????��??��????????����??????��??��??.
	MemoryEndIndex = inbyte[0]-1;		//reload first address	//??????��??��????????????index

	if(MemoryFull)	{MemoryIndex = MemorySet;}	//load memory count //???????��???? ????full,?��????.
	else			{MemoryIndex = MemoryEndIndex;}	//????????full,?����??��????????????????.

	if((MemoryEndIndex==0 && MemoryFull==0)||(ReadEepromError==1)||(MemoryEndIndex>MemorySet)) // No memory display "No M"
	{
		DarkAllIcon();
		AutoOffTimew=0;
		DisplayHalfByte(0x16,MemorySetTen); //n
		DisplayHalfByte(0x14,MemorySetSingle);//o
		MemoryIconOn;//MarkMEMORY = 1;			//MR icon display
		UserABDisplay();
		parting_line_off;
		
		do{}while(!KEY_MEMORYUP);
		delay(4);
		do{}while((AutoOffTimew <= 350)&&KEY_TIME&&KEY_POWER&&KEY_MEMORYUP);
		do{}while(!KEY_MEMORYUP||!KEY_TIME);
		delay(2);
		do{}while(!KEY_MEMORYUP||!KEY_TIME);
		goto TimeOver;
	}

	SysMeanEnd=DiaMeanEnd=PulseMeanEnd=0;
	if(MemoryFull==0)
		{
			if(AverageSet>MemoryEndIndex)
			{AverageSet=MemoryEndIndex;}
		}
		
//	if((MemoryEndIndex<3) && (!MemoryFull))
//	{
//		ShowMean = 0;
//	}				
		
	if(((MemoryEndIndex>0)||(MemoryFull==1))&&ShowMean)		//?????????????��??1,??????????????????,
		{
			DarkAllIcon();
			DisplayHalfByte(0x0a,MemorySetTen);  //????AV
			DisplayHalfByte(0x18,MemorySetSingle);
			for(i=0;i<AverageSet;i++)
				{
					EEPROMin = MemoryEndIndex;
					readM24L16();
					SysMeanEnd += inbyte[0];
					DiaMeanEnd += inbyte[1];
					PulseMeanEnd += inbyte[2];

                    MemoryEndIndex--;
                    if(MemoryEndIndex==0){MemoryEndIndex = MemorySet;}
                }

			SysMeanEnd /=AverageSet;
			DiaMeanEnd /= AverageSet;
			PulseMeanEnd /= AverageSet;
		}

//	while(KEY_TIME && KEY_POWER)		//????power or time key??��???,?��????????????
	while(KEY_POWER)					//20111211????power?��????????????
	{
//NextMem:
		if(HaveMemoryAvg==0)
		{
			HaveMemoryAvg1=1;

			EEPROMin = 0;
			readM24L16();
			MemoryEndIndex = inbyte[0]-1;		//reload first address	//??????��??��????????????index

			if(MemoryFull) 	MemoryIndex = MemorySet;	//load memory count //???????��???? ????full,?��????.
			else		MemoryIndex = MemoryEndIndex;	//????????full,?����??��????????????????.

			MemoryIndexBackup=MemoryIndex;
			MemoryEndIndexBackup=MemoryEndIndex;

			if(MemoryEndIndex >=1)
			{
				HaveMemoryAvg = 1;
				MemoryClredFlag=0;
				if(!ShowMean && MemoryIndex || HaveMemoryFirst==0) goto NoAverage;	//no display average
			}

            if ((unsigned char)PulseMeanEnd > MAX_PULSERATE)
            {
                DisplayHalfByte(0x11,PulseTen);          /* 'H' */
                DisplayHalfByte(0x12,PulseSingle);          /* 'I' */
                PulseMeanEnd = 0;
            }
            else if((unsigned char)PulseMeanEnd < MIN_PULSERATE)
            {
                DisplayHalfByte(0x13,PulseTen);          /* 'L' */
                DisplayHalfByte(0x14,PulseSingle);          /* 'O' */
                PulseMeanEnd = 0;
            }
            else 	DisplayToPUL((unsigned char)PulseMeanEnd);

			// DisplayToPUL((unsigned char)PulseMeanEnd);
			mmHgKpaDisplay((unsigned char)SysMeanEnd,(unsigned char)DiaMeanEnd);
			MemoryIconOn;					//MR icon display
//			DIAIconOn;SYSIconOn;
			UserABDisplay();
			if(WithWHO==1){ShowWHO(SysMeanEnd,DiaMeanEnd);}//20120317

//			DPDetect(SysMeanEnd,DiaMeanEnd);

			while(!KEY_MEMORYUP||!KEY_TIME);
			delay(8);
			while(!KEY_MEMORYUP||!KEY_TIME);
//*****************************************??????��?
			if(VoiceEnable==1)
				{
					SoundMemoryAVG();
					if(VoiceStop) goto ChangeMemoryIndex2;
				}
		}
//*****************************************??????��?
		else
		{
NoAverage:	HaveMemoryAvg1=0;
			DarkAllIcon();
//			DisplayToPUL(MemoryIndex);	//??????????????X??.

FastChangeLCD:
			DarkAllIcon();
			tomemorykeyinX(MemoryEndIndex);
            if (PulseRam[3].b[0] > MAX_PULSERATE)
            {
                DisplayHalfByte(0x11,PulseTen);          /* 'H' */
                DisplayHalfByte(0x12,PulseSingle);          /* 'I' */
            }
            else if(PulseRam[3].b[0] < MIN_PULSERATE)
            {
                DisplayHalfByte(0x13,PulseTen);          /* 'L' */
                DisplayHalfByte(0x14,PulseSingle);          /* 'O' */
            }
            else 	DisplayToPUL(PulseRam[3].b[0]);
            mmHgKpaDisplay(PulseRam[1].b[0],PulseRam[2].b[0]);
			
			DisplayToMemorySet(MemoryIndexBackup-MemoryIndex+1);	//记忆正翻1 2 3...
			
			
			
			// DisplayToMemorySet(MemoryIndex);
			UserABDisplay();
			if(!HaveMemoryAvg1 && !NoTimer)
				{ShowMemoryDate(PulseRam[4].b[0],PulseRam[5].b[0]);ShowMemoryTime(PulseRam[6].b[0],PulseRam[7].b[0]);}	//HH:MM

			if(WithWHO==1)
			{ShowWHO(PulseRam[1].b[0],PulseRam[2].b[0]);}	//20101226????WHO????
//			DPDetect(PulseRam[1].b[0],PulseRam[2].b[0]);
			if(PADEnable==1)
				{
					if(PADFlag==1)
						{PADIconOn;PADIconOn1;}
				}
				
			if (CuffDetect)
            {
                CuffIconOn;
                if(CuffOKFlag==1) 		//20221026 add
                {
					CuffIconOff;
                    OKIconOn;
                }
            }
            if (MoveDetect)
            {
                if(MoveFlag == 1)//MoveFlag
                    MoveIconOn;
            }	
						
				if(AFFlag)
				{
					 AFIconOn; 
				}
				else
				{
						AFIconOff;
				}
				
			Last_memory();
			last_memory_flag = 1;
				
//			while(!KEY_MEMORYUP||!KEY_TIME);
//			delay(3);
//*************************??????��?
			if(VoiceEnable==1)
				{
					if(KEY_MEMORYUP)  SoundMemory();	
				}
			
			if(flag_tomemory_long_press==1)
			{
				flag_tomemory_long_press = 0;
				goto ChangeMemoryIndex2;
			}
//*************************??????��?
		}

		AutoOffTimew=0;
		mtemp0c.b=0;
		mtemp1c.b=0;
		SecondFlag = 0;
		while(KEY_POWER)
		{
			while(KEY_MEMORYUP && KEY_TIME && KEY_POWER)
			{
				if(AutoOffTimew>AutoOffTimew_1_S_COUNT * 120) goto TimeOver;//查询记忆后无操作自动灭屏时间为3分59秒左右，和规定的4分钟灭屏只差1秒有点危险，需要调整，改为120s
				// if(AutoOffTimew>OFFTIME) goto TimeOver;
			}
//			delay(3);
			// if(!KEY_MEMORYUP || !KEY_POWER||!KEY_TIME) break;
			if(!KEY_MEMORYUP || !KEY_POWER) break;//20230404 bug_check_the_memory_and_press_the_set_button_replay_the_message
		}
ChangeMemoryIndex2:
		if(!KEY_POWER) goto TimeOver;

				if(HaveMemoryFirst==1 && ShowMean==1&&!KEY_MEMORYUP){goto 	NoChangeMemoryIndex;}

				// AutoOffTimew=0;
				if(!KEY_MEMORYUP)
				{
					// while(!KEY_MEMORYUP&&(AutoOffTimew<125));
					// if(AutoOffTimew>124)
					// 	{
					// 		DelOneMemory();
					// 		if(EmptyFlSag)	{EmptyFlag=0;goto Again;}
					// 		HaveMemoryFirst=0;
					// 		goto NextMem;
					// 	}
					
					MemoryIndex--;
					if(MemoryIndex > 250) MemoryIndex = 0;
					MemoryEndIndex--;
					if(MemoryEndIndex > 250) MemoryEndIndex = 0;

					//if(MemoryEndIndex == 0) MemoryEndIndex = MemorySet;
					//if(MemoryIndex == 0) HaveMemoryAvg=0;
					
					if(MemoryFull == 0)
					{
						if(MemoryIndex ==0) MemoryIndex = MemoryIndexBackup;
						if(MemoryEndIndex  ==0) MemoryEndIndex = MemoryEndIndexBackup;
					}
					else
					{
						if(MemoryIndex ==0) MemoryIndex = MemorySet;
						if(MemoryEndIndex  ==0) MemoryEndIndex = MemorySet;
					}
					
					delay(15);
					while(!KEY_MEMORYUP)
					{
							if ( AutoOffTimew >TWO)
							{
								flag_tomemory_long_press=1;
								goto FastChangeLCD;
							}
							else
							{
								flag_tomemory_long_press=0;
								goto FastChangeLCD;
							}
					}
				}

				// if(!KEY_MEMORYUP)
				// 	{
				// 		MemoryIndex++;
				// 		if(MemoryIndex >MemoryIndexBackup) MemoryIndex=1;
				// 		MemoryEndIndex++;
				// 		if(MemoryFull==0)
				// 			{
				// 				if(MemoryEndIndex >MemoryEndIndexBackup) MemoryEndIndex = 1;
				// 			}
				// 		else{if(MemoryEndIndex >MemorySet) MemoryEndIndex = 1;}
				// 	//	if(MemoryEndIndex == 0) MemoryEndIndex = MemorySet;
				// 	//	if(MemoryIndex == 0) HaveMemoryAvg=0;
				// 	}

NoChangeMemoryIndex:
		HaveMemoryFirst=0;  //???????��??????,????????????.
		ShowMean = 0;
		while(!KEY_MEMORYUP ||!KEY_TIME);
		delay(3);
		while(!KEY_MEMORYUP ||!KEY_TIME);
	}
	HaveMemoryAvg=0;

TimeOver:
	DarkAllIcon();
	MemoryMode=0;
	Vioce_LBT_Flag = 0;
}
```

###### 04
```
void totimekeyin(void)
{
	unsigned char i=0;
	IsPowerOn = 1;
	AutoOffTimew = 0;
	UserABDisplay();
	parting_line_off;
	
	CheckBatteryADC();
	delay(2);
	ShowBTBar();
	// while(!KEY_TIME);
	// delay(2);
	// while(!KEY_TIME);
/*
	do									//??mmHg?Kpa??
		{
			mmHgKpaSetDisplay();
			AutoOffTimew = 0;
			do{
				if(AutoOffTimew > OFFTIME){goto ToTimeOver;}
			  }while( KEY_MEMORYUP&& KEY_TIME && KEY_POWER);


					if( !KEY_MEMORYUP)
						{
							if(mmHgkPaFlag==1)
								{
									mmHgkPaFlag=0;
								}
							else{mmHgkPaFlag=1;}
							mmHgKpaSetDisplay();
							while( !KEY_MEMORYUP);
							delay(4);
						}




					if(!KEY_POWER) {IsPowerOn=0; goto ToTimeOver;}


		}while(KEY_TIME);

	while(!KEY_TIME);
	delay(2);
	while(!KEY_TIME);
*/
	
	if(flag_first_power_up == 1)  goto SET_TIME;

	DarkAllIcon();

  ShowBTBar();
	Voice_Display();
goto SET_VOICE;
		do								//??UserA?userB
		{
            while (!KEY_TIME)
            {
                flash_UserAB();
								parting_line_off;
            }
			AutoOffTimew = 0;
			do{
                flash_UserAB();
								parting_line_off;
				if(AutoOffTimew > OFFTIME){goto ToTimeOver;}
			  }
			while( KEY_MEMORYUP&& KEY_TIME && KEY_POWER);


					if(  !KEY_MEMORYUP)
						{
							if(UserA==1)
								{
									UserA=0;
								}
							else{UserA=1;}
							UserABDisplay();
							parting_line_off;
							while(  !KEY_MEMORYUP);
							delay(4);
						}

					if(!KEY_POWER) {IsPowerOn=0; goto ToTimeOver;}
		}while(KEY_TIME);
		Flash_SET_Flag = 0;
SET_TIME:
		
		TimeSetThreeKey();
		

		if(KEY_POWER==0||!IsPowerOn){goto ToTimeOver;}
SET_VOICE:			
		if(VoiceType>NO)
		{
		DarkAllIcon();
		AutoOffTimew = 0;
		ShowVoice();
		while(!KEY_TIME);
		delay(2);
		while(!KEY_TIME);
	ShowBTBar();
	Voice_Display();
		do									//????
			{				
				AutoOffTimew = 0;
				do{
					flash_voiceonoff();
					parting_line_off;
					if(AutoOffTimew > OFFTIME){goto ToTimeOver;}
					}while( KEY_MEMORYUP&& KEY_TIME && KEY_POWER);
			
						if( !KEY_MEMORYUP)
						{
							if(VoiceEnable==1)
							{
								VoiceEnable=0;
							}
							else{VoiceEnable=1;}
							ShowVoice();				
							while(!KEY_MEMORYUP);
							delay(2);
						}
						if(KEY_POWER==0){goto ToTimeOver;}
			}while(KEY_TIME);		

		while(!KEY_TIME);
		delay(4);
		}		

		DarkAllIcon();
		while(!KEY_TIME);
		delay(2);
		while(!KEY_TIME);
	ShowBTBar();
	Voice_Display();
		do									//??mmHg?Kpa??
		{
			mmHgKpaSetDisplay();
			AutoOffTimew = 0;
			do{
				flash_mmghkpa();
				parting_line_off;
				if(AutoOffTimew > OFFTIME){goto ToTimeOver;}
			  }while( KEY_MEMORYUP&& KEY_TIME && KEY_POWER);


					if( !KEY_MEMORYUP)
						{
							if(mmHgkPaFlag==1)
								{
									mmHgkPaFlag=0;
								}
							else{mmHgkPaFlag=1;}
							mmHgKpaSetDisplay();
							while( !KEY_MEMORYUP);
							delay(4);
						}
					if(!KEY_POWER) {IsPowerOn=0; goto ToTimeOver;}
		}while(KEY_TIME);

//************************************************????????
/*
		AutoOffTimew = 0;
		DarkAllIcon();
		do{
				DisplayHalfByte(0x0c,DIATen);		// 'C'
	    	DisplayHalfByte(0x13,DIASingle);	// 'L'
	    	if(AutoOffTimew > OFFTIME){goto ToTimeOver;}
	    	delay(2);
	    	}while(KEY_POWER&&KEY_TIME);
		if(!KEY_POWER)
			{
				CLRMemoryBank();
				flashCL();		//CL flash
			}
		while(!KEY_TIME);
		delay(4);
*/
ToTimeOver:
		IsPowerOn=0;
		DarkAllIcon();
		for(i=0;i<3;i++)
			{
				EEPROMin = 0xFB+i;
				readM24L16();
				outbyte[0]=inbyte[0];
				outbyte[1]=inbyte[1];
				outbyte[2]=inbyte[2];
				if(mmHgkPaFlag==1){outbyte[3]=inbyte[3]|0x01;}
				else{outbyte[3]=inbyte[3]&0xfe;}

				if(UserA==1){outbyte[4]=inbyte[4]|0x08;}
				else{outbyte[4]=inbyte[4]&0xf7;}

				if(VoiceEnable) outbyte[4]=outbyte[4]|0x10;
				else outbyte[4]=outbyte[4]&0xEF;

				outbyte[5]=volume_value; //save volume
				outbyte[6]=inbyte[6]; //NC
				writeM24L16();
			}
}
```

###### 05
```
//if(MemoryIndex == 0) HaveMemoryAvg=0;  //索引越界后重新索引,并停留在松开按键时索引的记忆位置;取消注释则越界后停留在第1笔记忆
```

##### AXD-303 A 雾化器
AXD-303 A 需要添加蜂鸣器功能。
2025 年 10 月 30 日晚上，外接蜂鸣器尝试能不能直接接 IO 口控制。5 V 无源蜂鸣器，在软件模拟输出 PWM 方波（2.5 KHz，57%占空比）可以实现蜂鸣。
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_13.png]]
一开始不响爱那个，是代码问题，外接小电源尝试供电发现，蜂鸣器 2.7 V 就开始有响声，随着电压增大而响度增大。（2.6 V 不响）
即，5 V 蜂鸣器最低工作电压为 2.7 V，3.6 V 响度也还可以。


AXD-303A，锦锐，芯片引脚图
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_14.png]]

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_15.png]]

##### 晶华微仿真器/烧录器接线

晶华微烧录器：
1 pin--BOOT
4 pin--GND
5 pin--SDA (SCLK)
6 pin--SCL (SDIO)
7 pin--VDD
接线：
GND-GND
SW (SCLK)--SDA
SCL (SDIO)--SCL
VDD-VM

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_16.png]]

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_17.png]]


##### PCM 01


![[../../annex/16.入职第十六周10.27-11.1(单休)_image_18.png]]
```测试
while(1)
{
		if(!KEY_POWER) heating_icon_on;
		if(!KEY_MEMORYUP) avg_icon_on;
		if(!KEY_ECO)	time_icon_on;
}
```


##### 锂电池上电背光会闪一下，换主控解决--BP00A

##### 小米充电器供电会（上电时）会有约1秒钟的拉低电平（掉电）。

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_19.jpg]]
使用小米充电器有几率掉电1秒左右。
可能是 16 pin 的 Type-C，其中通讯引脚被配置成了自动工装，可能是跟小米充电器的引脚有所冲突而引起的（有 2 个引脚电平影响到了）。
使用 6 pin 还是 7 pin  （不带数据传输）的充电器则正常。华为的充电器也正常。


!![[../../annex/16.入职第十六周10.27-11.1(单休)_image_20.jpg]]


##### 聊天群聊
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_21.png]]
1.①这个就是自动工装？

2.②自动工装是用串口，要是硬件串口有的多就用硬件串口，硬件串口不够用就用模拟串口

3.①我还以为这个是自动工装呢。原来是 USB 烧录的 VM。我看其他的都是单独再引一个 VM 出来。

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_22.png]]
4.②↑这里的 SCL 和 SWAT 应该是留给自动工装的

##### PCM 02

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_23.png]]

PCM01不补气。ADC 有改变。
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_24.png]]

Auto_Wakeup


```
if(show_cnt >= horse_race_lap_time)
		{
			show_cnt = 0;
			horse_lap_cnt++;
			if(horse_lap_cnt > 2/*3*/) horse_lap_cnt = 0;
		}
		show_horse_race_lap_feel(horse_lap_cnt);
```


```
void show_horse_race_lap_feel(uint8 cnt)
{
	Cushion_icon_on;
	DogSleep_icon_on;
	if(cnt == 0) {/*RELIEF_icon_on;BALANCE_icon_off;SUPPORT_icon_off;*/LIGHT_icon_on;RESTFUL_icon_off;WELL_icon_off;};
	if(cnt == 1) {/*RELIEF_icon_on;BALANCE_icon_on;SUPPORT_icon_off;*/LIGHT_icon_on;RESTFUL_icon_on;WELL_icon_off;};
	if(cnt == 2) {/*RELIEF_icon_on;BALANCE_icon_on;SUPPORT_icon_on;*/LIGHT_icon_on;RESTFUL_icon_on;WELL_icon_on;};
	//if(cnt == 3) {/*RELIEF_icon_on;BALANCE_icon_on;SUPPORT_icon_on;*/LIGHT_icon_off;RESTFUL_icon_off;WELL_icon_off;}
	if(cnt==0 /*|| cnt==2*/)
	{
		if(cushion_state == 0)
		{
			RELIEF_icon_on;BALANCE_icon_off;SUPPORT_icon_off;
		}
		else if(cushion_state == 1)
		{
			RELIEF_icon_off;BALANCE_icon_on;SUPPORT_icon_off;
		}
		else if(cushion_state == 2)
		{
			RELIEF_icon_off;BALANCE_icon_off;SUPPORT_icon_on;
		}
	}
	else
	{
		RELIEF_icon_off;BALANCE_icon_off;SUPPORT_icon_off;
	}
}
```


```
void show_horse_race_lap_feel(uint8 cnt)
{
	Cushion_icon_on;
	DogSleep_icon_on;
	if(cnt == 0) {RELIEF_icon_on;BALANCE_icon_off;SUPPORT_icon_off;LIGHT_icon_on;RESTFUL_icon_off;WELL_icon_off;};
	if(cnt == 1) {RELIEF_icon_on;BALANCE_icon_on;SUPPORT_icon_off;LIGHT_icon_on;RESTFUL_icon_on;WELL_icon_off;};
	if(cnt == 2) {RELIEF_icon_on;BALANCE_icon_on;SUPPORT_icon_on;LIGHT_icon_on;RESTFUL_icon_on;WELL_icon_on;};
	//if(cnt == 3) {/*RELIEF_icon_on;BALANCE_icon_on;SUPPORT_icon_on;*/LIGHT_icon_off;RESTFUL_icon_off;WELL_icon_off;}
	/*if(cnt==0)	// || cnt==2
	{
		if(cushion_state == 0)
		{
			RELIEF_icon_on;BALANCE_icon_off;SUPPORT_icon_off;
		}
		else if(cushion_state == 1)
		{
			RELIEF_icon_off;BALANCE_icon_on;SUPPORT_icon_off;
		}
		else if(cushion_state == 2)
		{
			RELIEF_icon_off;BALANCE_icon_off;SUPPORT_icon_on;
		}
	}
	else
	{
		RELIEF_icon_off;BALANCE_icon_off;SUPPORT_icon_off;
	}*/
}
```


```
ShowFeel(cushion_state/*day_avg_result_data.motion_mark*/);
```


```
#if	0				
			if (KEY_MEMORYUP==0)
			{
				MEMMODE:
				while (KEY_MEMORYUP==0);
				DarkAllIcon();
				delay(4);
				DayAvgMode();
				WorkMode=1;
				while (KEY_MEMORYUP==0);
				DarkAllIcon();
				WorkMode=1;
				AutoOffTimew=0;
				if(lowbat_flag == 1){goto end;}
				g_state = STATE_STANDBY;
				UART_Init();
				no_detect_move_count = 500;
			}
			break;

			case STATE_SLEEP:  
			ShowLight();
			disp_cushion_state(cushion_state);
			disp_to_temp(lasttemp);
			if (movement_state==1)
			{
				AutoOffTimew = 0;
				DarkAllIcon();
				g_state = STATE_Measure;
			}
			

			break;
		case STATE_Measure:
		if (movement_state == 1)
		{
			show_cnt++;
			if (show_cnt>=display_switch_time)
			{
				show_cnt =0;
				switch (led_cnt)
				{
				case 0:
					rolls_icon_on;
					break;
				case 1:
					rolls_icon_off;
					break;
				case 2:
					rolls_icon_on;
					break;
				case 3:
					rolls_icon_off;
					break;	
				default:
					break;
				}
				led_cnt+=1;
				if (led_cnt>3)
				{
					led_cnt =0;
				}
			}

		}else
		{
			AutoOffTimew = 0;
			DarkAllIcon();
			g_state = STATE_SLEEP;
		}

		break;

		case STATE_Auto_Monitoring:   
		{
			if (BedFlag == 1)
			{
				Auto_Wakeup = 0;
				goto reset;
			}
			
			if (AutoOffTimew>offtime_5s*6) 
			{
				goto end;
			}
		}
	
		default:
		break;
		}
		
		
	} while (1);
#endif
```


##### 电池电量百分比显示问题

测量数据：
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_24.png]]
↓对应样机：
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_25.jpg]]




![[../../annex/16.入职第十六周10.27-11.1(单休)_image_26.jpg]]


```
>4.1 V，99%
3.5 V<，1%
只在开机时检测电压
满电通过FULL脚（充电管理IC的pin脚）电平状态来判断是否满电
低电通过比较器来判断低电

问题比较大的是有满电提示LED灯的情况。

```



##### 王帅亮测的电压数据

客户样机：2.1 V 电流 500-515 mA  14 分 06 秒 
106 样机：2.1 V 电流：520-530 mA  16 分 25 秒】

要慢两分钟左右，其实 106样机在1级升压电路出现电压掉下去的情况，客户样机更稳定。二级升压电路波形一直。

同样 5ml 生理盐水

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_27.png]]

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_28.png]]

![[../../annex/16.入职第十六周10.27-11.1(单休)_image_29.png]]




##### 总结
1、遇到如 P106C、P126C、P136C 之类的充电管理问题。如遇到闪屏、先考虑软件问题。
 ①硬件问题上还需要考虑一个点：会不会是干/锂电池不行，更换个电池试一下。如果有 2 台机器，看看另外一台机器有没有相同问题，如果只有一台机器有某个问题，则尝试互换电池看看现象。
 ②抓异常现象时的波形，查看上电、开机分别的电压情况，是低电平还是高电平，切换过程中有没有异常波形。
 ③如果要更换元器件，需要跟硬件说一声，尤其是如果更换成了不同型号的元器件

2、方翔云换屏任务发现 LCD 屏出现给 SEG 脚前半部分 0 XFF，出现点亮上半部分显示、给 SEG 脚后半部分 0xFF，点亮下半部分，如果全部置 0xFF，出现下半部分被熄灭、只有上半部分可以显示的问题。
--是 LCD 屏接线接错了，SEG 和 COM 的线接反了。





### 工作之余

##### 焊接
绝大部分 PCB 板用的是玻璃纤维, 熔点在 700 度，焊锡通常在 300 度
“无锡焊铅“的温度不到 200 度，
无铅的一般温度会更高，一般铅越多温度越低，好用但是对身体不好。

工程塑料软化要250度以上高温锡熔点在250度到217之间整板均匀加热到230就够焊了，局部加热要烙铁300多度这时要控制接触时间。不能长时间焊一个点

钢网上锡后放上元器件，加热融化锡达到焊接目的。用铁板烧，用风枪的话元件会有位移（吹跑元件）
通过焊油和焊锡的表面张力来实现锡浆融化后让元器件对准。



|    元器件类别     |         具体型号/封装          | 推荐焊接温度范围 |    最大耐受温度/时间    |          关键注意事项          |
|:-----------------:|:------------------------------:|:----------------:|:-----------------------:|:------------------------------:|
|  IC 芯片 (通用)   |      SOP/SSOP/QFP 等封装       |    300℃-350℃     | 260℃,10 秒; 350 ℃, 3 秒 |    严格控时，建议使用热风枪    |
|    充电管理 IC    |       CN 3791 (SSOP 10)        |        -         |       260℃, 10 秒       |          参阅数据手册          |
|     电阻/电容     |         0603/0402 封装         |    350 ℃左右     |          265 ℃          |    体积小, 散热快, 速战速决    |
|     贴片电容      |           0402 封装            |        -         |     270±5 ℃, 10 秒      |   对温度敏感，过热易损坏介质   |     |     |     |     |     |     |
| 贴片二极管/晶体管 |  二极管（SOD）、三极管（SOT）  |    350-400 ℃     |            -            | 焊接时间不宜过长, 防止过热损坏 |     |     |     |     |     |     |
|     贴片 LED      |       常见贴片 LED 灯珠        |    260-300 ℃     |     295±5℃, 3 秒内      |           对高温敏感           |     |     |     |     |     |     |
|      MOS 管       | SOT-23 封装（如 HM 3400 C-VB） |        -         |    260℃, 5 秒或 300℃    |       大功率器件注意散热       |     |     |     |     |     |     |
|    贴片蜂鸣器     |        压电式无源蜂鸣器        |        -         |   320-350℃, 0.5-2 秒    |         避免长时间加热         |     |     |     |     |     |     |
|                   |                                |                  |                         |                                |     |     |     |     |     |     |


```

贴片元件的焊接确实是个精细活，温度和时间控制是关键。下面我汇总了一个表格，帮你快速了解常见元件的焊接参数，之后我们再详细聊聊具体的技巧和注意事项。

 🔍 常见贴片元器件焊接参数速查表 

 🔥 通用焊接原则与核心技巧

无论焊接哪种元件，掌握以下原则能让你事半功倍：

- 温度与时间的平衡：焊接的本质是在热量、时间之间取得平衡。目标是让焊锡充分熔化并形成良好焊点，同时避免元器件和PCB板过热。通常，每个焊点的操作时间应控制在3秒以内。
- 工具选择与设置：
    - 电烙铁：优先选用可调温、带接地的恒温烙铁。焊接精密贴片元件，温度范围通常在300°C到400°C之间调整。尖嘴或刀头烙铁头更适合精细操作。
    - 热风枪：适合多引脚IC焊接。对于有铅焊锡，温度可设330-350°C；无铅焊锡为350-370°C。风速选择：贴片阻容件用2-3档，IC类用3-4档。
- 手法关键：
    - 快和准：减少烙铁与焊点接触时间。
    - 使用焊锡丝：焊锡丝能帮助热量快速传递。
    - 辅助散热：用镊子轻夹元件引脚帮助散热（注意避免短路）。
- 观察焊点状态：良好焊点应光滑、明亮，呈圆锥形，焊锡能很好地润湿焊盘和元件引脚。

 ⚠️ 重要注意事项

1.  预防静电损伤：MOS管、IC等元件对静电敏感。操作时需佩戴防静电手环，使用防静电工作台和烙铁。
2.  避免热应力冲击：急剧温度变化可能导致元件内部开裂。让焊点自然冷却，避免用嘴吹气强制冷却。
3.  警惕虚焊和连锡：
    - 虚焊：通常因温度不足、焊接时间不够或焊盘氧化导致。
    - 连锡（桥接）：多引脚IC常见问题。可借助烙铁利用表面张力拖曳多余焊锡，或使用吸锡线。
4.  善用助焊剂：助焊剂能去除氧化物，提高焊锡流动性。对于难上锡焊点，适量添加助焊剂效果显著。

 💎 总结与核心建议

成功焊接贴片元件的核心在于：为特定元件选择合适的温度、使用合适的工具、采用正确的手法，并严格控制加热时间。

最可靠的参数来源永远是元器件的数据手册。希望这些信息能帮助你更自信地完成焊接工作！如果你在焊接某个特定元件时遇到了棘手的问题，欢迎随时再来问我。
```


##### 常识
05 年后生产的干电池、纽扣电池可以直接扔进垃圾桶，不用担心污染环境的问题。
锂电池、可二次充电的电池、汽车电瓶车内用的铅酸电池对环境污染大，需要集中回收处理。
一般是汞等重金属问题，汞在水中被水生物食用后会转变为甲基汞，会使人得水俣病


##### 中断
中断函数定义中关键字 interrupt 后面的数字代表什么？是固定不变的吗？可以修改吗？会影响什么？

单片机中，中断号是固定不变的。
- 中断号与中断源的对应关系是固定的：每个中断源（如外部中断 0、定时器 0 等）都对应一个固定的中断号。这个对弈关系是预先定义好的，不能更改。
- 中断号用于区分不同的中断：当中断发生时，CPU 通过固定的中断号来识别是哪个中断源发出了请求，并据此跳转到相应的中断服务程序执行。
- 中断向量地址也是固定的：每个中断号对应的中断服务程序入口地址（即中断向量地址）同样也是固定的。这些地址位于程序存储器的起始位置，由硬件决定。


在 51 单片机中，中断函数定义中关键字 interrupt 后面的数字表示中断号。中断号用于标识不同的中断源，以便在中断发生时跳转到相应的中断处理函数。以下是常见的中断号及其对应的中断源：
Interrupt 0：外部中断 0，由 P 3.2 端口引入，低电平或下降沿触发。
Interrupt 1：定时器/计数器 0 中断，由 T 0 计数器计满回零引起。
Interrupt 2：外部中断 1，由 P 3.3 端口引入，低电平或下降沿触发。
Interrupt 3：定时器/计数器 1 中断，由 T 1 计数器计满回零引起。
Interrupt 4：串口中断。
不同的单片机可能有不同数量的中断源和中断号。例如，有些单片机可能有更多的中断源，如 ADC 中断、串口 2 中断、PCI 中断等。具体的中断号和中断源需要参考所使用的单片机的资料。
以下是一个简单的例子，展示了如何定义一个中断函数：

```
#include <reg52.h>

Void main () {
P 1 = 0 x 0 f; // 0000 1111 下面四个灯亮上面四个灯灭
EX 1 = 1; // INT 1 中断允许
EA = 1; // 全局中断打开
IT 1 = 1; // 触发方式为下降沿触发
While (1);
}
Void jump_low () interrupt 2 {
P 1 = ~P 1; // 位反转
}
```

在这个例子中，jump_low 函数被定义为 interrupt 2，表示它是外部中断 1 的中断处理函数。当外部中断 1 发生时，程序会跳转到 jump_low 函数执行。

通过理解中断号和中断源的对应关系，可以更好地编写和调试单片机的中断程序。


##### C语言中的_Generic：深入理解与实践
https://geek-blogs.com/c/c-basic/C-_Generic/#google_vignette


##### 贴片电阻识别
①三位数字丝印标识
丝印 200 的电阻阻值为 20 欧姆（Ω）
- 识别规则：三位数字丝印中，前两位的 “20”代表有效数字，第三位的“0”表示10 的 0 次方（即 1），因此计算为 20 X 1=20Ω。
- 精度信息：三位数字丝印通常表示±5%精度，若为四位数字则精度为±1%。
- 常见于 0603/0805 等封装。
同理，丝印 304 的电阻阻值为 30 X 10<sup>4</sup>=300 KΩ。常见于 0805/1206 封装规格，误差多为 5%。

②四位数丝印电阻读数方法：
- 前三位为有效数字
- 第四位为 10 的幂指数
- 阻值单位为欧姆Ω。
丝印"002"的电阻阻值为 0.002 欧姆（2 毫欧）。
这种标识方法属于四位数字表示法，用于小阻值电阻：
- 前三位数字"002"代表有效数字
- 第四位数字"2"代表小数点位置（乘以 10 的负几次方）
- 因此"0022"表示 0.002 欧姆
该类电阻通常为合金采样电阻，常见封装为 2512，精度一般为 1%，功率可达 4 W。主要应用于电源、锂电池保护板等电流检测场合。

需要注意的是，不同厂家的丝印标识可能存在差异，实际应用中应参考具体制造商的数据手册。

③而两位数丝印电阻的读书方法是：直接读取数字，单位为欧姆Ω。



##### 锂电池充电时间
###### 3 .7 V 锂电池从 3.4 V 充满大约需要 1-2 小时
根据锂电池的充电特性，3.4 V 已经超过了涓流充电阈值（通常为 2.9-3.0 V），因此可以直接进入恒流充电阶段。在这个电压点，电池不需要经过预充电过程，可以使用全电流进行充电。

充电时间主要取决于以下因素：
①充电电流大小：
- 如果采用 0.5 C 充电电流（比如 2000 mAh 电池使用 1000 mA 电流），大约需要 2 小时左右
- 1 C 大电流充电理论上 1 小时可充满，但实际会因发热等因素延长至 1.5 小时左右
- 小电流充电（如 0.2 C）则可能需要 3-4 小时
②充电阶段转换：
从 3.4 V 开始充电会先进行恒流充电，当电压达到 4.2 V 后转为恒压充电，此时电流逐渐减小，最后阶段的充电速度会变慢。
③实际影响因素：
电池的老化程度、环境温度（最佳为 0-45℃）、充电器质量等都会影响实际充电时间。新电池在室温环境下使用优质充电器可以达到理论充电速度，而老旧电池或极端温度环境下充电时间会相应延长。

###### 4.2 V 锂电池从 3.4 V 充至满电需要 3 小时
4.2 V 锂电池从 3.4 V 充至满电所需时间主要取决于电池容量和充电电流，通常在 1-3 小时内可完成。

根据锂电池充电特性，充电过程分为恒流和恒压阶段，前期恒流充电可快速补充电量，后期恒压阶段则缓慢补满。

例如 1000 mAh 容量电池在 350 mA 充电电流下，理论充电时间约 2.85 小时，考虑实际效率后约为 3.56 小时（约 3.5 小时）。

实际充电时间受以下因素影响：
- 电池剩余电量：出厂时电池通常带 10%~50%电量，若初始电压 3.4 V 对应电量较高，充电时间会缩短
- 充电电流：电流越大充电越快，但需遵循设备允许范围
- 温度环境：高温（超过 40℃）可能延长充电时间，需在适宜环境下充电
- 充电器特性：多数设备充电器带过充保护，绿灯亮或自动停止即表示充满，避免超过 12 小时以防过充
建议以充电器指示为准，优先使用原装充电器确保安全。


###### 4.2 V 锂电池通常充不到 4.2 V，4.15 V~4.2 V 之间即可视为充满
4.2 V 锂电池通常充不到 4.2 V 是由于充电器或保护板设置、电池老化等因素导致，实际充满电压多在 4.15 V~4.2 V 之间，部分厂家为延长电池寿命会设置略低于 4.2 V 的满电电压。

①为什么通常充不到 4.2 V？
- 充电器设置：部分充电器为延长电池寿命，出厂设置满电电压会略低于 4.2 V，如设置为 4.18 V 等
- 保护板限制：锂电池保护板会设置过压保护，当检测到电压达到设定值时会切断充电，部分保护板会设置低于 4.2 V 的阈值
- 电池老化：随着使用时间增长，电池性能会下降，可能导致无法充到标准的 4.2 V
- 温度影响：充电环境温度过高或过低都可能影响充电电压，导致无法达到 4.2 V
- 
②一般多少 V 视为充满电？
- 标准电压：理论上，4.2 V 是锂电池的充满电压，达到此电压即认为充满
- 实际应用：在实际使用中，由于上述因素影响，通常在 4.15 V~4.2 V 之间即可视为充满，具体取决于电池类型和充电设备
- 厂家设置：部分厂家为延长电池寿命，会设置略低于 4.2 V 的满电电压，如 4.18 V 等
③为什么设置低于 4.2 V？
- 电池寿命：浅充浅放对电池寿命更有益，设置略低于 4.2 V 的满电电压可以减少电池压力，延长使用寿命
- 安全考虑：避免因充电器精度问题或环境因素导致过充，提高安全性
- 电池一致性：对于多串电池组，设置略低的满电电压有助于保证各电芯电压一致性，提高整体性能
综上，虽然 4.2 V 是锂电池的标准充满电压，但在实际应用中，由于多种因素影响，通常在 4.15 V~4.2 V 之间即可视为充满，具体取决于电池类型、充电设备和厂家设置。

##### 蓝牙的 FC 号是什么？
蓝牙的 FC 号即 MAC 号，是蓝牙设备通过 FCC 认证后获得的唯一标识符。

##### 状态机思想
状态机是一个理论模型，而 switch/case 是实现方法。

我觉得还是尽量别用回调函数，回调函数执行同类中断的共同函数就行。

状态机主要突出的是各种状态的变化，迁移，回调是一种语法，主要是用来降低函数耦合的！

简单思想：

```
函数｛函数体｝
if 执行成功 ｛后续操作｝
elif 执行失败 ｛后续操作｝
这里面成功或者失败的后续操作就是回调函数
```

状态机思想是一种工作方法，回调函数是编程基础知识，不一样 XD

数字电路告诉我们，状态是本质！程序是什么？状态的定制而已！
数字机从物理角度就是个状态机，记忆状态，也就是保持，状态触发进入下一个状态，接着保持，再被触发……
万物皆可状态机这句话可不是开玩笑的，数字电路的底层逻辑，所谓函数和程序就是机器执行的一堆状态码而已，只不过是高级编程语言的一种术语罢了，也就是翻译器，即所谓编程语言为了让人更容易理解的格式罢了
回调函数不是状态机？运行的每个代码都是状态！逻辑上的状态机手法和代码集合段（函数）本质没啥区别，都是状态定制。所以状态机过时说法有些本末倒置，万物皆可状态机，这也是继电器、数字电路模式实现的质的变化。往深了说就是时间的切片和延时(模拟量的数字处理)。

计算机的底层原理就是 Turing Machine，状态机的终极形式，当然永不过时了。


状态机和前后台系统是啥关系啊，我听说状态机+前后台系统可以近似完成裸机多任务编程

应该是可以的。多个状态机任务放在 while 1里面轮询，中断做一些简短的必要处理就可以了

我建议先别那么用，你也看到了状态机怎么实现的，如果多个任务要实现轮询，时序非常重要，如果有2、3个任务的话，时序还能理得清，任务一多，状态机就复杂得看不懂。
up 之前专门讲 rtos 的时候就说过这个问题（1小时的那个视频），rtos 就是专门为了解决这个问题而出现的。
如果有条件的话（不是自己给自己找麻烦），还是用 rtos 去解决吧，就算是 rtos 小白，从0开始照着视频移植和敲代码也不过1个多小时就能实现两位数的任务数，用 cubemx 这种专业工具甚至十几分钟就能完成，rtos 不会占用太多资源，最重要的是你写的代码以后你能看懂。状态机就不一定了


这不是学不学得明白的事情，看代码分析逻辑你是能看懂它是如何实现的，但自己写就不一定了。
这是一种编程风格，是一种编程思想，不是某种具体的逻辑实现，只有非常有经验的工程师才能运用熟练。
你平时编程的时候可以尝试从状态机编程的思想出发，去分析一个硬件的驱动如何实现。
举个例子类比一下，很多硬件它都有指令系统，向硬件发送指令，让硬件执行不同的动作。
用状态机的思想去理解的话，每一条指令对应一种状态，你通过输入指令、和指令集比对的方式 switch 状态，case 需要执行的动作让硬件执行，通过输入不同的指令来让状态切换，执行不同的动作，这是一个道理。

再给你举一个更简单的例子：电量显示。
通过测量电池的电压，让锂电池从3.2v 到4.2v 之间分为5个电量等级，每一个等级分别对应1-5格 LED 显示出来。
从状态机的思想去分析的话，5个电量等级分别是5个状态，分别定义为20%-100%五个枚举变量。
输入量是电池电压，通过 ADC 转换量化成数值。
通过 switch/case 语句判断。if 数值在0-20之间，就点亮 LED0；if 数值在20-40之间，就点亮 LED0和 LED1……
以此类推。至于状态的切换，则依赖于电池的电量。说到这你应该明白了吧？

懂了。我编程的时候 if if 太多我就查表了。写 c++的话写一个纯虚函数子类实现。我想 c++实现多态也是编译器构造了虚函数表，调用的时候查表。linux 的话用了个 container_of 查结构体首地址实现多态。但我感觉虽然有很多设计模式，本质还是查表，查状态吧？

实际上从代码的语法结构上来看，switch/case 语句就比 if/else 语句简洁。
如果你需要在多个同级的状态中去判断的话，最好用 switch/case 封装一下，毕竟所有的 case 对齐代表所有的判断条件。
如果判断的条件比较长或者比较混乱，可以用枚举变量封装一下，看起来更直观也更简洁，具体判断条件单独拎出来写，也更好理解，在逻辑上更简洁


表驱动法写状态机

简单一点儿的，SysTick 定时，启动后记录下当前时间戳，主循环里不断检测时间差，超时就关闭。




##### 低功耗处理 -- IO 口配置
可在空闲状态/待机状态/关机状态下，将 IO 口配置为输入模式，输入模式的功耗比输出模式小。需要时再按需配为输出模式。
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_30.jpg]]


###### AI①
单片机中，通常将 IO 口空闲时设为输入状态，并根据需要配置为上拉（默认高电平）或下拉（默认低电平），以避免浮空状态导致的电平不确定和干扰敏感问题。
- 输入状态的选择：  
  IO 口空闲时多设为输入模式（如按键检测），以便监控外部信号。浮空输入（无上拉/下拉）会导致电平不确定，易受干扰，因此实际应用中推荐使用上拉或下拉输入以固定默认电平。
- 上拉/下拉的默认电平：  
  - 上拉输入：内部接上拉电阻（阻值约 30 K~50 K 欧姆），空闲时引脚默认为高电平。适用于检测低电平输入（如按键按下），提高电路稳定性。  
  - 下拉输入：内部接下拉电阻，空闲时引脚默认为低电平。适用于检测高电平输入。  
- 原因分析：  
  - 避免浮空状态：浮空输入（高阻态）电平不确定，易受噪声干扰，可能导致误动作或功耗增加。上拉/下拉输入通过内部电阻固定默认电平，增强抗干扰能力。  
  - 应用需求：例如按键功能，未按下时需明确电平状态（上拉为高，下拉为低），便于检测变化。输出模式（如推挽/开漏）主要用于驱动外设，非空闲状态配置。  
综上，IO 口空闲时设为输入状态并配置上下拉，是为确保电平稳定性和系统可靠性。


###### AI②
为了降低功耗，单片机未使用的 IO 引脚通常配置为上拉输入模式，使其默认保持高电平；而对于输出模式，通常根据外部电路配置为低电平或高电平以最小化能耗。
- 输入模式配置原因：未使用的 IO 引脚应设置为输入模式（如上拉输入），以避免输出电流浪费。上拉输入模式通过内部上拉电阻将引脚默认拉高，功耗极低，适合低功耗场景（如电池供电设备）。这减少了不必要的电流消耗，因为高阻态输入下几乎无静态电流流动。浮空输入（高阻态）虽可降低功耗，但易受干扰，可能导致电平不稳定，因此上拉输入更可靠。
- 输出模式配置原因：对于输出引脚，配置为低电平或高电平需结合外部电路。推挽输出模式下，STM 8 等单片机默认为低电平，以避免外部电阻分压消耗能量；若外部电路需要高电平驱动，则配置为高电平，但需确保无电流回路形成。开漏输出模式通常功耗较低，因仅通过外部上拉电阻实现电平稳定，适合低功耗设计。
此外，低功耗设计还需注意：在单片机进入睡眠模式前，需逐一配置所有 IO 引脚，避免因代码笔误导致功耗异常；并优先使用硬件外设替代软件操作，减少不必要的 IO 活动。

###### AI③
为了降低功耗，单片机 IO 引脚的输入和输出模式在电平配置上存在显著区别，其核心在于平衡驱动能力、功耗和稳定性。
输入模式：通常配置为上拉输入（默认高电平）
- 配置原因：输入模式下，IO 引脚设为高阻态，通过内部上拉电阻将引脚“被动拉高”至高电平。这种方式功耗极低（仅μA 级电流），适合低功耗场景（如电池供电设备），且安全性高，外部电路可轻松拉低电平进行信号检测（如按键）。
- 对比分析：
  - 上拉输入（高电平）：功耗低、电平稳定，默认状态安全，避免浮空导致的干扰风险。
  - 浮空输入：虽功耗更低，但引脚电平不确定（易受噪声干扰），可能导致误触发或不稳定，不推荐用于关键信号。
  - 下拉输入（低电平）：功耗略高于上拉（因下拉电阻分压），但可确保默认低电平状态，适用于需高电平触发的场景。
输出模式：通常配置为低电平（推挽）或开漏输出
- 配置原因：输出模式下，低电平配置（如推挽输出接地）可减少静态功耗（仅 mA 级电流），且避免外部电路形成电流回路；开漏输出需外部上拉电阻，仅在输出高电平时有微弱电流，适合低功耗通信（如 I 2C）。
- 对比分析：
  - 推挽输出（低电平）：驱动能力强（可直接驱动 LED、继电器），电平稳定，但静态功耗略高（输出缓冲器导通时有微弱电流）。
  - 推挽输出（高电平）：功耗较高（因上拉至 VCC），若外部电路强制拉低，可能过流损坏 IO 口。
  - 开漏输出（高电平）：功耗低（仅μA 级），适合低功耗通信，但驱动能力弱（无法驱动大电流外设），电平易受外部干扰。
关键区别总结
| 维度         | 输入模式（上拉高电平）       | 输出模式（推挽低电平）       |
|--------------|------------------------------|------------------------------|
| 功耗     | 极低（高阻态，μA 级）        | 较低（mA 级，静态缓冲器电流） |
| 驱动能力 | 弱（仅信号检测）             | 强（可驱动外设）             |
| 稳定性   | 高（内部电阻稳定电平）       | 高（主动维持电平）           |
| 适用场景  | 按键、传感器检测（低功耗）   | LED、继电器驱动（主动控制）   |
结论：低功耗设计优先选输入上拉（高电平）或开漏输出（高电平），需强驱动时选输出低电平（推挽）；避免输出高电平（推挽）以减少功耗和风险。

###### AI④
为了降低功耗，单片机未使用的 IO 引脚通常配置为输入模式（如上拉输入），以保持高阻态并减少电流消耗；对于输出模式，通常根据外部电路需求配置为低电平或高电平，以最小化能耗。
输入/输出电平配置及原因
- 输入模式：通常配置为上拉输入，使引脚默认保持高电平。上拉输入通过内部上拉电阻将引脚“被动拉高”，功耗极低（仅μA 级电流），适合低功耗场景（如电池供电设备）。浮空输入虽功耗更低，但引脚电平不确定，易受干扰，可能导致不稳定；下拉输入则确保默认低电平，但功耗略高于上拉（因下拉电阻分压）。
- 输出模式：通常配置为低电平（推挽输出）或开漏输出。推挽输出低电平可减少静态功耗（仅 mA 级电流），避免外部电路形成电流回路；开漏输出需外部上拉电阻，仅在输出高电平时有微弱电流，适合低功耗通信（如 I 2 C）。推挽输出高电平功耗较高（因上拉至 VCC），且可能过流损坏 IO 口。
不同电平状态的对比分析
| 维度         | 输入模式（上拉高电平）       | 输入模式（浮空）             | 输入模式（下拉低电平）       | 输出模式（推挽低电平）       | 输出模式（推挽高电平）       | 输出模式（开漏高电平）       |
|--------------|------------------------------|------------------------------|------------------------------|------------------------------|------------------------------|------------------------------|
| 功耗         | 极低（高阻态，μA 级）        | 极低（高阻态）               | 较低（下拉电阻分压）         | 较低（mA 级，静态缓冲器电流） | 较高（上拉至 VCC）            | 低（外部上拉电阻，μA 级）    |
| 驱动能力     | 弱（仅信号检测）             | 弱（易受干扰）               | 弱（仅信号检测）             | 强（可驱动外设）             | 强（可驱动外设）             | 弱（无法驱动大电流外设）     |
| 稳定性       | 高（内部电阻稳定电平）       | 低（电平不确定，易受干扰）   | 高（下拉电阻稳定电平）       | 高（主动维持电平）           | 高（主动维持电平）           | 中（电平易受外部干扰）       |
| 适用场景     | 按键、传感器检测（低功耗）   | 不推荐（风险高）             | 需低电平触发的场景           | LED、继电器驱动（主动控制）  | 需高电平驱动的外设           | 低功耗通信（如 I 2 C）         |
输出模式配置与功耗关系
当 IO 口配置为输出模式时，若不需要驱动外设，将其从推挽或开漏模式配置回普通 IO 口输出模式（如输入上拉）可以降低功耗。普通 IO 口输出模式（如输入上拉）处于高阻态，静态功耗远低于推挽或开漏输出模式（输出缓冲器导通时有微弱电流）。因此，不需要驱动时，配置为输入上拉模式更节能；需要驱动时，再配置回推挽或开漏模式。
输出电平选择
若必须配置为输出模式，输出低电平通常比高电平更节能，因为推挽输出低电平（接地）的静态功耗较低，且避免了外部上拉电阻的分压损耗。开漏输出高电平虽功耗低，但驱动能力弱，仅适合低功耗通信场景。
综上，低功耗设计应优先将未使用的 IO 引脚配置为输入上拉模式，并在需要驱动时根据外设需求选择推挽或开漏输出模式，输出低电平通常更节能。

###### AI⑤
是的，在单片机中，通常情况下输入模式比输出模式的功耗要低。基于对所有 IO 口驱动模式的综合分析，其功耗高低排序及原因为：
功耗高低排序（由低到高）
1.  模拟输入模式  
2.  输入模式（浮空、上拉、下拉）
3.  输出模式（推挽、开漏） 
各模式功耗原因详细分析
1. 输入模式（Input Mode）
- 电路状态：IO 口处于高阻态，输入缓冲器工作，输出缓冲器不导通。
- 功耗分析：主要消耗是维持输入缓冲器工作的微小电流，几乎没有驱动电流，因此功耗极低。
- 细分模式：
    - 浮空输入：无内部上/下拉电阻，功耗最低，但引脚悬空时易受干扰。
    - 上拉/下拉输入：启用内部弱上拉或下拉电阻，会消耗极微弱的电流（μA 级），功耗略高于浮空输入。
2. 输出模式（Output Mode）
- 电路状态：输出缓冲器导通，主动驱动引脚为高或低电平。
- 功耗分析：输出缓冲器导通本身会消耗一定的静态电流。更重要的是，当输出高电平时，如果外接了上拉电阻到更高的电源，会形成电流回路，产生额外的功耗；当驱动外部负载（如 LED）时，电流更大，功耗显著增加。
- 细分模式：
    - 推挽输出（Push-pull）：可主动输出高电平和低电平，驱动能力强，但功耗也更高。
    - 开漏输出（Open-drain）：只能主动输出低电平，输出高电平时为高阻态，需外部上拉电阻。其功耗与上拉电阻和负载有关，通常低于推挽输出，但仍高于输入模式。
3. 复用功能模式（Alternate Function）
- 功耗分析：该模式本质上是让 IO 口服务于片内外设（如串口、SPI），其功耗特性与对应的输出模式（推挽或开漏）基本一致，因此功耗也高于输入模式。
4. 模拟模式（Analog）
- 功耗分析：此模式用于 ADC 或 DAC，数字输入输出功能被关闭，因此数字部分的功耗最低，甚至低于普通输入模式。
总结
在单片机的 IO 配置中，输入模式因其高阻态特性，功耗远低于需要主动驱动电平的输出模式。具体选择时，应根据功能需求（如驱动负载、信号检测或低功耗）来权衡功耗与性能。
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_31.jpg]]

























































































