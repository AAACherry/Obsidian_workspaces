
##### 雾化器 N300修改为 2 个触摸按键，并增加 1个 LED 灯
雾化器 N300 由3 个触摸按键修改为 2 个触摸按键，并增加了一个电源通电的 LED 灯
该 LED 灯在第 3 个地址处，所以一直没能点亮，方法也用错了。
给所有地址赋值后全亮 (全显函数可亮)，应该通过位偏移逐个点亮 LED 灯的方式去推断新增的 LED 灯所处的地址是哪里。

```
for(i=0x01;i<16;i++)
{
	ShowIcon2(a,1);
	ShowIcon2(a,2);
	ShowIcon2(a,3);
	ShowIcon2(a,4);
	//ShowIcon(i,2);
	a<<=1;
	Delay_ms(200);
}
```

```
uint8 testi=0;
unsigned char a=0x01;
unsigned char b = 0;
void main(void)
{	
	asm("nop");
	asm("clrwdt");
	OSCCON = 0X70;
	OPTION_REG = 0;
	SysInit();
	GIE=1;  //全局中断
	InitialLed();
	TouchKeyInit_System();
	delay(10);
	//uart_init();
	//Pwm4Enable(); //test
	Buzzertime=0;
	WorkState=0;
	FreshLEDFlag=1;
	
	Pwm1Enable();
	Delay_ms(200);
	Pwm1Disable();
	//TRISA1 = 0;
	//Pwm1Enable();
	
	if(b==0) {b++;ShowIcon2(0xFF,3);}
	
	while(1)
	{	
		//asm("CLR PORTB");
		//SendNumx(0);
		// 1，实现按键功能（触摸）
		// 2，串口打印
		// 3，加入pwm
		
		/*Pwm1Enable();
		Delay_ms(200);
		Pwm1Disable();
		Delay_ms(200);*/
		//ShowIcon(0x80,1);
		//Delay_ms(200);
		
		/*for(i=0x01;i<16;i++)
		{
			ShowIcon2(a,1);
			ShowIcon2(a,2);
			ShowIcon2(a,3);
			ShowIcon2(a,4);
			//ShowIcon(i,2);
			a<<=1;
			Delay_ms(200);
		}*/
		
		/*ShowAllIcon();
		Delay_ms(500);
		DarkAllIcon();
		Delay_ms(500);*/
		
		/*Pwm1Enable();
		Pwm4Enable();*/
		
		if (B_MainLoop) {
			B_MainLoop = 0;
		//	CLRWDT();
			CheckTouchKey();

			Refurbish_Sfr();
			KeyServer();
			
			if(FreshLEDFlag==1) {ShowRealTime(SetRealTime);FreshLEDFlag=0;}
			
			if(WorkState!=0) Pwm4Enable();
			else if(WorkState==0) Pwm4Disable();			
		}
		if(WorkState==0) Pwm4Disable();	
		if(b!=0) {b=0;ShowIcon2(0xFF,3);}	
	}
}
```
实际上原理图上也已经写明了，L15 灯在 R3 上，R1、R2、R3 分别对应第 1、2、3 地址（0x68、0x6A、0x6D）
![[../../annex/16.入职第十六周10.27-11.1(单休)_image_1.png]]





##### AXD-840 E

```

#define R 4  (300 ul)     //500 K  分压电阻
#define R 5  (240 ul)     //100 K
#define SARADC_FULLRANGE  (4095 ul) //adc 最大量程
#define SARADC_REFV     (180 ul)  //参考电压 avddr 2.4 v - acm 1.2 v = 1.8 v
#define V_OFFSET  ((g_s_func. E_power_type == DRY_BAT) ? ((uint 32_t) 282 ul) : ((uint 32_t) 267 ul)) //补偿 
#define V_OFFSET  ((g_s_func. E_power_type == DRY_BAT) ? ((uint 32_t) 292 ul) : ((uint 32_t) 267 ul)) //补偿 
#define V_OFFSET  ((g_s_func. E_power_type == DRY_BAT) ? ((uint 32_t) 296 ul) : ((uint 32_t) 267 ul)) //补偿 


#define CHECK_LIMIT (10 ul) //最小检测次数即取平均次数


//低电压触发阈值
#define LOW_BAT_VAL ((g_s_func. E_power_type == DRY_BAT) ? ((uint 32_t) 420) : ((uint 32_t) 340))
```


```
//BAT
//uint16  bat_val_table_BAT[] = {425, 490 , 575 ,0xffff};//最大 - 最小 / (格数 - 1) =  每格电压
uint16  bat_val_table_BAT[] = {425, 485 , 570 ,0xffff};//最大 - 最小 / (格数 - 1) =  每格电压
uint16  bat_val_table_BAT[] = {425, 485 , 565 ,0xffff};//最大 - 最小 / (格数 - 1) =  每格电压
//LI
uint16  bat_val_table[] = {300, 360 , 395 ,0xffff};//最大 - 最小 / (格数 - 1) =  每格电压
```






















































































































































