

##### AXD -846 E
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_1.png]]

使用双头 Tpye-c 数据线，连接电脑按键无反应-------
解决方式：TUDETECT 函数没有添加按键跳出的条件。

```
void TUDetect(void)
{
    AutoOffTimew = 0;
    while (1)
    {
        res = simulate_uart_get_buff_server(&stru_cmd_decode);
        if (res == 1)
        {
            if (checke_cmd_ack(E_CMD_START_COMMAND) == 1)
            {
                send_ack_cmd(E_CMD_START_COMMAND);
                AutoTestMode(); // ½øÈë×Ô¶¯²âÊÔº¯Êý
                break;
            }
        }
        else if (res == 0)
        {
        }

        if (AutoOffTimew > AutoOffTimew_1_S_COUNT * 3)
        {
            AutoOffTimew = 0;
            break;
        }

				if(!KEY_POWER || !KEY_MEMORYUP || !KEY_MEMORYDOWN || !KEY_TIME)
				{
					AutoOffTimew = 0;
          break;
				}
    }
    flag_is_auto_test_run = 0;
}
```



第三个引脚，与 GND 之间的电压为2.54V
6pin-Type-C，外面2个引脚为 GND，第2个和倒数第2个引脚为 VCC（对称）
中间两个为识别引脚，通常接5.1K 电阻。
遇到120W 不供电的情况，把中间2个引脚接 GND（可以先短接上一坨锡，然后再飞线出来接 GND）。看能不能供电。

Vcc 与 GND，5.02V
GND 与 D+，1.71V
AXD-846 E，120 W 小米充电器，机器无反应无电压时，GND 与 D+2.54V。
Vcc 与 D+，0V
Vcc 与 D-，3.3V
5.02 V

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_2.png]]

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_3.png]]

20251106，晚上要装好机器，检测抗静电时。在拆烧录线的过程中，不小心把 VM 的焊盘搞掉了。造成 LCD 显示异常（镜像显示+乱码显示）、按键等也无反应。
通过飞线，将 VM 线接好后就正常了。
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_4.png]]

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_5.png]]

###### 抗静电测试

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_6.jpg]]

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_7.jpg]]


##### AXD-840 E--锂电

&& bar_val!=7 （血压偏低时，改为不播报“若连续几天都维持这数值,请恰询您的医师”）


需要实现插入 USB: Type-C、不接锂电池时，全部功能正常使用（设置键、记忆键、测量键都可正常使用）。
而插入 USB: Type-C、且接锂电池时，只能进行设置和查看记忆，不能进入测量。

FULL 引脚和 CHARGE 引脚的不同电平状态分别代表不同的电源状态。

| FULL/Full 引脚 | CHARGE/Charge 引脚 |                 电源状态判断                  |    结构体标识变量    |                 注意/说明                 |
|:--------------:|:------------------:|:---------------------------------------------:|:--------------------:|:-----------------------------------------:|
|       1        |         1          |          空闲未充电（只接了锂电池）           |       NOCHARGE       |                                           |
|       1        |         0          |    FUll 脚高电平, 满电（接了锂电池和 USB）    |       FULL_BAT       |                                           |
|       0        |         1          | Charge 脚高电平, 正在充电（接了锂电池和 USB） |       CHARGING       |                                           |
|       0        |         0          |                       -                       |                      |                                           |
|       -        |        翻转        |   Charge 引脚间隔 2 ms 翻转电平（只接 USB）   | NO_BAT_AND_USB_INPUT | FULL 引脚和 Charge 引脚间隔 2 ms 翻转电平 |


```
//低电压触发阈值
#define LOW_BAT_VAL ((g_s_func.e_power_type == DRY_BAT) ? ((uint32_t)420) : ((uint32_t)340))

typedef enum
{
    NO_CHARGE = 0,//没有充电 空闲
    CHARGING,//正在充电
    FULL_BAT,// 充满
    NO_BAT_AND_USB_INPUT,//没有锂电但usb供电插入, 此时charge pin会一直翻转(2ms周期)
}e_charge_stat_t;
```


![[../../annex/17.入职第十七周11.3-11.7(双休)_image_8.png]]

方少，这俩引脚的状态分别是咋样的？

Full 引脚未满电的时候是 0，满电置 1；
Charge 引脚充电的时候是 0，未插入 type-c 充电的时候是1吗？
充电 IC 不一样状态可能也不一样

未插入空闲引脚都是高，充电和充满一高一低，没电池就是一直翻转

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_9.png]]

定时器中去检测有无插入 USB 充电、有无接锂电池，容易出现漏判断的情况。
而在代码中直接加入固定死循环 500 ms 去判断的话可靠性更高

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_10.png]]
进入测量，播报了个“请保持安静，现在准备开始测量血压...”中的“请”字后，立马中断，并进行播报“电力不足”→语音 ic 的 pin1悬空引脚接了 GND（原本是 pin 2 接 GND, 飞线搞错了就这样播报了）


##### 3 .05V--松瀚仿真器仿真器的工作电压

##### U80I 换屏

```
//	writeFULLmemorybank();

	while(1)
	{
		//DisplayToPUL(test1);
		//DisplayHalfByte(test1,test2);
//		WHOLevel1Icon;
//		delay(100);
//		WHOLevel2Icon;delay(100);
//		WHOLevel3Icon;delay(100);
//		WHOLevel4Icon;delay(100);
//		WHOLevel5Icon;delay(100);
//		WHOLevel6Icon;delay(100);
//		DarkAllIcon();delay(100);
		
//		SoundAllCommand2(0x55,1,0,0);	//optimal
//		delay(100);
//		SoundAllCommand2(0x55,2,0,0);	//normal
//		delay(100);
//		SoundAllCommand2(0x55,3,0,0);	//High normal
//		delay(100);
//		SoundAllCommand2(0x55,4,0,0);	//mild hypertension
//		delay(100);
//		SoundAllCommand2(0x55,5,0,0);	//moderate hypertension
//		delay(100);
//		SoundAllCommand2(0x55,6,0,0);	//Severe hypertension
//		delay(100);

//		ShowWHO(test1,test2);
//		delay(10);
//		DarkAllIcon();

//		LBTIconOn;
//		delay(10);
//		LBTIconOff;

//		BTIconOn;
//		delay(10);
//		BTIconOff;	
//		(*((volatile  uint8 xdata *)(0xf001+test1)))|=(0x01+test2);
//			delay(10);
//			(*((volatile  uint8 xdata *)(0xf001+test1)))|=(0x01+test2);
//				delay(10);
	}
```


##### FY-B01
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_11.png]]
FY_B01 加蓝牙（芯片为晶华微的芯片--BP 507），开发环境是蓝色的 CDK。其仿真用 CKLink 平头哥。

接线：
①TMS--SWCLK
②TCK--SWDIO
③GND--GND
黄色 SWCLK，蓝色 SWDIO
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_12.png]]

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_13.png]]

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_14.png]]

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_15.png]]


蓝牙数据（用 Aikankan，爱看看 APP）：
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_16.png]]

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_17.png]]

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_18.png]]

FY_B01,接 USB 供电时无法连接蓝牙；接锂电池可正常使用。

蓝牙连接不上的原因是电路问题，缺件漏焊；焊上还是连不上：虚焊了

##### RAK-N300 雾化器

RAK-N 300 雾化器:
使用 CMS-ICE 8 PRO 仿真/烧录器，接线：
①VDD-VM
②DIO--TX
③CLK--RX
④GND-GND

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_19.png]]

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_20.png]]










##### 防御性编程--不透明指针与接口封装



##### 指针大小
指针的大小不取决于它指向什么类型的数据，而主要由当前程序运行平台的寻址能力决定。
简单来说，指针是用来存放内存地址的变量，地址总线有多少根，就决定了地址编号需要多长来存储。

| 系统/平台类型 |     典型指针大小     |                          说明                          |             注意/说明              |     |
|:-------------:|:--------------------:|:------------------------------------------------------:|:----------------------------------:|:---:|
| 32 位操作系统 | 4 字节（32 bit/4 B） |           寻址空间为 2<sup>32</sup> ,即 4 GB           |                                    |     |
| 64 位操作系统 |  8 字节 (64 bi/8 B)  |           寻址空间为 2<sup>64</sup> ,即 8 GB           |                                    |     |
| STM 32（ARM） | 4 字节（32 bit/4 B） | 作为 32 位微控制器,寻址空间为 2<sup>32</sup> ,即 4 GB  |                                    |     |
|   51 单片机   |   通常为 2-3 字节    | 51 内核是 8 位 CPU，但地址总线可扩展到 16 位甚至 20 位 | 因此指针大小不固定，由编译模式决定 |     |
|               |                      |                                                        |                                    |     |

在 64 位电脑的 Keil 中编程，指针大小取决于 Keil 中为项目选择的目标平台（Target）。如果 Keil 项目配置为编译生成 64 为应用程序，那么指针大小就是 8 字节。如果配置为编译兼容 32 位系统的程序，那么指针大小就是 4 字节。
所以，主要受开发环境（编译器）根据目标平台设置的影响，而不是直接由你的电脑操作系统位数决定。

STM 32 基于 ARM 内核的 32 位微控制器，“32”位主要是指其内核的数据通路、寄存器和寻址能力是 32 位的。
51 单片机内核是 8 位的，其 CPU 一次能处理的数据宽度是 8 bit。

51 单片机和 STM 32 使用指针的区别有：
①大小不同，STM 32 上通常为 4 字节，51 单片机不统一，但通常为 2 字节。
②寻址范围不同，STM 的 32 位指针可以访问完整的 4 GB 地址空间；51 单片机的指针受其地址总线宽度限制。
③不同类型的指针大小相同，但指针类型决定指针的运算（如 p+1）的步长。在 51 上，由于存在多种内存空间（如 code、xdata 等），指针类型还可能隐含了所指向的存储区域。

指针大小的最根本决定因素是 CPU 的寻址位数（逻辑寻址空间）。编译器和开发环境会根据目标硬件（即程序要运行的芯片）的寻址能力来确定指针大小。
个人电脑的位数（开发环境），只会影响能否编译出对应位数的程序，而不影响最终单片机程序里指针的大小。



##### XLF 906 M (906 A) MP5 PLUS WRITER 烧录器接法
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_21.png]]


##### IspowerOn 变量--是否进休眠

##### 语音规格承认书
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_22.png]]

##### %n，保留末位 n 位；/m，舍弃末位 m 位

##### 节约内存空间的使用

```
typedef	struct
{
	uint8_t rec		:1;
	uint8_t tran	:1;
	uint8_t recOver :1;
	uint8_t Receive_END :1;
	uint8_t NoReceive :1;
	uint8_t rctimeOver :1;
	uint8_t sdtimeOver :1;
	uint8_t NO_ACK_CS :1;

	uint8_t Disallflag :1;
	uint8_t adcupdata:1;

}stateFlag_typedef;

typedef volatile union byte_bit
	{
		struct
		{
			uint8 bit0:1;
			uint8  bit1:1;
			uint8  bit2:1;
			uint8  bit3:1;
			uint8  bit4:1;
			uint8  bit5:1;
			uint8  bit6:1;
			uint8  bit7:1;
		}bt;
		uint8    b;
	}byte_bit;
typedef volatile union word_data
{
	uint16 	w;
	uint8 	b[2];
}word_data;
typedef volatile union dword_data
{
	uint32    l;
	uint16 	w[2];
	uint8 	b[4];
}dword_data;

typedef union nword_data 
{
	uint32    w;
	uint16 	b[2];
}nword_data;

extern volatile union byte_bit					MeasureStateFlag;
#define   SamplePressure		MeasureStateFlag.bt.bit0
#define   SampleSignal  		MeasureStateFlag.bt.bit1

extern volatile union byte_bit					STATEFlag1;
#define   First30mmHg  			STATEFlag1.bt.bit0
#define   MemoryMode				STATEFlag1.bt.bit1
#define   RePump   					STATEFlag1.bt.bit2
#define   GetLeakagePresureFlag	STATEFlag1.bt.bit3
#define   MemoryFull				STATEFlag1.bt.bit4
#define   FirstDeflate  		STATEFlag1.bt.bit5

extern volatile union byte_bit					OneShotFlag;
#define   OneShot 					OneShotFlag.bt.bit0
#define   OneShotDC					OneShotFlag.bt.bit1
#define   KeyIn 						OneShotFlag.bt.bit2
#define   SecondFlag				OneShotFlag.bt.bit3
#define   OneShotPump				OneShotFlag.bt.bit4
#define   OneShotValve			OneShotFlag.bt.bit5
#define   OneShotRX					OneShotFlag.bt.bit6

extern volatile union byte_bit					initstates;
#define   SmallSignalOn 		initstates.bt.bit0
#define   NormalSignal  		initstates.bt.bit1
#define   LargeSignalOn 		initstates.bt.bit2


extern volatile union	word_data				Xx;
#define	  Xxw 							Xx.w
#define	  Xx2b							Xx.b[1]
#define	  Xx1b							Xx.b[0]

extern volatile union	word_data				Dy;
#define	  Dyw 							Dy.w
#define	  Dy2b							Dy.b[1]
#define	  Dy1b							Dy.b[0]


extern volatile union byte_bit  KeyModeFlag;
#define	SetKeyFlag 		KeyModeFlag.bt.bit0
#define	MemoryKeyFlag	KeyModeFlag.bt.bit1
#define	PowerKeyFlag	KeyModeFlag.bt.bit2

extern volatile union 	byte_bit				mtemp0c,mtemp1c;
extern volatile union 	byte_bit				IDbuffer;
extern volatile union 	byte_bit				ibuffer;
extern volatile union	nword_data				PulseRam[63];
extern volatile union	nword_data				PulsePressure[4];

```


##### 三位数组形式点 LCD 屏幕
2.1 LCD 显示字符映射表

```
Const uint 8 LCDTableA[] = {
    AChar_0, AChar_1, ..., AChar_H  // 字符 0-9, A-F 及其他特殊字符的段码定义
};
```

2.2 三维数组 LCD 3 - 核心显示映射

```
Uint 8 LCD 3[disp_posit_max][7][2] = {
    // 格式: {SEG 寄存器地址, COM 位掩码}
    {
        {20, (1 << 2)}, // 位置 1 的第 a 段 - SEG 20, COM2
        {21, (1 << 2)}, // 位置 1 的第 b 段 - SEG 21, COM2
        // ... 共 7 段 (a-g)
    },
    // 其他显示位置...
};
```


三维数组含义：
第一维：显示位置（如月份个位、日期十位等）
第二维：每个数字的 7 个段（a-g）
第三维：段对应的硬件信息【SEG 地址, COM 掩码】

###### 3.1 显示单个数字函数

```
void DisplayHalfByte2(e_disp_dat_t e_dat, e_disp_posit_t e_posit)
{
    // 1. 参数验证
    if (e_posit == MemorySetHundred) return;
    if (e_posit超出范围) return;
    
    // 2. 特殊位置数字范围检查（如小时十位只能显示0-2）
    if ((e_posit == HourTen) && (e_dat无效)) return;
    
    // 3. 获取字符段码
    temp = LCD2[e_dat];  // 从映射表获取段码
    
    // 4. 逐段显示控制
    for (i = 0; i < 7; i++) {
        if (段码包含当前段) {
            ShowIcon(LCD3[e_posit][i][1], LCD3[e_posit][i][0]); // 点亮段
        } else {
            DarkIcon(LCD3[e_posit][i][1], LCD3[e_posit][i][0]); // 熄灭段
        }
    }
}
```

###### 3.2 血压值显示函数

```
void DisplayToSYSDIA(unsigned int SYS, unsigned char position)
{
    if (position == 1) { // 收缩压显示
        if (SYS < 100) 显示空;  // 百位为空
        else 显示百位数字;
        
        if (SYS < 10 && 单位标志) 显示空;  // 十位为空  
        else 显示十位数字;
        
        显示个位数字;
    }
    // 舒张压显示类似...
}
```

###### 4. 显示位置枚举说明

```
typedef enum {
    MonthSingle = 1,    // 月份个位
    DayTen,             // 日期十位  
    DaySingle,          // 日期个位
    HourSingle,         // 小时个位
    MINTen,             // 分钟十位
    MINSingle,          // 分钟个位
    SYSHundred,         // 收缩压百位
    SYSTen,             // 收缩压十位
    SYSSingle,          // 收缩压个位
    DIAHundred,         // 舒张压百位
    DIATen,             // 舒张压十位
    DIASingle,          // 舒张压个位
    // ... 其他位置
} e_disp_posit_t;
```

##### 5. 工作流程
###### 5.1 初始化流程

```
LCD_GPIOInit() → LCD_FunIOInit() → LCD_StructInit() → lcd_ram_init()
```

###### 5.2 数据显示流程

```
获取要显示的数字 → 通过LCD2映射表转换为段码 → 
通过LCD3三维数组找到对应的SEG/COM地址 → 
写入LCD控制器寄存器 → 硬件显示
```

###### 6. 变量含义说明


```
全局变量：
-   ••
    `seg_buf`：指向LCD段寄存器的指针，直接控制显示内容
-   ••
    `ShowTimeDateFlag`：显示状态标志位
-   ••
    `flag_is_refresh_display_now`：立即刷新显示标志

参数变量：
-   ••
    `e_dat`：要显示的数字/字符（0-9, A-F等）
-   ••
    `e_posit`：显示位置（对应LCD3的第一维索引）
```










##### 防止快按时，出现语音播报“高，高...”重复播报第一个字后再被打断
可在语音播报前有一段如500ms 的延时，其中判断一下按键是否有快按

##### 语音播报会异常
↑
1.算法
2.Keil 版本不对
3.引脚配置不对
4.RAM 超内存了

##### 记忆内容显示 : 255, , 255, Hi 的问题
问题所在: 索引不对，索引到了没有记忆的存储区 (高压、低压、脉搏的索引内存空间的值为 0，0，0，即初始化值)，而 tomemorykeyin 函数中，会判断高低压的值，故该异常值的情况会显示 255，255，Hi。

##### N300 的定时器配置计算
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_23.jpg]]


##### 芯片型号
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_24.jpg]]

BP018，蓝牙型号，RX→TX, TX→RX

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_25.jpg]]













##### 其他
###### P126
3.3 x 0.7
3.3 V 稳压 ic
100 K、100 K，250
上面的改成 62 K，70 K
0.6 几

###### 喇叭->蜂鸣器？
喇叭，内部线圈，几Ω
蜂鸣器，...Ω
有无限流电阻？
喇叭代替蜂鸣器寿命如何？

直流/交流驱动？

###### 抗静电测试
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_26.jpg]]

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_27.jpg]]

##### 软件版本号
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_28.jpg]]


##### Temp<<=1 和 Temp<<1
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_29.png]]



##### 表达式分析 - 范围内递增公式

###### 1. temp = (temp - 1 + 3) % 3 + 1 

**目的和作用：**
-   ••
    在1、2、3三个值之间**循环递减**
-   ••
    每次将temp的值减1，当小于1时循环回到3

**执行过程：**
```
temp=1 → (1-1+3)=3 → 3%3=0 → 0+1=1
temp=2 → (2-1+3)=4 → 4%3=1 → 1+1=2  
temp=3 → (3-1+3)=5 → 5%3=2 → 2+1=3
```


###### 2.temp = temp % 3 + 1

**目的和作用：**
-   
    在1、2、3三个值之间**循环递增**
-   
    每次将temp的值加1，当大于3时循环回到1

**执行过程：**
```
temp=1 → 1%3=1 → 1+1=2
temp=2 → 2%3=2 → 2+1=3
temp=3 → 3%3=0 → 0+1=1
```


###### 3. 限制条件

**数值范围的限制：**
-   
    两个表达式都假设temp是正整数
-   
    如果temp可能为0或负数，需要额外处理
-   
    如果temp值很大，取模运算可以正常工作

**边界条件：**
-   
    当 temp=0时：**0%3+1=1** （第二个表达式）
-   
    当 temp=0时：**(0-1+3)%3+1=2%3+1=3** （第一个表达式）
实际效果：这个表达式实际上 **保持 temp 值不变**，是一个恒等变换

temp=(temp-1+3)%3+1；
temp=temp%3+1。
###### 其目的、作用分别是什么？有什么限制吗？数字3、1的值可以任意替换成其他值吗？
第一个表达式用于将 temp 规范到区间【m, m+n-1】（如果 temp 不在这个区间，则映射到区间内），如果 temp 在区间内则不变。

第二个表达式用于在区间【m, m+n-1】内循环递增（每次加1，循环）。

替换后的通用公式：**temp = (temp - a + n) % n + a** 或 **temp = temp % n + a**
**替换限制：**
-   ••
    n必须为正整数（除数不能为0）
-   ••
    a可以是任意整数，决定循环的起始值
-   ••
    循环范围大小由 n 决定，循环区间为【a, a+n-1】

Temp =（temp-a+1）%n+a
Temp =（temp-a-1+n）%n+a
- 对于 n 和 a，可以是任意整数，但 n 必须是正整数，a 可以是任意整数。循环的范围是【a, a+n-1】。
- 对于大于10的循环，比如100，1000，10000，都是适用的，只要 n 是正整数，且 temp 是整数。但是要注意整数范围，如果 temp 很大，要避免溢出。
- 数字大小范围限制：由于取模运算，只要 n 不是0，就可以进行。但是要注意，在编程中，如果 n 为0，会除以0导致错误。另外，如果 n 很大，而 temp 是负数，可能需要调整确保非负。在 C 语言中，取模运算对于负数的情况，不同的编译器可能有不同的结果，所以通常我们保证被模数是非负的，比如加上 n 的倍数。
- 因此，我们通常使用非负的模运算，即先加上 n 的倍数使其非负，再取模。


- **n 必须是正整数**（n > 0）
- **a 可以是任意整数**（正数、负数、零）
- **temp 可以是任意整数**

循环递增的通用写法（避免负数模运算）：

temp = (temp - a + 1 + n) % n + a // 加上n确保非负，但这里1步长，加上一个n就够了吗？实际上，因为temp-a可能为负，所以我们可以加上多个n，但通常加一个n就够，因为(temp - a + 1)最小为（最小temp - a + 1），我们加上n后，再取模，就可以得到非负。

但是，为了确保非负，我们通常加上足够的n的倍数，使得整个被模数非负。由于步长为1，我们只需要加上一个n就可以保证非负，因为(temp - a + 1)的最小值可能是负的，但加上一个n后，最小值就是n-（区间长度），但因为我们不知道temp的范围，所以加上n可以保证非负吗？不一定，如果temp比a小很多，那么加一个n可能不够。所以更通用的做法是加上多个n，或者使用条件判断。

实际上，我们通常知道 temp 的范围，或者我们允许 temp 任意整数，那么我们可以用：
temp = (temp - a + 1) % n;
if (temp < 0) temp += n;
temp += a;

循环递减：
temp = (temp - a - 1) % n;
if (temp < 0) temp += n;
temp += a;

所以，通用的循环递增和循环递减函数可以这样写（C 语言）：
```
循环递增：
int cycle_increment(int temp, int a, int n) {
int res = (temp - a + 1) % n;
if (res < 0) res += n;
return res + a;
}
```

```
循环递减：
int cycle_decrement(int temp, int a, int n) {
int res = (temp - a - 1) % n;
if (res < 0) res += n;
return res + a;
}

```

对于任意整数 temp，a 和正整数 n，都可以将 temp 在区间【a, a+n-1】内循环递增或递减。
-   原表达式并不是循环递增和循环递减，需要修改。
-   修改后的公式可以通用，n和a可以是任意整数，但n必须是正整数。
-   对于大范围（如100,1000,10000）都适用，只要整数不溢出。
但是，在编程中，要注意整数溢出的问题，如果 temp、a、n 的范围很大，可能需要使用长整型。


##### 总结
##### 1. 整数循环公式
###### 1.1 基础公式

```
// 循环递增：temp = temp % n + a 
```

**限制条件：**
-   n 必须为正整数
- temp 应为非负整数（或确保语言对负数取模行为符合预期）
- 循环范围：【a, a+n-1】

适用场合：**​ 菜单循环、星期循环、月份循环等**

```
// 循环递减：temp = (temp - a + n) % n + a
```
**限制条件：**
-  n 必须为正整数
- 对负数的处理比递增公式更友好

###### 1.2 负整数循环
// 负整数循环递增：在【-a, -a+n-1】范围内递增 
```
temp = (temp + a) % n - a; 
temp = (temp + a + 1) % n - a; 
```
**限制条件：**
-  循环范围：【-a, -a+n-1】
- 需要确保负数取模行为正确

// 负整数循环递减：在【-a, -a+n-1】范围内递减 
```
temp = (temp + a + n - 1) % n - a;
```
###### 1.3 跨越0点的正负整数混合循环
// 在【-m, n】范围内循环递增 

```
temp = (temp + m) % (m + n + 1) - m;
temp = (temp + m + 1) % (m + n + 1) - m;
```



###### 1.4 任意起止点的整数循环

```
// 在[start, end]范围内循环递增
temp = (temp - start) % (end - start + 1) + start;

// 在[start, end]范围内循环递减
temp = (temp - start + (end - start)) % (end - start + 1) + start;

// 示例：在[10, 15]范围内循环
// 递增：10 → 11 → 12 → 13 → 14 → 15 → 10...
temp = (temp - 10) % 6 + 10;


temp = (temp - start + 1) % (end - start + 1) + start
```

##### 2. 浮点数循环公式
###### 2.1 基础浮点数循环

```
// 浮点数循环递增：[a, a+n)范围内
temp = fmod(temp - a + n, n) + a;

// 浮点数循环递减：[a, a+n)范围内  
temp = fmod(temp - a, n) + a;  // 注意：这实际上是递增，需要调整

// 正确的浮点数循环递减
temp = a + n - fmod(a + n - temp, n) - 0.000001; // 减小数避免边界问题


temp = fmod(temp - a + step, n) + a
```

###### 2.2 带步长的浮点数循环

```
// 浮点数循环（通用公式，支持正负步长）
temp = fmod(temp - a + step + n, n) + a;

// 示例：在[0.0, 5.0)范围内，步长0.5
// 0.0 → 0.5 → 1.0 → ... → 4.5 → 0.0...
temp = fmod(temp - 0.0 + 0.5 + 5.0, 5.0) + 0.0;
```

###### 2.3 浮点数光滑循环（避免边界跳跃）

```
// 使用三角函数实现光滑循环（周期函数）
temp = a + n/2 + (n/2) * sin(2 * M_PI * (temp - a) / n);

// 或者使用模运算与线性插值结合
temp = a + fmod(temp - a, n) + (temp < a ? n : 0);
```

##### 3. 特殊循环模式
###### 3.1 双向摆动循环（如-1,0,1,0,-1,0,1...）

```
// 在[-m, m]范围内摆动
temp = abs((temp + m) % (2*m + 2) - m - 1) - 1;

// 示例：在[-1, 1]范围内摆动
// -1 → 0 → 1 → 0 → -1 → 0 → 1...
temp = abs((temp + 1) % 4 - 2) - 1;
```

###### 3.2 斐波那契式循环（指数增长后归零）

```
// 不是真正的循环，但实现类似循环的指数模式
temp = (temp * factor) % (max_value + 1);

// 示例：因子=2，最大值=7
// 1 → 2 → 4 → 1 → 2 → 4 → 1... (8会变成1)
temp = (temp * 2) % 8;
```

###### 3.3 质数模数循环（确保完全遍历）

```
// 当n为质数时，任何步长都能遍历所有元素
temp = (temp * prime_step) % prime_n;

// 示例：n=7(质数)，step=3
// 1 → 3 → 2 → 6 → 4 → 5 → 1 → 3...
temp = (temp * 3) % 7;
```

##### 4. 多维循环公式 
###### 4.1 二维网格循环（行优先）

```
// 在rows×cols网格中循环
int total = rows * cols;
int pos = (current_pos + 1) % total;
int row = pos / cols;
int col = pos % cols;

// 一行公式（合并行列计算）
temp = ((temp / cols) * cols + (temp % cols + 1) % cols) % total;
```

###### 4.2 三维空间循环

```
// 在x×y×z空间中循环
int total = x_size * y_size * z_size;
int pos = (current_pos + 1) % total;
int x = pos % x_size;
int y = (pos / x_size) % y_size; 
int z = pos / (x_size * y_size);
```

##### 5. 实用简化公式
###### 5.1 布尔值切换（最简循环）
```
// 布尔值循环：true ↔ false
temp = !temp;
// 或使用：temp = 1 - temp;
```

###### 5.2 三态循环
```
// 在-1, 0, 1之间循环
temp = ((temp + 2) % 3) - 1;
// -1 → 0 → 1 → -1 → 0 → 1...
```

###### 5.3 颜色循环（RGB）
```
// 在0-255范围内循环颜色值
red = (red + step) % 256;
green = (green + step) % 256;  
blue = (blue + step) % 256;
```

##### 6. 边界安全的通用公式
```
// 处理所有边界情况的通用循环公式
temp = start + ((temp - start + step) % range_size + range_size) % range_size;

// 浮点数安全版本
temp = start + fmod(fmod(temp - start + step, range_size) + range_size, range_size);
```

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_30.png]]


##### 为什么不用等差/等比数列
等差数列确实能生成序列，但循环特性需要手动处理边界，比如到最大值后跳回最小值。取模运算天然适合循环，因为它自动处理溢出，代码更简洁。比如用等差公式得写条件判断，而取模一行搞定，这在嵌入式或性能敏感场景很重要。

用等差需要判断索引是否越界，而取模自动回绕。同时要提到等比数列的局限性，比如指数增长不适合固定范围循环，除非配合取模限制范围。

###### 1. 为什么不用等差/等比数列公式？

###### 1.1 数学本质差异

等差数列公式：​ aₙ = a₁ + (n-1)d
- 生成线性序列，但不自动循环
- 需要额外处理边界和回绕

取模运算： value % modulus
-  天生具有循环特性
-  自动处理边界回绕

###### 1.2 代码实现对比
```
// 使用等差数列实现循环（需要条件判断）
int next_value = current + step;
if (next_value > max_value) {
    next_value = min_value + (next_value - max_value - 1);
} else if (next_value < min_value) {
    next_value = max_value - (min_value - next_value - 1);
}

// 使用取模实现循环（一行代码）
int next_value = (current - min_value + step + range_size) % range_size + min_value;
```

###### 2. 等差/等比数列的循环表达
###### 2.1 等差数列的循环实现
```
// 等差数列循环公式（模仿取模风格）
temp = min_value + (temp - min_value + step) % (max_value - min_value + 1);

// 等效于
temp = (temp - min_value + step) % range_size + min_value;
```

###### 2.2 等比数列的循环实现
```
// 等比数列循环（需要指数和对数运算）
temp = min_value + pow(ratio, (log(temp - min_value + 1) / log(ratio) + 1) % range_size);

// 这显然比取模复杂得多，且不实用
```

![[../../annex/17.入职第十七周11.3-11.7(双休)_image_31.png]]

###### 6.1适合取模的场景
-   ••
    **循环缓冲区**：固定大小的队列
-   ••
    **状态机循环**：有限状态循环
-   ••
    **时间周期计算**：星期、月份等
-   ••
    **游戏开发**：角色循环移动、动画帧

###### 6.2 适合等差/等比的场景
-   ••
    **无限序列**：不需要循环的序列
-   ••
    **数学计算**：需要精确数学表达式时
-   ••
    **性能极端敏感**：某些特定硬件平台

###### 6.3 混合使用方案
```
// 使用等差数列生成序列，用取模实现循环
int sequence(int n, int start, int step, int modulus) {
    return (start + n * step) % modulus;
}

// 或者先计算再取模
int value = start + step * index;
int cyclic_value = value % modulus;
```

###### 8.1 推荐使用取模的情况
```
// 1. 简单循环
index = (index + 1) % count;

// 2. 带步长循环  
index = (index + step) % count;

// 3. 有偏移的循环
value = (value - min + step) % range + min;

// 4. 双向循环（支持负步长）
index = (index + step + count) % count;
```




##### ％、/、+、-、x 运算、位运算(<<、>>、＆、||等运算)在 C 语言中、51单片机中的执行速度、运算速度分别有什么区别？一样吗？

需要注意的是，51单片机是8位单片机，其运算通常由软件库或硬件指令支持，但硬件指令可能只支持部分基本运算

在51单片机中，运算速度大致排序（从快到慢）：

位运算（尤其是对位地址的操作） > 加减法 > 乘法/除法/取模

在通用的 C 语言环境中（比如在 PC 上），现代处理器对各种运算都有很好的优化，速度差异可能不明显，但大致顺序相似：位运算和加减法很快，乘除法和取模较慢。

因此，在编写51单片机的程序时，应尽量避免使用乘除法和取模运算，尤其是在中断服务程序或对实时性要求高的地方。可以考虑使用位运算代替部分乘除法（例如，乘以2的幂可以用左移实现）。

举例：
-   ••
    代替乘法：a * 8 可以写为 a << 3
-   ••
    代替除法：a / 4 可以写为 a >> 2
-   ••
    取模运算：a % 8 可以写为 a & 7

但是注意，这种替代只适用于2的幂次方。
对于非2的幂次方的乘除法，不能直接用移位代替。取模运算也是如此。

###### 1. 运算速度概述

###### 1.1 通用 C 语言环境（现代处理器）

在现代处理器上，基本运算速度通常遵循以下顺序（从快到慢）：
- 位运算（<<, >>, &, |, ^, ~）
- 加减法（+, -）
- 乘法（x）
- 除法（/）
- 取模（%）

###### 1.2 51单片机环境

在51单片机中，由于硬件限制，运算速度差异更加明显：
- 位运算（最快，单周期或接近单周期）
- 加减法（较快，1-2周期）
- 乘法（较慢，4周期）
- 除法（慢，4周期）
- 取模（最慢，需要多次运算）

```+、-
// C语言（现代处理器）：通常1时钟周期
int a = b + c;
int d = e - f;

// 51单片机：1-2时钟周期
// 8位加减：1周期
// 16位加减：2周期
// 32位加减：4周期或更多
```


###### 3. 51单片机特殊优化
###### 3.1 51单片机的位寻址优势
```
// 51有专门的位寻址空间（20H-2FH）
bit flag;  // 定义位变量
flag = 1;  // 单周期操作

// 对比普通变量的位操作
unsigned char flags;
flags |= 0x01;  // 需要读-改-写，至少2周期
```

##### 4.2 实际应用中的优化策略
###### 4.2.1 替代乘除法

```
// 避免使用乘法
// 慢：a = b * 10;
// 快：a = (b << 3) + (b << 1);  // 8b + 2b = 10b

// 避免使用除法
// 慢：a = b / 8;
// 快：a = b >> 3;  // 右移3位等于除以8
```

###### 4.2.2 替代取模运算
```
// 慢：a = b % 8;
// 快：a = b & 0x07;  // 与7进行与运算

// 慢：a = b % 16;
// 快：a = b & 0x0F;  // 与15进行与运算
```

# 乘除法和取模运算的位运算优化技巧
## 1. 2的幂次方运算的优化（最常用）
### 1.1 乘法优化：左移位代替乘法
```
// 原始乘法（慢）
result = value * 8;     // 乘以8
result = value * 16;    // 乘以16
result = value * 32;    // 乘以32

// 优化版本（快）- 使用左移位
result = value << 3;    // 2^3 = 8，相当于乘以8
result = value << 4;    // 2^4 = 16，相当于乘以16  
result = value << 5;    // 2^5 = 32，相当于乘以32

// 通用公式：value * (2^n) = value << n
```

### 1.2 除法优化：右移位代替除法
```
// 原始除法（慢）
result = value / 8;     // 除以8
result = value / 16;    // 除以16
result = value / 32;    // 除以32

// 优化版本（快）- 使用右移位
result = value >> 3;    // 2^3 = 8，相当于除以8
result = value >> 4;    // 2^4 = 16，相当于除以16
result = value >> 5;    // 2^5 = 32，相当于除以32

// 通用公式：value / (2^n) = value >> n
```

### 1.3 取模优化：按位与代替取模
```
// 原始取模（慢）
result = value % 8;     // 对8取模
result = value % 16;    // 对16取模
result = value % 32;    // 对32取模

// 优化版本（快）- 使用按位与
result = value & 0x07;  // 8-1=7，二进制0111
result = value & 0x0F;  // 16-1=15，二进制1111  
result = value & 0x1F;  // 32-1=31，二进制00011111

// 通用公式：value % (2^n) = value & ((1 << n) - 1)
```

## 2. 非2的幂次方运算的优化
### 2.1 乘法分解：分解为2的幂次方组合
```
// 原始乘法（慢）
result = value * 10;    // 乘以10
result = value * 12;    // 乘以12
result = value * 15;    // 乘以15

// 优化版本 - 分解为移位和加法
result = (value << 3) + (value << 1);  // 8*value + 2*value = 10*value
result = (value << 3) + (value << 2);  // 8*value + 4*value = 12*value  
result = (value << 4) - value;         // 16*value - value = 15*value

// 更多例子：
result = value * 5   → (value << 2) + value;      // 4+1=5
result = value * 7   → (value << 3) - value;      // 8-1=7
result = value * 9   → (value << 3) + value;      // 8+1=9
result = value * 13  → (value << 4) - (value << 2) + value; // 16-4+1=13
```

### 2.2 除法近似：使用移位和调整
```
// 原始除法（慢）
result = value / 3;     // 除以3
result = value / 5;     // 除以5
result = value / 10;    // 除以10

// 近似优化版本（有精度损失）
result = (value * 0x5555) >> 16;  // 近似除以3 (0x5555 ≈ 1/3)
result = (value * 0x3333) >> 16;  // 近似除以5 (0x3333 ≈ 1/5)
result = value >> 3 + value >> 5;  // 近似除以10 (1/8 + 1/32 ≈ 0.125+0.03125=0.15625)

// 更精确的方法（需要调整）
result = (value + (value >> 4)) >> 3;  // 改进的除以10近似
```

### 2.3 取模优化：减法和移位组合
```
// 原始取模（慢）
result = value % 7;     // 对7取模
result = value % 10;    // 对10取模
result = value % 15;    // 对15取模

// 优化版本（需要循环或条件判断）
// 对7取模：value - 7 * (value / 7)
// 但需要先优化除法，不推荐

// 更好的方法：使用位运算特性
result = value - ((value * 0x24924924) >> 32) * 7;  // 对7取模的近似
```

### 总结
优先使用位运算替代的场景：

- **2的幂次方**的乘除法和取模：直接使用移位和按位与
- **小常数乘法**：分解为2的幂次方组合
- **性能关键代码**：即使可读性稍差也值得优化

**谨慎使用位运算的场景：**
- **需要高精度**的结果时
- **数值可能溢出**时
- **代码可读性**更重要时

# 非2的幂次方运算的通用优化公式与原理分析
## 1. 非2的幂次方运算的通用优化公式
### 1.1 乘法运算通用分解公式

对于任意整数乘法 `value * N`，可以将其分解为2的幂次方的线性组合：

通用公式： `value * N = Σ(value << k_i)`
其中 k_i 是 N 的二进制表示中为1的位的位置（从0开始计数）

数学表达：​
如果 `N = 2^a + 2^b + 2^c + ...`
那么 `value * N = (value << a) + (value << b) + (value << c) + ...`

```示例
// N = 10 (二进制 1010 → 2^3 + 2^1)
value * 10 = (value << 3) + (value << 1)

// N = 13 (二进制 1101 → 2^3 + 2^2 + 2^0)  
value * 13 = (value << 3) + (value << 2) + value

// N = 21 (二进制 10101 → 2^4 + 2^2 + 2^0)
value * 21 = (value << 4) + (value << 2) + value
```

### 1.2 除法运算近似公式

对于除法 `value / N`，可以使用定点数乘法近似：

通用公式：​ `value / N ≈ (value * M) >> K`

其中 `M ≈ 2^K / N`，需要精心选择 M 和 K 来平衡精度和范围

```
// value / 3 ≈ (value * 0x5555) >> 16
// 因为 0x5555/65536 ≈ 0.333328 ≈ 1/3

// value / 5 ≈ (value * 0x3333) >> 16  
// 因为 0x3333/65536 ≈ 0.199996 ≈ 1/5

// value / 7 ≈ (value * 0x2492) >> 16
// 因为 0x2492/65536 ≈ 0.142853 ≈ 1/7
```

### 1.3 取模运算优化公式

对于取模 `value % N`，可以使用除法的优化结果：

通用公式：​ `value % N = value - N * (value / N)`

结合除法优化公式使用


#### 会不会多此一举？
51单片机、32单片机中的乘除法、取模运算是如何实现的？我用上述方法，将乘除法、取模运算替换为移位运算对提升运算速度究竟有没有作用？还是说底层的逻辑乘除法、取模运算已经是通过移位等方式实现了，实际软件代码完全没有必要再去移位表达乘除法和取模运算，会不会多此一举了？

1.  对于51单片机（比如经典的8051内核），硬件资源极其有限。乘法（MUL）和除法（DIV）确实有单条指令支持，但仅限8位操作。对于更复杂的运算（比如16位乘除、取模），编译器生成的代码确实是通过多个步骤（包括移位、加减）的软件库实现的。在这种情况下，手动优化非常有价值，特别是用移位代替2的幂次方运算，或者用移位加法组合代替小常数乘法。
2. 对于32位单片机（比如 ARM Cortex-M 系列），情况完全不同。现代 Cortex-M 内核基本都有硬件乘法器（甚至硬件除法器），一条指令就能完成32位乘法。编译器也会自动将明显的2的幂次方运算（如乘以8）优化为移位指令。这时候手动优化可能确实是多此一举，甚至可能干扰编译器的优化策略

-   51单片机：手动优化很有必要，特别是非2的幂次方运算
-   32位单片机：优先相信编译器，只在性能热点处考虑手动优化


##### C 语言实现多态？



##### 状态机思想？




##### 
对拓展开放，对修改封闭

高内聚、低耦合。高内聚指模块内部元素紧密相关，低耦合指模块间依赖关系尽可能少且松散。


##### TTL 接口




##### PCS
PCS 指的是件数

##### Pin to pin
芯片 Pin to pin 指的是芯片之间的直接物理连接，常用于描述两个电路板或模块之间通过针脚对齐的方式进行电气通信。该模式下，源芯片的各个输入输出引脚（即 pin）直接对应目标芯片的对应引脚，无需额外的适配器或转换。


##### 内存中的 OTP
内存中的 OTP 指的是一次性可编程存储器，一种特殊类型的非易失性存储器，允许用户仅写入数据一次，之后无法修改或擦除。


##### 三极管
三极管的压降取决于其工作状态和材料类型。
饱和状态下，小功率硅三极管的集电极-发射极饱和压降通常在 0.1 V 至 0.3 V 之间。
基极-发射极对于硅管约 0.6 至 0.7 V 压降，锗管则为 0.2 V 至 0.3 V。

三极管基极为什么要接一个电阻？
三极管基极串联电阻主要用于限流保护，而并联（下拉）电阻则用于确保可靠截止和稳定工作状态。

三极管基极的高低电平主要取决于其类型，NPN 型需要高电平导通，PNP 型需要低电平导通。
高电平使得 NPN 导通，PNP 截止；低电平使得 PNP 导通，NPN 截止。

三极管的三种工作状态：
截止状态
放大状态
饱和状态


##### 伺服
伺服意指完全服从控制指令的系统。




##### PCM 01 蓝牙接线
![[../../annex/17.入职第十七周11.3-11.7(双休)_image_32.png]]














































































































































































