[2025-11-22 18：19：15]

## N 300 雾化器

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_1.png]]

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_2.png]]





## 玫丽科技 A01 干电改锂电
主控为 BP00B
LI_BAT 锂电，DRY_BAT 干电


晶华微，烧录不进程序，通信异常。
晶振电压不对，换晶振后还是这样，实际为主控焊错了，没有按照丝印焊 (引脚对不上)。

红正黑负，线接反后，小电源供电。电压从3.5V→1.4V。

晶振两端电压
供电3.52 V 时；0.52 V、  0.36 V
供电4.0 V 时;    0.368 V、0.458 V


![[../../annex/19.入职第十九周11.17-11.21（双休）_image_3.png]]

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_4.png]]

```
压力传感器。
锂电池：4.092V
pin1（A7）：0.273V
pin2（VO-）：1.515V
pin3（A8）：2.743V
pin4：0V（悬空）
pin5（VO+）:1.512V
pin6（A7）：0.273V
```


#### 万用表测量数据

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_5.png]]


```
锂电池供电（不插USB）：
pin1（GND）：0V
pin2（U7-2）：0V
pin3（GND）：0V
pin4（VUSB）：0V
pin5（VBT）：4.085V
pin6（FULL）：3.286V
pin7（CHRG）：3.287V
pin8（VUSB）：0V
```

```
插入 USB 供电（不插锂电池）：
Pin 1（GND）：0 V
Pin 2（U 7-2）：0 V
Pin 3（GND）：0 V
Pin 4（VUSB）：4.99 V
Pin 5（VBT）：4.088 V
Pin 6（FULL）：2.222 V
Pin 7（CHRG）：1.062 V
Pin 8（VUSB）：5.0 V
```

```
锂电池供电（插入USB）：
pin1（GND）：0V
pin2（U7-2）：0.325V
pin3（GND）：0V
pin4（VUSB）：4.99V
pin5（VBT）：4.152V
pin6（FULL）：3.285V
pin7（CHRG）：0.001V
pin8（VUSB）：5.0V
```




代码内容与 AXD-840 E 一致。
```
void charge_mode(void)
{
	uint16_t bat_val;
	uint16_t bat_cells;
	uint16_t show_cells;
	uint8_t Show_FULL = 0;
	
	if (get_cur_charge_stat() == NO_CHARGE)
	{
		return;
	}
	
	if(get_cur_charge_stat() == CHARGING)
	{
		IsPowerOn = 1;
    VALVE_OFF;
    PUMP_OFF;
		aky_disp_clear_all();
		
		bat_val = get_cur_bat_val_by_math();
		bat_cells = get_baterry_cells(bat_val);
		
		if (bat_cells <= 0)
    {
        //始终从第1格开始
        bat_cells = 1;
    }  
		
		charge_mode_show_bar(bat_cells);	//快速刷新显示一次
		
		
//aky_disp_single_tube(bat_cells, MemorySetTen);	//test
//while(KEY_SET);
		
//		wait_all_key_release();
//		
//		off_time_tick_clr();
	}
		wait_all_key_release();
		
		off_time_tick_clr();
		while(1)
		{
			 if(uart_rx_trig())
			 {
					 //锂电usb插入充电时检测自动工装
					 TUDetect();
			 }
			 
			if(get_cur_charge_stat() == CHARGING)
			{
				Show_FULL = 0;
        if (TIME_320MS == 1)
        {
            if (g_s_flag_group.flag_one_shot == 1)
            {
                g_s_flag_group.flag_one_shot = 0;

                //充电3s关闭背光
                if (get_cur_off_time_tick() > 3000 / AKY_TICK_INTERVAL)
                {
                    //3s
                    LED_OFF;
                    three_color_control(COLOR_ALL_OFF);
                }
                
                bat_val = get_cur_bat_val_by_math();
								
//aky_disp_single_tube(bat_val / 10000, SYSHundred);	//test
//aky_disp_single_tube(bat_val / 1000 % 10, SYSTen);
//aky_disp_single_tube(bat_val / 100 % 10, SYSSingle);	
//aky_disp_single_tube(bat_val / 10, DIAHundred);
//aky_disp_single_tube(bat_val % 10, DIATen);
//delay(75);
								
                bat_cells = get_baterry_cells(bat_val);
                if (bat_cells <= 0)
                {
                    //始终从第1格开始
                    bat_cells = 1;
                }
//aky_disp_single_tube(bat_cells, PulseTen);	//test
//delay(75);
//aky_disp_single_tube(disp_I, PulseSingle);
								
#if (AKY_DEBUG_UART_PRINTF == 1)
    aky_uart_fmt_num("bat_val = ",get_cur_bat_val_by_math());
    aky_uart_fmt_num("bat_cells = ",get_baterry_cells(bat_val));
    aky_uart_fmt_num("get_cur_charge_stat = ",get_cur_charge_stat());
#endif

                if (get_cur_charge_stat() == FULL_BAT)
                {
                    //full拉低 充满显示满格
                    show_cells = 6;
                }
                else
                {
                    show_cells++;
                    if (show_cells > 6)
                    {
                        //最大格数则从当前格数重新开始跑马
                        if (bat_cells == 6)
                        {
                            //full引脚没拉低时不能算充满 不显示满格
                            show_cells = 5;
                        }
                        else
                        {
                            show_cells = bat_cells;
                        }
                    }
                }
//if(KEY_MEM == 0)
//{
//aky_disp_single_tube(bat_cells, MemorySetTen);	//test
//delay(75);
//aky_disp_single_tube(disp_empty, MemorySetTen);	//test
//}
//else if(KEY_SET == 0)
//{
//aky_disp_single_tube(bat_cells, MemorySetSingle);	//test
//delay(75);
//aky_disp_single_tube(disp_empty, MemorySetSingle);	//test
//}
                charge_mode_show_bar(show_cells);
            }
        }
        else
        {
            g_s_flag_group.flag_one_shot = 1;
        }
			}
			else if((get_cur_charge_stat() == NO_BAT_AND_USB_INPUT) || (get_cur_charge_stat() == FULL_BAT) && Show_FULL == 0)
			{
				Show_FULL = 1;
				show_cells = 6;
				charge_mode_show_bar(show_cells);	//满格
			}

      if (all_while_loop_exit() == 1)
			{
					break;
			}
			if (get_cur_charge_stat() == NO_CHARGE)
			{
					break;
			}  
			
			if (KEY_POWER == 0 || KEY_MEM == 0 || KEY_SET == 0)
			{
					break;
			}
			
		}
		
		auto_test_deinit();	//充电状态下按下MEN键和SET键进入对应模式正常使用
		
		if (KEY_POWER == 0)	//20251101充电不测量,其他按键有功能
		{
					IsPowerOn = 1;
					g_e_sys_stat = START_TEST_MODE;
			bat_flush_control(BAT_START);
			bat_flush_control(BAT_DISP);
		}
		else if (KEY_MEM == 0)
    {
        IsPowerOn = 1;
        g_e_sys_stat = MEM_MODE;
		bat_flush_control(BAT_START);
		bat_flush_control(BAT_DISP);
    }
    else if (KEY_SET == 0)
    {
        IsPowerOn = 1;
        g_e_sys_stat = SET_MODE;
		bat_flush_control(BAT_START);
		bat_flush_control(BAT_DISP);
    }	
		else if (get_cur_charge_stat() == NO_CHARGE)
    {
        IsPowerOn = 0;
        g_e_sys_stat = STOP_MODE;
    }

    aky_disp_clear_all();
    off_time_tick_clr();			
}
```


```
show_cells = bat_cells;	//确保从当前电压格数开始跑马
```


测试代码
```
//if(KEY_MEM == 0)
//{
//aky_disp_single_tube(bat_cells, MemorySetTen);	//test
//delay(75);
//aky_disp_single_tube(disp_empty, MemorySetTen);	//test
//}
//else if(KEY_SET == 0)
//{
//aky_disp_single_tube(bat_cells, MemorySetSingle);	//test
//delay(75);
//aky_disp_single_tube(disp_empty, MemorySetSingle);	//test
//}
aky_disp_single_tube(3, MemorySetTen);
```

A01 泵不工作，是引脚没焊接好
![[../../annex/19.入职第十九周11.17-11.21（双休）_image_6.png]]

#### 只插 USB （无锂电池）时不能正常工作
![[../../annex/19.入职第十九周11.17-11.21（双休）_image_7.png]]
只插 USB （无锂电池）时不能正常工作，这是由于硬件决定的，将 D 1 二极管焊上后，泵就可以工作了，但同时也无法控制泵的启停。
而其他机器可以在无锂电池时正常使用是因为有其余的外围电路设计供电使用

## AXD-303A 雾化器

### 无源蜂鸣器-电容-IO 口
![[../../annex/19.入职第十九周11.17-11.21（双休）_image_8.jpg]]

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_9.jpg]]

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_10.jpg]]
测量电容的大小，档位打到 F（20 mF ）处
![[../../annex/19.入职第十九周11.17-11.21（双休）_image_11.jpg]]



11.19。AXD-303A 雾化器，加蜂鸣器测试。
```
uint8 testi;

void main(void)
{
	static unsigned long tick_last = 0;	
#ifdef LVD_RST_ENABLE
	LVDCON = 0xE0;	//设置LVD复位电压为2.7V
#endif
#ifdef SYSCLK_16MHZ		
	CKDIV = 0;
#endif	
#ifdef UART_EN
	Uart_Initial(UART_BAUTRATE);
#endif

	
//看门狗时钟源为IRCL
	// CKCON |= ILCKE;									//使能IRCL
	// WDCON  = WDTS(WDTS_IRCL) | WDRE(WDRE_reset);   	//设置看门狗时钟源为ILCKE，模式为复位模式
	// WDVTHH = 0;										//看门狗复位阈值高八位设置 当前值为5s	
	// WDVTHL = 75;									//看门狗复位阈值低八位设置
	// WDFLG = 0xA5;	
	
	EA = 1; 	

	SysInit();
	TS_init();	
	InitLoop();
	P00 = 1;	
	WorkState = POWER_ON;
	ShowTime(WorkTime_MinuteVal);
	
	/*for(testi=0;testi<100;testi++)
	{
		P14 = 1;
		Delay_ms(1);
		P14 = 0;
		Delay_ms(1);
	}*/
	
	//P14 = 0;
	PwmEnable(5);
	while(1)
	{	
		P00 = 1;	
//		Delay_ms(1500);
//		P00 = 0;
//		P14 = 1;
		
		PwmEnable(5);
		PwmFrq(5,5);
		PwmDuty(40,5);
		
//		PwmDisable(5);
		
		/*for(testi=0;testi<5;testi++)
		{
			P14 = 1;
			//Delay_5us(100);
			Delay_ms(250);
			P14 = 0;
			//Delay_5us(10);
			Delay_ms(250);
		}*/
		
	
		/*TS_Action();
		Touch_Scanf();
		Test_show_fun();
		Faction_pro();*/
		
		
	}
}
```

11.19。AXD-303A 雾化器，定时器模拟 PWM 测试。

```
void TIMER0_ISR (void) interrupt 1			//
{
	TH0 = TH0_VAL;
	TL0 = TL0_VAL;
	
	/*t0_tick_test_us2++;
	if(t0_tick_test_us2 >400)
	{
		t0_tick_test_us2=0;
		P14 = 1;
	}
	if(t0_tick_test_us2>200)
	{
		P14 = 0;
	}*/
	
	t0_tick_test_us2++;
	t0_tick_test_1min++;
	//P03 = ~P03;
	//P04 = ~P04;
		
//	if(t0_tick_test_1min<20000)	//20251115
//	{
//		if(t0_tick_test_us2 == 1)//2
//			{
//				P03=~P03;
//				P04=~P04;
//				P14= ~P14;
//			}
//			if(t0_tick_test_us2 == 2)//3
//			{
//				t0_tick_test_us2 = 0;
//				P03=~P03;
//				P04=~P04;
//				P14= ~P14;
//			}
//	}
//	else
//	{
//		P14 = 0;
//	}

			/*if(t0_tick_test_us2%2 == 1)//2
			{
				P03=~P03;
				P04=~P04;
				P14= ~P14;
			}
			if(t0_tick_test_us2%5 == 1)//3
			{
				P03=~P03;
				P04=~P04;
				P14= ~P14;
			}*/
	
		
#endif

}
```

11.19。AXD-303A 雾化器，定时器模拟 PWM 测试。

```
void TIMER1_ISR (void) interrupt 3 		 //每1ms中断一次
{
	TH1 = TH1_VAL;
	TL1 = TL1_VAL;
	
	OsTime.T1ms_Cnt++;
	//g_u32_tick_cnt++;
	//g_u32_tick_test++;
	TimerOKFlag = 1;

	/*if(test_buz==1)
	{
		test_buz=0;
		P14 = 1;
		Delay_ms(500);
		P14 = 0;
		Delay_ms(200);
	}*/
	
	if((WorkState == POWER_ON) && (WorkGear != WorkOFF) && (WorkTime_MinuteVal != 0))
	{
		if(Time_Flag == 1)
		{
			Time_Flag = 0;
			t1_tick_test_us2 = 0;
			t1_tick_test_1s = 0;
			t1_tick_test_1min = 0;
		}
		t1_tick_test_us2++;
	}
	
	if((WorkState == POWER_ON) && (WorkGear != WorkOFF) && (WorkTime_MinuteVal != 0))
	{
		/*if(t1_tick_test_us2 >= 500)
		{
			//P00=1;
			P01=1;
			P02=1;
		}*/
		if(t1_tick_test_us2 >= 980)
		{
			t1_tick_test_us2 = 0;
			t1_tick_test_1s++;
			//P00=0;
			//P01=0;
			//P02=0;
		}
		if(t1_tick_test_1s >= 60)
		{
			t1_tick_test_1s = 0;
			t1_tick_test_1min++;
			WorkTime_MinuteVal--;
			if(WorkTime_MinuteVal == 0)
			{
				WorkGear = WorkOFF;
				//WorkState = POWER_OFF;
			}
			Ever_min_Update = 1;
		}
	}
	
}
```

AXD-303A 查看软件版本号，按键进入方式

```
void Touch_Scanf(void)
{ 
#if SUPPORT_WHEEL_SLIDER
		if(WheelSliderPosition != -1)
		{
			//当WheelSliderPosition不等于-1时， 表示滑条或圆环有触摸事件发生。WheelSliderPosition的值表示滑条或圆环的位置。
		}
#endif		
		

#if SUPPORT_KEY
/*************************************************************************************************
变量KeysFlagSN是触摸库对外的数据接口，KeysFlagSN的每一位对应一个触摸键的状态，为1表示触摸键触发。可多键同时触发。
*************************************************************************************************/
		if(KeysFlagSN != 0)
		{
			switch(KeysFlagSN)
			{
				case 0x0001:
					break;
				case 0x0002:
					break;
				//......
				default:
					break;
			}
		}
#if GENERATE_TS_KEY_EN
/*************************************************************************************************
变量TS_Key是根据KeysFlagSN得到的按键信息，以下为按键产生的过程：
|-----------------------------------------------------------------------------------------------------------------------------------|
|	单键：以K1为例，K1按键产生的流程如下所示：																																												|
|																																																																		|
|					 	|---> K1|KEY_BREAK(短按松开)																																														|
|	K1(按下)--|																																																												|
|					 	|---> K1|KEY_LONG_START(长按大约1秒)---> K1|KEY_LONG(一直长按，约每300ms产生一次长按键)---->K1|KEY_LONG_BREAK(长按松开)	|
|																								 ^																							    |																|
|																								 |																							    |																|
|																								 |----------<-----------<------------<--------------|																|
|-----------------------------------------------------------------------------------------------------------------------------------|

|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|																																																																																				|
|	复合键：以K1(K1=0x0001),K2(K2=0x0002)为例， 当K1，K2同时按下时，产生按键为(K1<<5)|K2，即0x22, 产生按键的流程如下所示：																								|
|																																																																																				|
|										|---> ((K1<<5)|K2)|KEY_BREAK(短按松开)																																																							|
|	(K1<<5)|K2(按下)--|																																																																										|
|										|---> ((K1<<5)|K2)|KEY_LONG_START(长按大约1秒)---> ((K1<<5)|K2)|KEY_LONG(一直长按，约每300ms产生长按键)---->((K1<<5)|K2)|KEY_LONG_BREAK(长按松开)		|
|																															 		 ^																							           |																					|
|																																 	 |																							           |																					|
|																															 		 |---------<-------------<----------------<----------------|																					|
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
																															 
注意：由于复合键按下时，软件不一定同时检测到双键，而是先检测到单键按下，例如先检测到K1，此时会先产生K1键，等到检测到K2也按
下时，才会产生按键(K1<<5)|K2，检测到双键后，如果双键一直按下，会产生((K1<<5)|K2)|KEY_LONG_START和((K1<<5)|K2)|KEY_LONG，如果
有一个键先松手，会停止产生按键， 等到双键都松开时，才会产生((K1<<5)|K2)|KEY_BREAK(短按松开)或((K1<<5)|K2)|KEY_LONG_BREAK(长按松开)
*************************************************************************************************/
		if(TS_Key != 0)
		{
			switch(TS_Key)
			{
				//单按键消息
				case KEY_POWER:									//K1短按产生的按键消息
					break;
				case (KEY_POWER|KEY_BREAK):      //K1短按松手产生的按键消息
					if((ViewVersionFlag[0] != 1))
					{
						SingleKey_PressFlag = 1;
					Buz_WorkFlag = 1;
					}
				 
					if((ViewVersionFlag[0] == 1) && (ViewVersionCount <= 3))
					{
						Buz_WorkFlag = 1;
						ViewVersionTick = 1;
						t1_tick_viewversion_ms = 0;						
						ViewVersionCount++;
						ViewVersionFlag[ViewVersionCount-1] = 2;
						if((ViewVersionFlag[ViewVersionCount-1] == 2) && (ViewVersionFlag[ViewVersionCount-2] == 2))
						{
							SingleKey_PressFlag = 1;
					Buz_WorkFlag = 1;
						}
//						TM1650_DisplayHalfByte(ViewVersionCount,Minute_Ten);		//use for test
//						TM1650_DisplayHalfByte(ViewVersionFlag[ViewVersionCount-1],Minute_Single);		//use for test
					}
				//P00 = ~P00;
					break;
				case (KEY_POWER|KEY_LONG_START):	//K1长按开始产生的消息（长按约1秒时产生）
					break;
				case (KEY_POWER|KEY_LONG):				//K1长按产生的消息（每隔约300ms产生一次）
					if((WorkGear == WorkOFF) && (ViewVersionCount <= 3))
					{
						Buz_WorkFlag = 2;	
						t1_tick_viewversion_ms = 0;
					}
					break;
				case (KEY_POWER|KEY_LONG_BREAK):	//K1长按松手产生的消息
						if((WorkGear == WorkOFF) && (ViewVersionCount <= 3))
						{
							Buz_WorkFlag = 3;
							ViewVersionTick = 1;
							ViewVersionCount++;
							//ViewVersionFlag[0] = 1;
							ViewVersionFlag[ViewVersionCount-1] = 1;
//							TM1650_DisplayHalfByte(ViewVersionCount-1,Minute_Ten);		//use for test
//							TM1650_DisplayHalfByte(ViewVersionFlag[ViewVersionCount-1],Minute_Single);		//use for test
						}
					break;

				case KEY_DOWN:					//K2短按产生的按键消息
					break;
				case (KEY_DOWN|KEY_BREAK):      	//K2短按松手产生的按键消息
					break;
				case (KEY_DOWN|KEY_LONG_START):	//K2长按开始产生的消息（长按约1秒时产生）
					break;
				case (KEY_DOWN|KEY_LONG):			//K2长按产生的消息（每隔约300ms产生一次）
					break;
				case (KEY_DOWN|KEY_LONG_BREAK):	//K2长按松手产生的消息
					break;

				case KEY_FUNCTION:					//K3短按产生的按键消息
					break;
				case (KEY_FUNCTION|KEY_BREAK):      	//K3短按松手产生的按键消息
					break;
				case (KEY_FUNCTION|KEY_LONG_START):	//K3长按开始产生的消息（长按约1秒时产生）
					break;
				case (KEY_FUNCTION|KEY_LONG):			//K3长按产生的消息（每隔约300ms产生一次）
					break;
				case (KEY_FUNCTION|KEY_LONG_BREAK):	//K3长按松手产生的消息
					break;

				case KEY_UP:					//K4短按产生的按键消息
					break;
				case (KEY_UP|KEY_BREAK):      	//K4短按松手产生的按键消息
					break;
				case (KEY_UP|KEY_LONG_START):	//K4长按开始产生的消息（长按约1秒时产生）
					break;
				case (KEY_UP|KEY_LONG):			//K4长按产生的消息（每隔约300ms产生一次）
					break;
				case (KEY_UP|KEY_LONG_BREAK):	//K4长按松手产生的消息
					break;

#if GENERATE_DOUBLE_KEY_EN				
	//复合键消息
				case (K1<<5)|K2:										//K1和K2同时按下时产生的按键消息
					break;
				case ((K1<<5)|K2)|KEY_BREAK:				//K1和K2短按松手产生的按键消息
					break;
				case ((K1<<5)|K2)|KEY_LONG_START:		//K1和K2长按开始产生的按键消息（长按约1秒时产生）
					break;
				case ((K1<<5)|K2)|KEY_LONG:					//K1和K2长按产生的消息（每隔约300ms产生一次）
					break;
				case ((K1<<5)|K2)|KEY_LONG_BREAK:		//K1和K2长按松手产生的消息
					break;
#endif
			}
		}

#endif
#endif
}
```

AXD-303A 查看软件版本号，定时器
```
if((ViewVersionTick == 1))
	{
		t1_tick_viewversion_ms++;
		if((t1_tick_viewversion_ms >= 2000)  && (ViewVersionCount <= 3))
		{
			t1_tick_viewversion_ms = 0;
			ViewVersionTick = 0;
			ViewVersionCount = 0;
			Buz_WorkFlag = 3;
			ViewVersionFlag[0] = 0;
			ViewVersionFlag[1] = 0;
			ViewVersionFlag[2] = 0;
			ViewVersionFlag[3] = 0;
			ViewVersionFlag[4] = 0;
		}
	}
	else
	{
		t1_tick_viewversion_ms = 0;
	}
```

AXD-303A 雾化器，定时器1的时基。
![[../../annex/19.入职第十九周11.17-11.21（双休）_image_12.png]]

## 玫丽科技 A04 加双语
玫骊 A04 LED 显示装饰圈有 LED 哈萨克语+俄罗斯语项目-BP004

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_13.jpg]]
BUSY=1/BUSY=0
![[../../annex/19.入职第十九周11.17-11.21（双休）_image_14.png]]

A04语音测试代码
```
delay(75);
aky_disp_single_tube(1, DIASingle);
spk_combine_cmd(0x55,121,80,72);
while(!BUSY);
	
delay(75);
spk_combine_cmd(0x11,0,0,0);	//哈萨克斯坦语
while(!BUSY);
delay(20);
aky_disp_single_tube(2, DIASingle);
spk_combine_cmd(0x55,121,80,72);
while(!BUSY);
	
delay(75);
spk_single_cmd(0x11);
while(!BUSY);
delay(20);
aky_disp_single_tube(3, DIASingle);
spk_combine_cmd(0x55,121,80,72);
while(!BUSY);

delay(75);
spk_combine_cmd(0x22,0,0,0);	//俄语
while(!BUSY);
delay(20);
aky_disp_single_tube(4, DIASingle);
spk_combine_cmd(0x55,121,80,72);
while(KEY_POWER);
```


```
if(g_s_func.e_spk_type == Russian_Kazakh)
		{
			if (g_s_set.flag_spk_on_off == 0)
			{
				spk_combine_cmd(0x11,0,0,0);	//哈萨克斯坦语
				
delay(75);
aky_disp_single_tube(g_s_set.flag_spk_on_off, DIASingle);
spk_combine_cmd(0x55,121,80,72);
while(!BUSY);
				
			}
			if (g_s_set.flag_spk_on_off == 1)
			{
				spk_combine_cmd(0x22,0,0,0);	//俄语
			}
		}
	while(1)
	{
		delay(10);
		aky_disp_single_tube(g_s_set.flag_spk_on_off, DIASingle);
		aky_disp_single_tube(1, DIATen);
		spk_single_cmd(0xC0);
		//spk_combine_cmd(0x55,121,80,72);
		while(!BUSY);
		
		delay(100);
		aky_disp_single_tube(g_s_set.flag_spk_on_off, DIASingle);
		aky_disp_single_tube(2, DIATen);
		spk_single_cmd(0xC0);
		//spk_combine_cmd(0x55,121,80,72);
		while(!BUSY);
		
		delay(200);
		aky_disp_single_tube(g_s_set.flag_spk_on_off, DIASingle);
		aky_disp_single_tube(3, DIATen);
		spk_single_cmd(0xC0);
		//spk_combine_cmd(0x55,121,80,72);
		while(!BUSY);
		
		delay(300);
		aky_disp_single_tube(g_s_set.flag_spk_on_off, DIASingle);
		aky_disp_single_tube(4, DIATen);
		spk_single_cmd(0xC0);
		//spk_combine_cmd(0x55,121,80,72);
		while(!BUSY);
		
		delay(500);
		aky_disp_single_tube(g_s_set.flag_spk_on_off, DIASingle);
		aky_disp_single_tube(5, DIATen);
		spk_single_cmd(0xC0);
		//spk_combine_cmd(0x55,121,80,72);
		while(!BUSY);
		
		while(KEY_POWER);
		aky_disp_single_tube(g_s_set.flag_spk_on_off, DIASingle);
		aky_disp_single_tube(6, DIATen);
		spk_single_cmd(0xC0);
		//spk_combine_cmd(0x55,121,80,72);
		while(!BUSY);
	}
//delay(75);
//aky_disp_single_tube(1, DIASingle);
//spk_combine_cmd(0x55,121,80,72);
//while(!BUSY);
//	
//delay(75);
//spk_combine_cmd(0x11,0,0,0);	//哈萨克斯坦语
//while(!BUSY);
//delay(20);
//aky_disp_single_tube(2, DIASingle);
//spk_combine_cmd(0x55,121,80,72);
//while(!BUSY);
//	
//delay(75);
//spk_single_cmd(0x11);
//while(!BUSY);
//delay(20);
//aky_disp_single_tube(3, DIASingle);
//spk_combine_cmd(0x55,121,80,72);
//while(!BUSY);

//delay(75);
//spk_combine_cmd(0x22,0,0,0);	//俄语
//while(!BUSY);
//delay(20);
//aky_disp_single_tube(4, DIASingle);
//spk_combine_cmd(0x55,121,80,72);
//while(KEY_POWER);
```

```
delay(50);
aky_disp_single_tube(1, SYSTen);
aky_disp_single_tube(g_s_set.flag_spk_on_off, SYSSingle);
delay(50);		
spk_single_cmd(0xC0);
while(!BUSY);		
		delay(50);
		spk_judge();	//语音ic上电默认为俄语,init后需要判断一下语音类型

delay(50);		
aky_disp_single_tube(2, SYSTen);
aky_disp_single_tube(g_s_set.flag_spk_on_off, SYSSingle);
delay(50);		
spk_single_cmd(0xC0);
while(!BUSY);
```

```
else if(g_s_func.e_spk_type == Russian_Kazakh)
						{
							/*code*/
aky_disp_single_tube(g_s_set.flag_spk_on_off, SYSSingle);
								if (spk_single_cmd(0xC3) == 1)// C3h 请保持安静,将臂带与心脏位置保持同高,测量开始
                {
                    if (KEY_POWER == 0)
                    {
                        goto start_test_exit;
                    }
                }
								while(KEY_POWER);
						}
```

##### A04 ，阀漏气：没焊好，引脚漏焊

##### A 01 和 A 04 无法使用自动工装

自动工装机下发的数据，正常。
![[../../annex/19.入职第十九周11.17-11.21（双休）_image_15.png]]

机器没有回复指令，大概率为配置错误
![[../../annex/19.入职第十九周11.17-11.21（双休）_image_16.jpg]]


## 天津邦邦 BB-Q5

天津邦邦 BB-Q5：换屏，点 SEG 不对。是逻辑图反了，SEG 和 COM 反了。
![[../../annex/19.入职第十九周11.17-11.21（双休）_image_17.png]]

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_18.png]]

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_19.png]]

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_20.png]]

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_21.png]]

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_22.png]]

SEG 和 COM 脚的逻辑线有误



## 培训--示波器使用


## 内存使用情况


```
xdata是一种存储器类型修饰符，用于指定变量存储在外部数据存储器中，速度比内部RAM慢
```


![[../../annex/19.入职第十九周11.17-11.21（双休）_image_23.jpg]]

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_24.png]]

![[../../annex/19.入职第十九周11.17-11.21（双休）_image_25.png]]


## keil：hex ---> bin ---> hex ---> Download
原创 sdc123 大川搬砖

 _2025年10月31日 12:00_ _北京_
https://mp.weixin.qq.com/s/CN2KDV8u24dng7xtGc7sTw

## 嵌入式中代码执行时间测量的几种方法
https://mp.weixin.qq.com/s/JBOpdcGqDypOf9Si5HfxSg

## 8位寄存器值溢出后会怎样？数据会丢失还是循环回零？
https://blog.csdn.net/qq_41882586/article/details/129539017

## PWM信号加电容mos管的巧妙方法
https://blog.csdn.net/qq_21370051/article/details/126230283

## 一文看懂PWM控制原理及电路应用详解
https://www.21ic.com/a/981000.html



























































































































































































































































