
启动电机时，一瞬间的电流可能不稳定，导致 LED 显示有时候正常，有时候错乱、不显、显示乱码等问题，加个延时就好。
中断、while 里不要放 Delay，用标志位去判断。

https://blog.csdn.net/weixin_42550185/article/details/140081709

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_1.jpg]]





##### 晶华微烧录器的使用 ：
![[../../annex/15.入职第十五周10.20-10.25(双休)_image_2.png]]





##### PCM01 宠物睡眠仪，数据定义

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_3.png]]


```
Typedef struct
{
    Uint 8 ReceiveLiveDataFlag : 2;//实时数据接收情况
    Uint 8 ReceiveMemoryOKFlag : 2;  //记忆数据接收情况
		Uint 8 ReceiveResultDataFlag : 2;	//结果数据接收情况
    Uint 8 ReceiveErrorFlag : 2; //错误代码接收情况
}BLE_Receive_flag;

Extern BLE_Receive_flag BLEReceiveFlags;

Xdata BLE_Receive_flag BLEReceiveFlags = {0,0,0,0};

#define ReceiveLiveDataFlag   	BLEReceiveFlags. ReceiveLiveDataFlag
#define ReceiveMemoryOKFlag    BLEReceiveFlags. ReceiveMemoryOKFlag
#define ReceiveResultDataFlag  BLEReceiveFlags. ReceiveResultDataFlag
#define ReceiveErrorFlag       BLEReceiveFlags. ReceiveErrorFlag

```

报错，主要问题是：
​​extern 声明应该在头文件中​​（在头文件中定义、使用 extern）
​​变量定义应该在源文件中​​
​​声明和定义的顺序很重要​


```
typedef struct
{
    uint8 ReceiveLiveDataFlag : 2;//实时数据接收情况
    uint8 ReceiveMemoryOKFlag : 2;  //记忆数据接收情况
		uint8 ReceiveResultDataFlag : 2;	//结果数据接收情况
    uint8 ReceiveErrorFlag : 2; //错误代码接收情况
}BLE_Receive_flag;

extern BLE_Receive_flag BLEReceiveFlags;

xdata BLE_Receive_flag BLEReceiveFlags = {0,0,0,0};

#define ReceiveLiveDataFlag   	BLEReceiveFlags.ReceiveLiveDataFlag
#define ReceiveMemoryOKFlag    BLEReceiveFlags.ReceiveMemoryOKFlag
#define ReceiveResultDataFlag  BLEReceiveFlags.ReceiveResultDataFlag
#define ReceiveErrorFlag       BLEReceiveFlags.ReceiveErrorFlag
```

```
// 在文档9或适当位置定义结构体
typedef struct
{
    uint8 ReceiveLiveDataFlag : 2;    // 实时数据接收标志
    uint8 ReceiveMemoryOKFlag : 2;     // 记忆数据接收确认标志  
    uint8 ReceiveResultDataFlag : 2;   // 结果数据接收标志
    uint8 ReceiveErrorFlag : 2;        // 错误接收标志
} ReceiveFlags;

// 在全局变量声明区域
xdata ReceiveFlags receiveFlags = {0, 0, 0, 0};

// 在文档12的UartHandle函数中使用
void UartHandle(void)
{
    if(ReceiveArray[0]==0xFD&&ReceiveArray[1]==0xFD&&ReceiveArray[2]==0x04&&ReceiveArray[3]==0x01&&ReceiveArray[4]==0x01) {
        if(ReceiveArray[5]==0) {
            receiveFlags.ReceiveResultDataFlag = 1;  // 接收成功
        } else {
            receiveFlags.ReceiveResultDataFlag = 2;  // 接收失败
        }
    }
}

// 在发送函数中检查标志
void SendResultData2(void)  
{
    do {
        if(receiveFlags.ReceiveResultDataFlag == 1) {
            // 处理成功情况
            break;
        } else if(receiveFlags.ReceiveResultDataFlag == 2) {
            // 处理失败情况  
            break;
        }
    } while(AutoOffTimew<=150 && KEY_POWER);
}
```


```
*** WARNING L57: UNCALLED FUNCTION, IGNORED FOR OVERLAY PROCESS
*** 警告 L57：未调用的函数，已在覆盖处理时被忽略
```

待机0.1V，等待连接2.2-2.3V，连接成功2.6V
样机供电电压       蓝牙对应电压
3.93V;                待机时0.22-0.28V,    工作时2.68V,    2.65V
3.6 V;                 待机时0.03 V;    
3.4 V;                 工作时（样机唤醒状态） 2.38 V;       
3.39 V;               工作时（样机唤醒状态） 2.32 V;
1                         工作时（样机唤醒状态） 2.69 V



##### AXD-840 E 血压计改问题点
遇到问题：
样机
样机待机 4.9 V, 电流在 30-33 uA
按下按键不唤醒（按下按键但未能唤醒机器时），电流 100 uA
按下按键成功唤醒，电流 30-50 mA (47 mA)
测量工作，泵拉低电压 0.2 V（即此时电压为 4.9 V ->4.7 V），工作电流 100 mA->200 mA（随着马达的工作，电流住家年达）
4.94 V->4.7/4.65 V，4.6 V，4.5 V,


```
电量显示的实际情况：
4.30 空框闪烁，报低电

4.38 空框

>=4.39 一格显示（4.39-4.80）

>=4.80 两格显示（4.81-5.37）

>=5.37 三格显示（5.39-）
>=5.39 三格显示

```


```
//disp_to_dia(fresh_bat_value,0,1);
	//aky_disp_num_div_5_tube(fresh_bat_value);
			//show_baterry_cells(g_s_bat_flush.bat_cells_last);
			/*aky_disp_single_tube(fresh_bat_value/10000, SYSHundred);
			aky_disp_single_tube(fresh_bat_value % 10000 / 1000, SYSTen);
			aky_disp_single_tube(fresh_bat_value % 1000 / 100, SYSSingle);
			aky_disp_single_tube(fresh_bat_value % 100 / 10, DIAHundred);
			aky_disp_single_tube(fresh_bat_value % 10 / 1, DIATen);*/
```


![[../../annex/15.入职第十五周10.20-10.25(双休)_image_4.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_5.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_6.jpg]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_7.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_8.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_9.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_10.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_11.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_12.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_13.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_14.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_15.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_16.png]]


![[../../annex/15.入职第十五周10.20-10.25(双休)_image_17.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_18.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_19.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_20.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_21.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_22.png]]


![[../../annex/15.入职第十五周10.20-10.25(双休)_image_23.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_24.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_25.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_26.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_27.png]]

![[../../annex/15.入职第十五周10.20-10.25(双休)_image_28.png]]


#####  1.编译时报错：warning C294: unreachable code

```
COMMON\aky_func.c(3821): warning C294: unreachable code
```

分析原因：检查延时代码，没有发现问题；注意到该段代码前面的 if 语句：if (P 1 & 0 x 10 == 0) ，怀疑运算优先级问题导致条件语句无法满足后继代码运行条件，查看位与运算 & 和逻辑运算 == 的优先级，发现逻辑运算 == 的优先级高于位与运算 &；而显然 0 x 10 == 0 这个条件是不成立的，因此导致后继代码无法到达。修改该条件语句为 if ((P 1 & 0 x 10) == 0) 重新编译，错误警告消失。

以上实例说明，在不明确运算优先级的情况下，应使用符号 ()明确运算的优先顺序。
————————————————
版权声明：本文为 CSDN 博主「levin 1972」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接： https://blog.csdn.net/levin1972/article/details/139976904


#####  2.编译时报错：warning C294: unreachable code
由于 return 语句会立即结束函数的执行，任何在 return 之后的代码都不会被执行，因此编译器会发出警告。

在 C 程序中，unreachable code（不可达代码）错误通常是指在逻辑上不可到达的代码段。这意味着代码的某个部分在执行时永远也不会被运行。该错误通常发生在以下几种情况下：

在 return 语句之后：
如果一个 return 语句之后还有代码，编译器会报出 unreachable code 错误，因为 return 语句会返回到调用该函数的地方，后面的代码将无法执行。

在 break、continue 或 goto 语句之后：
类似于 return，如果你在这些语句后面写了代码，编译器也会识别到这些代码是不可达的。

条件永远不为真的 if 语句：
如果你的 if 语句条件逻辑确保了某些代码块永远不会被执行，编译器可能会向你发出 unreachable code 的警告。

逻辑错误或变量总是为特定值的情况下的代码执行：
如果你有些逻辑判断确保代码块不会被执行，例如，变量总是为 NULL 或总是满足某个条件。

解决方法
去掉无用代码：
检查那些被识别为不可达的代码，并根据需要去除。例如，如果某段代码在 return 之后，可以直接删除。

调整逻辑：
如果你发现某段逻辑导致了无可达代码，考虑重构你的条件表达式或代码结构。

注释或删除：
如果你在测试阶段写了一些调试代码，结果被标记为不可达，确认是否依然需要这些代码。如果不需要，可以直接删除或注释掉。
————————————————
版权声明：本文为 CSDN 博主「huiyuanzhenduo」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接： https://blog.csdn.net/huiyuanzhenduo/article/details/145299742


马林发现加上宏定义 SEG【】后，程序会出现 CAL 模式校准失败的情况（若未宏定义则正常），据说是因为内存满了，需要删改代码。

##### 51 单片机初始 128 B 为高速传输
51 单片机有128 个字节为高速传输，栈通常就在该区域




























































































