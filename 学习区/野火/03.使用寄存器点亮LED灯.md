
## P 9 初步入门（直接操作内存点亮 LED）
以绝对的地址（内存）操作，还未用到寄存器
![[../../annex/使用寄存器点亮LED灯_image_1.png]]

红绿蓝三种颜色，可以混合起来有 255 种颜色
![[../../annex/使用寄存器点亮LED灯_image_2.png]]

32 位，但是高 16 位是无效的，只有低 16 位有效。低 16 位每一个位对应的是一个 io 端口的每一位。
pb0到7是低寄存器，pb8到15是高。
![[../../annex/使用寄存器点亮LED灯_image_3.png]]


```
在Edit中的configuration的testcompletion中的Dynamic Syntax Checking，Enable关掉
↑ 关闭程序中的×，C语言中的语法动态检查报错
```

![[../../annex/使用寄存器点亮LED灯_image_4.png]]
点击 load 按钮，灯不亮。

PB 0 的 io 口可以配置成输入和输出。默认由端口配置低寄存器（控制低 8 位）。
![[../../annex/使用寄存器点亮LED灯_image_5.png]]

后面四个位控制 1 个 io 口
![[../../annex/使用寄存器点亮LED灯_image_6.png]]

复位值都是 0。默认复位中是输入的。我们要配置成输出。
![[../../annex/使用寄存器点亮LED灯_image_7.png]]

输出有好几个模式。如果要驱动 LED，一般用推挽输出模式。通用推挽输出模式是 00
![[../../annex/使用寄存器点亮LED灯_image_8.png]]
![[../../annex/使用寄存器点亮LED灯_image_9.png]]


要在 MODE 模式这个位大于等于 0 的情况下，就是在下面随便选一个。输出的时候还要配置速度，配置成 10 M，配置成 01。
![[../../annex/使用寄存器点亮LED灯_image_10.png]]
![[../../annex/使用寄存器点亮LED灯_image_11.png]]
![[../../annex/使用寄存器点亮LED灯_image_12.png]]
![[../../annex/使用寄存器点亮LED灯_image_13.png]]
那么我们可以配置端口，配置低寄存器低四位为 0001，其他位不改变。
每四个位控制一个 GPIO。
我们是以 4 个位为一个组合。4x0是因为那个寄存器四位一组，控制8个 IO（32/4=8）

**先写 MODE【1：0】，再选 CNF0【1：0】**
MODE 大于 0 的情况下，CNF0 是在输出模式下选择一个
MODE 等于 0 的情况下，CNF0 是在输入模式下选择一个。
如：我们要选择输出低电平，所以 MODE 选择 01：输出模式，最大速度 10 MHZ. 然后，因为 MODE 选择了 01，二进制01=1>0，所以 CNF0 在输出模式中选一个，选通用推挽模式，则选 00. 所以 4321 位的二进制数为 0001.

```
左移多少位呢？我们是以 4 个位为一个组合，且是 PB0，所以（4*0）。如果是1的话就是（4*1），则左移4位。
4x0是因为那个寄存器四位一组，控制8个IO（32/4=8）
```

```
//0001就是1，所以（1）。
```

如果是 1，则左移 4 位，从 4567 开始配置。
```
4*1等于4，即左移4位，第四位为1，对应PB1的第一位。
4x0是因为那个寄存器四位一组，控制8个IO（32/4=8）
当写很多相同操作的时候，有的是要移动8位，就写成4*2。
```
![[../../annex/使用寄存器点亮LED灯_image_14.png]]
![[../../annex/使用寄存器点亮LED灯_image_15.png]]


左边是驱动单元，相当于是 CPU。
右边是芯片厂商 ST 设计的外设。
外设挂载在两条总线 APB 1、APB 2上。
为了降低对外设的功耗，复位的情况下, 每个外设（如 GPIO）的端口的时钟都是关闭的。
时钟就相当于心脏，没有时钟就不会工作。
时钟由 RCC 这个外设控制，RCC 挂载在 AHB 系统总线上。

![[../../annex/使用寄存器点亮LED灯_image_16.png]]

需要把这个位制 1
![[../../annex/使用寄存器点亮LED灯_image_17.png]]

或上 3 位。把位 3 制 1
![[../../annex/使用寄存器点亮LED灯_image_18.png]]

###### 代码
```c
//一个程序不能有两个main函数，通过条件编译宏
#if 0	//跟C语言中的if else是一样的，但是这个是宏，通过条件编译宏。在编译的时候如果说if 0，则到endif的内容不进行编译
#include <reg52.h>
//把具有特殊功能的内存取别名的过程就是寄存器映射。sfr P0 = 0x80;用sfr关键字给地址内存取地址P0

sbit LED = P0^0;	//字节操作

void main(void)//返回值类型为空，即表示函数执行完没有返回值；括号中的void表示形参为空
{
	P0=0xFE;//P0有8个端口，其他端口配置成1，最后一个端口配置成0。即0xFE	//总线操作
	LED = 0;//位操作
}

#endif

#include "stm32f10x.h"	//里面是各种寄存器的映射。/* 用于存放寄存器映射的代码，相当于51单片机中的 reg52.h这个头文件 */


int main(void)
{
	//0x40010C0C &= ~(1<<0);	//要写0，&	//GPIOA_ODR地址偏移为0Ch（h表示十六进制）;0CH代表十六进制0x000c
	//main.c(20): error:  #137: expression must be a modifiable lvalue。 即左值0x40010C0C必须是一个能够修改的。0x40010C0C在我们看来是一个地址，但是对于编译器而言，这是一个立即数。
	//如果要编译器看作是一个地址，要进行强制的数据类型转换
	//*( unsigned int * )0x40010C0C &= ~(1<<0);//这个地址是32位的，所以用unsigned int类型。指针作为左值，对指针进行指针操作
	
	//三步：1.打开外设的时钟 -> 2.控制GPIO端口，配置输入/输出 -> 3.再往ODR寄存器中写0还是1，输出对应的高电平还是低电平
	
	//1.打开GPIOB端口的时钟。
	*( unsigned int * )0x40021018 |= ( (1) << 3 );
	
	//2.配置IO口为输出（控制 CRL 寄存器）
	*( unsigned int * )0x40010C00 |= ( (1) << (4*0) );	//地址偏移为0，改为0x40010C00，跟起始地址一样。//是|=（或上等于）	，是制1操作，而不是清零
	//左移多少位呢？我们是以 4 个位为一个组合，4*是因为4位设定一个引脚的模式，第二个引脚就可以写成4*2了；且是PB0，所以（4*0）。4x0是因为那个寄存器四位一组，控制8个IO（32/4=8）
	//如果是1的话就是（4*1），则左移4位。4*1等于4，即左移4位，第四位为1，对应PB1的第一位。当写很多相同操作的时候，有的是要移动8位，就写成4*2
	//0001就是1，所以（1）。
	
	//3.控制 ODR 寄存器
	*( unsigned int * )0x40010C0C &= ~(1<<0);
}

//置位	|=	，清0	&=~				//只改变了我们的目标状态位，其他位不变。

//*( unsigned int * )0x40010C0C &= 0;//如果这么写，有什么不好的？ 你会把前面另外的15的位置都清零了。
//*( unsigned int * )0x40010C0C &= 1);//同样，如果这样写，剩下的位也是0

//*( unsigned int * )0x40010C0C &= ~(1<<0);//1左移0位，相当于还是0位为1。然后取反，则0位为0，其他位为1。这种做法就只改变了我们的目标状态位，其他位不变。
//再进行&与操作，我们知道，任何数跟1相&，值是不变的。任何数跟0相&，都会被清零
//逻辑与&：1为真，0为假，两数相与，一假则假，同真则真。//当位上数字是1时1&0=0，发生变化变成0了。


void SystemInit(void)//SystemInit会把我们的系统时钟的配置成72M。现在函数体为空，那么会把我们的系统时钟配置成多少兆呢？
//stm32芯片有一个机制：当你外部没有配置系统时钟的时候，或者外部晶振出现故障的时候，它会使用它内部的晶振（HSI）=8M。它会用作8M来用作系统时钟来驱动外设工作。
{
 //函数体为空，目的是为了骗过编译器不报错
}


```

```
进行|=（置1）运算和&=~（清零）运算时。
是将原有的位与（1<<n）相运算。（寄存器从0开始，左移3即是第四位）

按位或运算符（|）
	运算规则：0|0=0；  0|1=1；  1|0=1；   1|1=1；
	即：有1为1，全0为0--参加运算的两个对象只要有一个为1，其值为1。
按位与运算符（&）
	运算规则：0&0=0;  0&1=0;   1&0=0;    1&1=1;
	即：全1为1，否则为0--两位同时为“1”，结果才为“1”，否则为0

如：原本是 01001 00001
	1、要置1(1<<3)则是：
	01001 00001 | 00000 01000 = 01001 01001
	2、要清零：
	01001 00001 取反后为 10110 11110
	01001 00001 & 10110 11110 = 00000 00000
```


## P 10 GPIO 功能框图讲解

操作 GPIO，GPIO 中的电路是什么样子的？
操作寄存器，对应电路中的哪一部分？

### GPIO 简介

![[../../annex/使用寄存器点亮LED灯_image_19.png]]

GPIO：general purpose intput output
是通用输入输出端口的简称，简单来说就是软件可控制的引脚，STM 32 芯片的 GPIO 引脚与外部设备连接起来，从而实现与外部通讯、控制以及数据采集的功能。
（GPIO 通用输入输出端口，即软件控制输入输出的端口）

![[../../annex/使用寄存器点亮LED灯_image_20.png]]

1、GPIO 和引脚的区别
GPIO 包含在引脚里面，这些引脚是有特殊功能的，与 GPIO 不一样。比如电源 VCC，它只能供电，不能说是输入/输出、不能用来控制其他的外部设备

2、每一个 GPIO 的功能是什么？
如 PE 2，可以当做普通的输入/输出。还有其他的功能，那么其他功能是什么？怎么找？

![[../../annex/使用寄存器点亮LED灯_image_21.png]]
通过搜索 pin definitions 来确定所需功能的对应引脚

![[../../annex/使用寄存器点亮LED灯_image_22.png]]


### GPIO 框图讲解

![[../../annex/使用寄存器点亮LED灯_image_23.png]]

#### 芯片外部电路（1）
右边是我们能看到的引脚，就是芯片外部的引脚，用来连接外部电路的。

![[../../annex/使用寄存器点亮LED灯_image_24.png]]

往左是看不到的芯片内部
![[../../annex/使用寄存器点亮LED灯_image_25.png]]

如果输入的电压高于 3.3 v，电流就会往上流，上面的二极管打通，流不到芯片的内部。
![[../../annex/使用寄存器点亮LED灯_image_26.png]]

但是也有极限，如果大于 VDD 很多的话，二极管就可能会被烧坏，电源就进入了芯片内部，严重的情况会把整个芯片都烧毁
![[../../annex/使用寄存器点亮LED灯_image_27.png]]
如 IO 直接接电机的时候，电机启动时会有反向电动势，反向电动势有时会有过充。即电压很高，积分时间过短。二极管可能还没起到这种开关的作用
![[../../annex/使用寄存器点亮LED灯_image_28.png]]

![[../../annex/使用寄存器点亮LED灯_image_29.png]]
过充电压很尖、很高、很快的直接进入芯片内部，直接烧毁。

又如：电机启动的时候，它的反向电流也很大，反向电动势也很大，往往这个两个保护二极管它起不了作用。此时大概率烧毁芯片。
![[../../annex/使用寄存器点亮LED灯_image_30.png]]

如果想直接接电机，要经过一个驱动电路，进行隔离
![[../../annex/使用寄存器点亮LED灯_image_31.png]]


如果是负电压，比 VSS 低的话，则电流往外边流，也会起到保护电路的作用。超过 VSS 的话
![[../../annex/使用寄存器点亮LED灯_image_32.png]]

#### 芯片内部电路--上下部分，输出

##### 推挽输出（2）
![[../../annex/使用寄存器点亮LED灯_image_33.png]]

![[../../annex/使用寄存器点亮LED灯_image_34.png]]

我们输出 0 或1 的时候，是通过操作数据寄存器（ODR），
![[../../annex/使用寄存器点亮LED灯_image_35.png]]
然后经过这个输入控制，这个 0 或 1 是属于高低电平
![[../../annex/使用寄存器点亮LED灯_image_36.png]]
然后控制这两个 mos 管来工作，
![[../../annex/使用寄存器点亮LED灯_image_37.png]]
然后通过外部的 GPIO 输出 3.3 v 或者是 0 v
![[../../annex/使用寄存器点亮LED灯_image_38.png]]

![[../../annex/使用寄存器点亮LED灯_image_39.png]]
输出驱动器简化图↓↓
![[../../annex/使用寄存器点亮LED灯_image_40.png]]

###### ODR 寄存器输出 1 时
ODR 寄存器输出 1 或者 0。
比如输出 1 的时候，然后经过反向器。
然后 1 经过反向变成0。0 的话，上面的 mos 管导通。P 管 PMOS。当积极的电压小于上面的 Us 的时候，那么 PMOS 导通。
![[../../annex/使用寄存器点亮LED灯_image_41.png]]
那么 V OUT 的电压与 VDD 的电压相等，那么对外输出 3.3 v
![[../../annex/使用寄存器点亮LED灯_image_42.png]]

上面的 P 管是导通，而下面的 N 管是截止。
![[../../annex/使用寄存器点亮LED灯_image_43.png]]

###### ODR 寄存器输出 0 时

![[../../annex/使用寄存器点亮LED灯_image_44.png]]

上面 Ug 和 Us 相等，上面是关闭。
下面 Ug 大于 Us，那么下面导通 V out 通过 N 管拉到地，对外输出 0。

推挽输出，推的时候对外输出（1），就好像 VDD 给外面的这个外设或者负载在灌电流。所以该电流叫灌电流
挽的时候（0），叫拉电流。
MOS 管的内阻非常小，所以推挽的时候对外输出的电流是比较大，可以达到 25 mA。所以可以直接点亮 LED 灯

##### 开漏输出（与推挽输出相对）（2）

![[../../annex/使用寄存器点亮LED灯_image_45.png]]

开漏输出，只能输出低电平，不能输出高电平。
开漏的时候，上面的 P 管不工作，只有下面的 N 管工作。、

###### ODR 输出 1 时
![[../../annex/使用寄存器点亮LED灯_image_46.png]]
V OUT 悬空高阻态。  弹幕：高阻态可以理解为断路
此时想让它输入高电平的话，我们需要外加一个上拉电阻。
通过 VDD 把电阻上拉。然后 V OUT 就等于 VDD 了，然后再输出 1。
弹幕：电阻无穷大，分了所有的电压，所以输出等于电源电压
![[../../annex/使用寄存器点亮LED灯_image_47.png]]

###### ODR 输出 0 时

![[../../annex/使用寄存器点亮LED灯_image_48.png]]
Vg 大于 Vs，导通。那么 V OUT 就会被拉低，对外输出低电平。
![[../../annex/使用寄存器点亮LED灯_image_49.png]]

这低电平是由内部电路提供的，高电平只能由外部电路提供。、
这个外部电路只能通过上拉电阻，接到电源里面，对外输出高电平。
![[../../annex/使用寄存器点亮LED灯_image_50.png]]

如果 STM 32 要驱动 5 V 的传感器，电平要匹配，那么输入高电平的时候也要 5 V，这时只需将 VDD 改成 5 V 即可。它一般用在 IIC 或 SM BUS 这种总线上
![[../../annex/使用寄存器点亮LED灯_image_51.png]]

##### 总结
什么叫推挽输出？
1、可以输出高低电平，用于连续数字器件，高电平由 VDD （系统一般是 3.3 V）决定，低电平由 VSS 决定。
2、推挽结构指两个三极管（用的最高的是 MOS 管）受两路互补的信号控制，总是在一个导通的时候另一个截止，优点开关效率效率高，电流大（电流大是因为 MOS 管的内阻小），驱动能力强。
3、输出高电平时，电流输出到负载，叫灌电流，可以理解成推。输出低电平时，负载电流流向芯片，叫拉电流，即挽。

什么叫开漏输出？
1、只能输出低电平，不能输出高电平。
2、如果要输出高电平，则需要外接上拉。
3、开漏输出具有"线与"功能，一个为低，全部为低，多用于 I2C 和 SMBUS 总线。

##### 输出数据寄存器（3）

###### 端口输出寄存器（GPIO_ODR）
![[../../annex/使用寄存器点亮LED灯_image_52.png]]

对应手册的 ODR（output data register），有 32 位，但是只有低 16 位有效。对应外部 GPIO 的 16 个引脚。
往里面写 1 就输出高电平，写 0 输出低电平。
![[../../annex/使用寄存器点亮LED灯_image_53.png]]

![[../../annex/使用寄存器点亮LED灯_image_54.png]]

###### 端口位设置/清除寄存器 （GPIO_BSRR）（Bit set reset register）

![[../../annex/使用寄存器点亮LED灯_image_55.png]]
低 16 位控制 set（置位），写 1 有效，写 0 无效。
如果想让 GPIO 的位 0 输出高电平，就往这个位当中写 1。

高 16 位对应的是 reset，也叫清零。
如果想让将位 0 清零的话，那么往这个位写 1

![[../../annex/使用寄存器点亮LED灯_image_56.png]]
如果同时在高 16 位的位 0 和低 16 位的位 0 写 1，置位(BSy)有效。
所以对外输出高电平，影响到的就是 ODR 寄存器
![[../../annex/使用寄存器点亮LED灯_image_57.png]]


###### 端口位清除寄存器 （GPIO_BRR）
![[../../annex/使用寄存器点亮LED灯_image_58.png]]
只有低 16 位有效，
端口位清除寄存器 （GPIO_BRR）的低 16 位相当于端口位设置/清除寄存器（GPIO_BSRR）的高 16 位。

##### 复用功能输出（4）

![[../../annex/使用寄存器点亮LED灯_image_59.png]]

复用功能输出就是来自片上的外设，此时输出数据寄存器就不用了。
![[../../annex/使用寄存器点亮LED灯_image_60.png]]

###### 数据寄存器（USART_DR）

![[../../annex/使用寄存器点亮LED灯_image_61.png]]
串口的外设把数据放到这个寄存器

![[../../annex/使用寄存器点亮LED灯_image_62.png]]
然后输出 0/1 到我们外部引脚

#### 芯片内部电路--上半部分，输入

##### 输入数据寄存器（GPIO_IDR）
输入数据寄存器（GPIO_IDR）（input data register）
![[../../annex/使用寄存器点亮LED灯_image_63.png]]
输出数据寄存器，与 ODR 是相对应的。
也是有 32 位，但是只有低 16 位有效。
![[../../annex/使用寄存器点亮LED灯_image_64.png]]
如果位 0 写入 0，则表示外部的引脚输入的是 0。
如果是 1，表示读的是高电平。
而且当输出数据寄存器（ODR，3）配置成输出的时候（往里面写 1 的时候），这个 1 可以从输入数据寄存器（IDR，4） 里面读取到。可以监控。

##### TTL 肖特基触发器（施密特触发器）

![[../../annex/使用寄存器点亮LED灯_image_65.png]]

外部的数字电平进来后（高电平 3.3 v），但是读取到 IDR 寄存器的时候（它只能是 0 或 1）。
此时，肖特基触发器就起到一个媒介的作用。

###### 普通的输入 ：
一般 TTL 电平高于 2.8 v 的时候，就把它变成 1。（输出为 2 v 的时候，肖特基触发器就认为是高电平，然后往 IDR 寄存器里面相应的位写 1）
TTL 电平小于 1.2 v 的时候，TTL 就认为是低电平，往 IDR 寄存里面相应的位写 0。

![[../../annex/使用寄存器点亮LED灯_image_66.png]]

![[../../annex/使用寄存器点亮LED灯_image_67.png]]

###### 复用功能的输入
如果是复用功能的输入，就不进入 IDR 寄存器了，而是通过线路进入内部的复用功能输入（这条外设）
![[../../annex/使用寄存器点亮LED灯_image_68.png]]

数字信号时：
如串口，RX ，A 10。此时进入到串口外设的 DR 数据寄存器。（复用功能输入那一条）
![[../../annex/使用寄存器点亮LED灯_image_69.png]]

如果是 ADC 采集时：
经过 TTL 时就不经过该触发器了，因为 3.3 b、2.5 v 都是模拟信号，都要体现到内部 ADC 上，被它采集（模拟输入这条）
![[../../annex/使用寄存器点亮LED灯_image_70.png]]

相对于模拟输入，也有模拟输出，也是不经过推挽、开漏或关闭模块电路控制。而是直接输出
![[../../annex/使用寄存器点亮LED灯_image_71.png]]

![[../../annex/使用寄存器点亮LED灯_image_72.png]]


##### 端口配置低寄存器（GPIO_CRL）
配置上拉/下拉输入的时候，只与 CRL 寄存器的对应位的 1/0 ，具体是上拉还是下拉，是通过配置 BSRR 寄存器来设置的。
![[../../annex/使用寄存器点亮LED灯_image_73.png]]
在读取外部数字电频的时候，比如说读取 3.3 V，或者是 0 V。

在输入的时候，可以配置成上拉输入/下拉输入
![[../../annex/使用寄存器点亮LED灯_image_74.png]]
这个配置对应端口配置低寄存器（GPIO_CRL）
![[../../annex/tmp1699103787744_使用寄存器点亮LED灯_image_68.png]]
可以配置成上拉/下拉输入。
但是从寄存器配置上来看，只有 1 个位（1/0），到底是上拉还是下拉输入，从源码上控制。

当配置成上拉输入的时候，通过软件配置，就往位设置（BSRR）当中写 1。如果配置成下拉输入，就往位清除（BSRR）当中写 1。
上拉由 BSRR 的低16位控制，下拉由 BSRR 的高16位控制。

#### GPIO 的初始化顺序
1、选定具体的 GPIO
2、配置 GPIO 的工作模式（CRL 和 CRH 寄存器）--输入还是输出？推挽？开漏？复用？
3、控制 GPIO 输出高低电平（ODR、BRR 和 BSRR）

如上节课的点亮 LED，选择 GPIO 0，那么配置 CRL 寄存器的时候，就只能配置低 4 位。GPIO 1 的话只能配置 4~7 位。
所以选定具体哪个 GPIO 口，影响的是我们要配置的寄存器的哪些位。

## P 11 寄存器映射代码讲解
以寄存器操作。把绝对的内存地址再取个名字叫寄存器别名。

以绝对的地址（内存）去操作的话，如果不去手册中查看地址对应哪个寄存器的话是不知道代码的作用的.
可读性较差。
```
*(unsigned int *)0x40010C00 |= ((1)<<(4*0));
```

![[../../annex/使用寄存器点亮LED灯_image_75.png]]
AHB 系统总线是高速的。
里面有个叫 RCC 的外设，它是控制单片机的复位和时钟。
然后通过两条线桥接出来，一条是 APB 1，一条是 APB 2。
外设挂载在 APB1和 APB2上，AHB 挂在了时钟
在实现单片机外设的寄存器映射时，先定好三条总线的基地址。

###### 代码
```main.c


//一个程序不能有两个main函数，通过条件编译宏
#if 0	//跟C语言中的if else是一样的，但是这个是宏，通过条件编译宏。在编译的时候如果说if 0，则到endif的内容不进行编译
#include <reg52.h>
//把具有特殊功能的内存取别名的过程就是寄存器映射。sfr P0 = 0x80;用sfr关键字给地址内存取地址P0

sbit LED = P0^0;	

void main(void)
{
	P0=0xFE;
	LED = 0;

#endif

#include "stm32f10x.h"	//里面是各种寄存器的映射。/* 用于存放寄存器映射的代码，相当于51单片机中的 reg52.h这个头文件 */


int main(void)
{
#if 0	//屏蔽该段代码
	//三步：1.打开外设的时钟 -> 2.控制GPIO端口，配置输入/输出 -> 3.再往ODR寄存器中写0还是1，输出对应的高电平还是低电平
	
	//1.打开GPIOB端口的时钟。
	*( unsigned int * )0x40021018 |= ( (1) << 3 );
	
	//2.配置IO口为输出（控制 CRL 寄存器）
	*( unsigned int * )0x40010C00 &= ~( (0x0f) << (4*0) );	
	*( unsigned int * )0x40010C00 |= ( (1) << (4*0) );	//地址偏移为0，改为0x40010C00，跟起始地址一样。//是|=（或上等于）	，是制1操作，而不是清零
	//左移多少位呢？我们是以 4 个位为一个组合，4*是因为4位设定一个引脚的模式，第二个引脚就可以写成4*2了；且是PB0，所以（4*0）。4x0是因为那个寄存器四位一组，控制8个IO（32/4=8）
	//如果是1的话就是（4*1），则左移4位。4*1等于4，即左移4位，第四位为1，对应PB1的第一位。当写很多相同操作的时候，有的是要移动8位，就写成4*2
	//0001就是1，所以（1）。
	
	//3.控制 ODR 寄存器
	*( unsigned int * )0x40010C0C &= ~(1<<0);
#else
		//1.打开GPIOB端口的时钟。
	RCC_APB2ENR |= ( (1) << 3 );
	
	//2.配置IO口为输出（控制 CRL 寄存器）
	GPIOB_CRL &= ~( (0x0f) << (4*0) );//先清零
	GPIOB_CRL |= ( (1) << (4*0) );
	
	//3.控制 ODR 寄存器
	GPIOB_ODR &= ~(1<<0);
	//GPIOB_ODR |= (1<<0);
#endif
}

//置位	|=	，清0	&=~				//只改变了我们的目标状态位，其他位不变。


void SystemInit(void)
{
 //函数体为空，目的是为了骗过编译器不报错
}


```


```stm32f10x.h
/* 用于存放寄存器映射的代码，相当于51单片机中的 reg52.h这个头文件 */

// 外设 peripheral

//按住Shift+End选中,按住Shift+Delete删除
//然后Shift+Insert就是插入刚才的内容.

#define PERIPH_BASE			 		((unsigned int)0x40000000)	//设置外设的基地址
#define APB1PERIPH_BASE	 		PERIPH_BASE	//设置APB1的基地址
#define APB2PERIPH_BASE	 		(PERIPH_BASE + 0x10000)	//设置APB2的基地址
#define AHBPERIPH_BASE	 		(PERIPH_BASE + 0x20000)	//设置AHB的基地址

#define RCC_BASE						(AHBPERIPH_BASE + 0x1000)
#define GPIOB_BASE					(APB2PERIPH_BASE + 0x0C00)

#define RCC_APB2ENR					*(unsigned int*)(RCC_BASE + 0x18)//在编译器看来，它只是一个立即数，我们需要把它强制类型转换成指针

//*RCC_APB2ENR = 0XFEDD;
//*在类型变量前面表示取内容，同样位置&才代表取地址
//定义成*地址后是可以直接写入内容的，前面的这么定义的话没有意义
/*因为这几个是我们要进行操作的，要改变这个地址里存放的数值的（如输出数据寄存器 我们可以用高低电平01来点灯），
而前面几个都是基地址，我们不需要操作他们*/
/*前面几个只是单纯的数值加减，因为总线基址不需要你调用访问，要调用的是后面的寄存器，
所以总线的基址加减为了方便不需要用指针，寄存器需要访问才需要指针*/

#define GPIOB_CRL						*(unsigned int*)(GPIOB_BASE + 0x00)
#define GPIOB_CRH						*(unsigned int*)(GPIOB_BASE + 0x04)
#define GPIOB_ODR						*(unsigned int*)(GPIOB_BASE + 0x0C)

```




































































