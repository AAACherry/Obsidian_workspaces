
#### 寄存器的初步认识
无论学哪一款单片机，写的程序最终都是操作寄存器的。

##### 什么是寄存器？
1、什么是储存器映射？
存储器本身不具有地址信息，它的地址是由芯片厂商或用户分配，给存储器分配地址的过程就称为存储器映射。
2、什么是寄存器映射？
给存储器分配地址的过程就称为存储器映射。
#####  辨认正方向
![[../../annex/寄存器_image_1.png]]


![[../../annex/寄存器_image_2.png]]

![[../../annex/寄存器_image_3.png]]

![[../../annex/寄存器_image_4.png]]
小圆点，表示正方向的起始部分。正方向在这个小圆点的基础上，逆时针旋转
如果有两个圆点，一般看比较小的那个点。
还有一种方法就是正看丝印。如果有小圆点以小圆点为优先来判断方向。
如果没有小圆点，一般是正看丝印的左边的为第一个引脚，然后逆时针方向排列
![[../../annex/寄存器_image_5.png]]

##### 寄存器的结构
![[../../annex/寄存器_image_6.png]]

![[../../annex/寄存器_image_7.png]]

![[../../annex/寄存器_image_8.png]]

##### 寄存器地址
![[../../annex/寄存器_image_9.png]]

![[../../annex/寄存器_image_10.png]]

![[../../annex/寄存器_image_11.png]]
4 G 的内存，分为八块。从 block 0 到 block 7，每个块有 512 M，第一块只能设计 flash，将 flash 放在该地址空间当中。
其实所有外设都放在一块线性的存储器里面的。
块 1--flash
块 2--SRAM
块 3、块 4--FSMC
块 5--FSMC 的寄存器
块 6--没有使用
![[../../annex/寄存器_image_12.png]]
![[../../annex/寄存器_image_13.png]]
![[../../annex/寄存器_image_14.png]]
![[../../annex/寄存器_image_15.png]]

##### 地址访问内存单元
![[../../annex/寄存器_image_16.png]]

![[../../annex/寄存器_image_17.png]]

##### 寄存器和存储器映射的概念
![[../../annex/寄存器_image_18.png]]

#### STM 32 寄存器映射
##### 基地址、偏移
所有外设存在于一个内存块上，这个内存块是 32 GB。
特色外设放在 block 2 当中，block 2 当中又按照一定的顺序放了各种各样的外设。各种外设对应有相应的内存的地址。
外设的速度是不一样的，根据速度不一样，又分成了三条总线（APB1、APB2、AHB）。
其中 APB2 和 AHB 是高速的，APB1 是低速的。
开始是 APB1 的总线，然后接着是 APB2，AHB。
所有外设根据速度的不同，挂载在这三条总线上，具体哪条总线挂载什么外设看手册。
GPIO 挂载在 APB2 总线上。

![[../../annex/寄存器_image_19.png]]

![[../../annex/寄存器_image_20.png]]
![[../../annex/寄存器_image_21.png]]

![[../../annex/寄存器_image_22.png]]

![[../../annex/寄存器_image_23.png]]

![[../../annex/寄存器_image_24.png]]

32位单片机内存寻址范围是2^32 = 4GB，而每个内存地址对应的内存空间是8bit，单片机每次读32bit，所以4 X8 = 32 ，所以寄存器偏移地址才会以4位往上递增。
stm32 一个寄存器32位，而地址的基本单元是一字节，8比特，所以一个寄存器占4个比特，4个内存单元，这就是为什么移动一个寄存器地址加4的原因

##### GPIO -ODR 描述
![[../../annex/寄存器_image_25.png]]
![[../../annex/寄存器_image_26.png]]
r=read，可读。w=write，可写。 r/w，可读可写。
位说明，具体的功能是往里面写 0 或写 1 的时候会出现什么样的结果。

#### C 语言对寄存器的封装
![[../../annex/寄存器_image_27.png]]

##### 宏定义基地址
![[../../annex/寄存器_image_28.png]]
51 单片机是通过 sfr 和 sbit 关键字、具体的内存单元地址、寄存器别名对应起来。

我们先定义总线，总线和外设基址宏定义
![[../../annex/寄存器_image_29.png]]

![[../../annex/寄存器_image_30.png]]
三条总线的基地址已经定义好了。先宏定义 APB 1 的地址。然后 APB 2 和 AHB 的地址在 APB 1 的基础上加上地址偏移量。

然后再在每条总线的基地址之上加上外设的偏移地址。就可以得到外设的基地址
![[../../annex/寄存器_image_31.png]]

![[../../annex/寄存器_image_32.png]]

##### 如何实现 PB 0输出高低电平
![[../../annex/寄存器_image_33.png]]

![[../../annex/寄存器_image_34.png]]
如果是 GPIOB_ODR=0, 则所有的（16 位）都为 0，
如果想要只有一位为 0，则 GPIOB_ODP=（1<<0）。一左移零位
	1<<0准确的说是先把1转化成二进制，然后左移0位。等于只转换成了二进制
![[../../annex/寄存器_image_35.png]]
1 左移 10 位↑

如果不想要重置（只有一位为 1，其余为 0），则：
GPIOB_ODP |=（1<<0）。在等号前面加上|（或）。或|相当于加（+）
c 语言中，1为真，0为加，而逻辑运算或是二者其中之一为真就为真，所以1或0为1
![[../../annex/寄存器_image_36.png]]
清零：GPIOB_ODP &=~（1<<0）。（~是取反）
![[../../annex/寄存器_image_37.png]]

##### 结构体封装寄存器
![[../../annex/寄存器_image_38.png]]寄存器的地址是连续且间隔都为 4 个字节的，所以我们可以定义一个结构体，把端口的基地址赋值给这个结构体。结构体中定义 unsigned int + 各寄存器名称（32 位），然后可以通过这个结构体访问它的成员的方式来访问寄存器。
![[../../annex/寄存器_image_39.png]]


![[../../annex/寄存器_image_40.png]]

##### 结构体指针访问寄存器
![[../../annex/寄存器_image_41.png]]

![[../../annex/寄存器_image_42.png]]

![[../../annex/寄存器_image_43.png]]












