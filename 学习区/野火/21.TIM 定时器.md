
## P 101  TIM-基本定时器-功能框图讲解

##### 定时器简介
定时器功能	：定时、输出比较、输入捕获、互补输出
定时器分类	：基本定时器、通用定时器、高级定时器
定时器资源	：F 103 系列有 2 个高级定时器 TIM 1 和 TIM 8、4 个通用定时器 TIM 2/3/4/5、2 个基本定时器 TIM 6 和 TIM7

输出比较：最常用的是外部 GPIO 输出 PWM 信号
输入捕获：可以测量一个信号的脉冲宽度/它的频率

##### 定时器分类

![[../../annex/21.TIM 定时器_image_1.png]]

##### 基本定时器功能框图讲解
###### 基本定时器功能简介
1-计数器 16 bit，只能向上计数，只有 TIM 6 和 TIM7
2-没有外部的 GPIO，是内部资源，只能用来定时
3-时钟来自 PCLK 1，为 72 M，可实现 1~65536 分频

我们知道，PCLK 1 初始化的时候配置 36 M，基本定时器的时钟来自 PCLK 1，而跟此处的 72 M 冲突了。
APB 1 是低速总线，分配系数是 2。因为系统时钟 AHB 是 72 M，二分频后就等于 36 M。
要乘以 2，所以说并不是跟 APB 1 的总线时钟矛盾。

![[../../annex/21.TIM 定时器_image_2.png]]

APB 2 总线是高速总线，默认配置成 1 分频
![[../../annex/21.TIM 定时器_image_3.png]]

![[../../annex/21.TIM 定时器_image_4.png]]
所以得到定时器 1 和 8 的时候是 72 M


![[../../annex/21.TIM 定时器_image_5.png]]

![[../../annex/21.TIM 定时器_image_6.png]]


###### 时钟源
1-时钟源来自 RCC 的 TIMx_CLK（属于内部的 CK_INT）
2-TIMx_CLK 等于多少呢？如何确定？（72 M）
具体的查看：RCC 时钟树框图

###### 控制器
1-控制器用于控制定时器的：复位、使能、计数、触发 DAC
2、涉及到的寄存器为：CR 1/2、DIER、EGR、SR

###### 时基（定时器的心脏）
定时器最主要的就是时基部分：包括<font color="#ff0000">预分频器</font>（PSC，用来对时间进行分频的）、<font color="#ff0000">计数器</font>（CNT，count）、<font color="#ff0000">自动重装载寄存器</font>（ARR）。

计数要在时钟的驱动下进行计数，时钟是方波，一个脉冲计数器就加 1。
![[../../annex/21.TIM 定时器_image_7.png]]
驱动计数器的时钟叫 CK_CNT，是由 CK_PSC （内部时钟，72 M）经过预分频器 PSC 得到的

###### 预分频器
1-16 位（最大 65535）的预分频器 PSC 对内部时钟 CK_PSC 进行分频之后，得到计数器时钟 <font color="#ff0000">CK_CNT=CK_PSC/(PSC+1)</font>.（PSC+1 是官方规定的，必须加 1）

2-计数器 CNT 在计数器时钟的驱动下开始计数，计数一次的时间为 1/CK_CNT
计数周期： 1/CK_CNT x （ARR+1）--是从 0 计数到 ARR，实际计数了 ARR+1 次

###### 计数器、自动重装载寄存器
定时器使能 (CEN 置 1)后，计数器 CNT 在 CK_CNT 驱动下计数，当 TCNT 值与 ARR 的设定值相等时就自动生成事件并 CNT 自动清零，然后自动重新开始计数，如此重复以上过程。

自动重装载寄存器（ARR）表示计数器能够计数到的最大数值。
如：配置成 1000 时，计数器从 0 计数到 1000 时，产生中断，计数器清零，重新自动装载。

###### 影子寄存器
1-PSC 和 ARR 都有影子寄存器，功能框图上有个影子
2-影子寄存器的存在起到一个<font color="#ff0000">缓冲的作用</font>，用户值->寄存器->影子寄存器->起作用，如果不使用影子寄存器则用户值在写到寄存器之后则里面起作用。
<font color="#ff0000">ARR 影子，TIMx_CR 1: APRE 位控制</font>.（由控制寄存器 1--TIMx_CR 1 的第 7 位来控制）
（计数器在这个周期计数完毕后，即产生一个更新中断后在下一个周期开始的时候我们写进去的 ARR 的值才起作用）通常情况下设置立马起作用

###### 定时时间的计算
<font color="#ff0000">如何实现 500 mS 的定时</font>？

```
1、PSC = 72-1，定时器频率=72 M/(PSC+1)=1 MHZ
2、ARR = 1000-1，从 0 计数到 999，则计了 1000 次
3、中断周期 T = 1000 *1/1000000 = 1 mS
```
<font color="#ff0000">定时器频率=72 M/(PSC+1)=1 MHZ</font>.

由此可见，想控制一次中断产生的时间，都需要控制 PSC 和 ARR 的值

##### 时基初始化结构体讲解

![[../../annex/21.TIM 定时器_image_8.png]]

[2024-01-26 23：30：19]



## P 102  TIM-基本定时器-定时代码讲解

##### 代码

```main.c
#include "stm32f10x.h"  //相当于51单片机中的    #include <reg51.h> 
#include "bsp_led.h"
#include "bsp_BasicTim.h"

uint16_t time = 0;
//在it.c中使用了，在it.c中声明一下


int main(void)
{
  //  来到这里的时候,系统的时钟已经被配置成72M。不需要自己配置，启动文件中已经配置好了。
	LED_GPIO_Config();//初始化LED端口

	BASIC_TIM_Init();//初始化完毕，这时候定时器就开始工作了，如果时间到了，定时器会进入中断，让time的值++
	
	//然后我们不断的判断time的值是否等于1000
	while(1)
	{
		if( time == 1000 )//1000ms(1s)
		{
			time = 0;
			LED1_TOGGLE;/* LED1 取反 */
		}	
			
	}
}




```

```bsp_BasicTim.c
#include "bsp_BasicTim.h"

//往初始化结构体中每个成员写配数据，然后调用init函数，就会把我们配置好的结构体成员写到相应的寄存器中


// 中断优先级配置
static void BASIC_TIM_NVIC_Config(void)
{
    NVIC_InitTypeDef NVIC_InitStructure; 
    // 设置中断组为0
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);		
		// 设置中断来源
    NVIC_InitStructure.NVIC_IRQChannel = BASIC_TIM_IRQ ;	
		// 设置主优先级为 0
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;	 
	  // 设置抢占优先级为3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;//只有1个中断源，随便配置	
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}


static void BASIC_TIM_Config(void)//static,限定函数内部调用,其他文件调用不了
{
	
    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;//首先，定义一个初始化结构体。然后往结构体中填充成员
		
		// 开启定时器时钟,即内部时钟CK_INT=72M
    BASIC_TIM_APBxClock_FUN(BASIC_TIM_CLK, ENABLE);//先开定时器的时钟
	
		// 自动重装载寄存器的值，累计TIM_Period+1个频率后产生一个更新或者中断
    TIM_TimeBaseStructure.TIM_Period = BASIC_TIM_Period;	

	  // 时钟预分频数为
    TIM_TimeBaseStructure.TIM_Prescaler= BASIC_TIM_Prescaler;//配置的是1us
	
		// 时钟分频因子 ，基本定时器没有，不用管
    //TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1;
		
		// 计数器计数模式，基本定时器只能向上计数，没有计数模式的设置
    //TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up; 
		
		// 重复计数器的值，基本定时器没有，不用管
		//TIM_TimeBaseStructure.TIM_RepetitionCounter=0;
	
	  // 初始化定时器
    TIM_TimeBaseInit(BASIC_TIM, &TIM_TimeBaseStructure);
		
		// 清除计数器中断标志位
    TIM_ClearFlag(BASIC_TIM, TIM_FLAG_Update);
	  
		// 开启计数器中断
    TIM_ITConfig(BASIC_TIM,TIM_IT_Update,ENABLE);
		
		// 使能计数器
    TIM_Cmd(BASIC_TIM, ENABLE);	
	
	
}

void BASIC_TIM_Init(void)
{
	BASIC_TIM_NVIC_Config();//首先，配置好中断优先级
	BASIC_TIM_Config();//再调用模式配置
}


```

```bsp_BasicTim.h
#ifndef __BSP_TIMEBASE_H
#define __BSP_TIMEBASE_H


#include "stm32f10x.h"

/********************基本定时器TIM参数定义，只限TIM6、7************/
#define BASIC_TIM6 // 如果使用TIM7，注释掉这个宏即可

#ifdef  BASIC_TIM6 // 使用基本定时器TIM6
#define            BASIC_TIM                   TIM6
#define            BASIC_TIM_APBxClock_FUN     RCC_APB1PeriphClockCmd //2、3、4、5、6、7挂载在APB1总线
#define            BASIC_TIM_CLK               RCC_APB1Periph_TIM6
#define            BASIC_TIM_Period            1000-1
#define            BASIC_TIM_Prescaler         71
#define            BASIC_TIM_IRQ               TIM6_IRQn
#define            BASIC_TIM_IRQHandler        TIM6_IRQHandler

#else  // 使用基本定时器TIM7
#define            BASIC_TIM                   TIM7
#define            BASIC_TIM_APBxClock_FUN     RCC_APB1PeriphClockCmd
#define            BASIC_TIM_CLK               RCC_APB1Periph_TIM7
#define            BASIC_TIM_Period            1000-1
#define            BASIC_TIM_Prescaler         71
#define            BASIC_TIM_IRQ               TIM7_IRQn
#define            BASIC_TIM_IRQHandler        TIM7_IRQHandler

#endif
/**************************函数声明********************************/


void BASIC_TIM_Init(void);




#endif	/* __BSP_TIMEBASE_H */


```

```stm32f10x_it.c
#include "bsp_BasicTim.h"

extern uint16_t time;//extern，表示变量是外部定义的

void  BASIC_TIM_IRQHandler (void)
{
	if ( TIM_GetITStatus( BASIC_TIM, TIM_IT_Update) != RESET ) 
	{	
		time++;//time应该为全局变量，main函数中定义
		TIM_ClearITPendingBit(BASIC_TIM , TIM_FLAG_Update);  		 
	}		 	
}
```

```
```


[2024-01-27 00：39：27]

```
在bsp_BasicTim.h文件中声明函数void BASIC_TIM_Init(void);时忘记加分号了，导致6个error报错
```




## P 103 TIM-高级定时器-时钟源功能框图讲解

#### 定时器简介

定时器功能	：定时、输出比较、输入捕获、断路输入
定时器分类	：基本定时器、通用定时器、高级定时器
定时器资源	：F 103 有 2 个高级定时器、4 个通用定时器、2 个基本定时器

输出比较：输出 PWM 波。输入捕获：1、测量脉冲的宽度 2、PWM 输入
高级定时器比通用定时器多了一个互补输出

![[../../annex/21.TIM 定时器_image_9.png]]



#### 高级定时器功能简介
1-计数器 16 bit，上/下/两边计数（可以加减），TIM 1 和 TIM 8，还有一个重复计数器 RCR，独有。
2-有 4 个 GPIO（不是很准确），其中通道 1~3 还有互补输出 GPIO
3-时钟来自 PCLK 2，为 72 M，可实现 1~65536 分频

#### 高级定时器 GPIO 说明

![[../../annex/21.TIM 定时器_image_10.png]]


#### 高级定时器功能框图详解

![[../../annex/21.TIM 定时器_image_11.png]]


##### 一、时钟源
1-内部时钟源 CK_INT（72 M）
2-外部时钟模式 1—外部的 GPIO Tix（x=1 2 3 4）
3-外部时钟模式 2—外部的 GPIO ETR
4-内部触发输入

###### 内部时钟源
1-内部时钟源来自 RCC 的 TIMx_CLK
2-TIMx_CLK 等于多少呢？如何确定？
具体的查看：RCC 时钟树部分

最常用的是内部时钟，无论是什么时钟源，最后都会称为 CK_PSC ，经过 PSC 预分频器之后用来驱动 CNT 计数器，称为计数器的时钟
![[../../annex/21.TIM 定时器_image_12.png]]

###### 外部时钟 1

![[../../annex/21.TIM 定时器_image_13.png]]
选定引脚后，经过滤波器滤波（高频 ->低频），滤波后经过边沿检测器（上升沿有效还是下降沿有效），产生 2 路触发信号，接着通过控制寄存器 TIMx_SMCR 的 TS 位最终选择哪一路连接到 TRGI 成为触发信号。选择外部模式后连接到 CK_PSC，最终驱动预分频器，经过分频后成为计数器的时钟。 
滤波器作用：时钟间断的频率非常的高，不需要太高的时钟，可以使 2 个脉冲才称为 1 个有效，这样就叫滤波

![[../../annex/21.TIM 定时器_image_14.png]]

①时钟信号输入引脚
1-外部的 GPIO TIx，对应：TIMx_CH 1/2/3/4
2-TIM_CCMRx 的位 CCxS【1:0】配置，其中 CCMR 1 控制 TI 1/2， CCMR 2 控制 TI 3/4

②滤波器
1-如果来自外部的时钟信号的频率过高或者混杂有高频干扰信号的话，我们就需要使用滤波器对 ETRP 信号重新采样，来达到降频或者去除高频干扰的目的，2-由 TIMx_CCMRx 的位 ICxF【3:0】配置。

![[../../annex/21.TIM 定时器_image_15.png]]

③边沿检测
1-边沿检测的信号来自于滤波器的输出，在成为触发信号之前，需要进行边沿检测，决定是上升沿有效还是下降沿有效。
2-由 TIMx_CCER 的位 CCxP 和 CCxNP 配置。

④触发选择
1-当使用外部时钟模式 1 时，触发源有两个，一个是滤波后的定时器输入 1（ TI 1 FP 1）和滤波后的定时器输入 2（ TI 2 FP 2）。
2-由 TIMx_SMCR 的位 TS【2:0】配置。

⑤从模式选择
1-选定了触发源信号后，最后我们需把信号连接到 TRGI 引脚，让触发信号成为外部时钟模式 1 的输入，最终等于 CK_PSC，然后驱动计数器 CNT 计数。
2-具体的配置 TIMx_SMCR 的位 SMS【2:0】为 000 即可选择外部时钟模式 1。

⑥使能计数器
1-经过上面的 5 个步骤之后，最后我们只需使能计数器开始计数，外部时钟模式 1 的配置就算完成。
2-使能计数器由 TIMx_CR 1 的位 CEN 配置。


###### 外部时钟 2

![[../../annex/21.TIM 定时器_image_16.png]]

高级定时器和通用定时器有 ETR，专门用于外部时钟模式 2 的时钟输入。
经过边沿检测（低电平有效/高电平有效），然后会经过分配（相当于是滤波，跟外部时钟模式 1 类似），接着经过滤波器二次分频（通过另外一个时钟对这个信号 ETFP 进行采样）
![[../../annex/21.TIM 定时器_image_17.png]]

①时钟信号输入引脚
当使用外部时钟模式 2 的时候，时钟信号来自于定时器的特定输入通道 TIMx_ETR，只有 1 个。

②外部触发极性
1-来自 ETR 引脚输入的信号可以选择为上升沿或者下降沿有效。
2-具体的由 TIMx_SMCR 的位 ETP 配置。

③外部触发预分频器
1-由于 ETRP 的信号的频率不能超过 TIMx_CLK（ 180 M）的 1/4，当触发信号的频率很高的情况下，就必须使用分频器来降频。
2-具体的由 TIMx_SMCR 的位 ETPS【1:0】配置。

④滤波器
1-如果 ETRP 的信号的频率过高或者混杂有高频干扰信号的，需要使用滤波器对 ETRP 信号重新采样，来达到降频或者去除高频干扰的目的。
2-具体的由 TIMx_SMCR 的位 ETF【3:0】配置，其中的 fDTS 是由内部时钟 CK_INT 分频得到，具体的由 TIMx_CR 1 的位 CKD【1:0】配置。

⑤从模式选择
1-经过滤波器滤波的信号连接到 ETRF 引脚后，触发信号成为外部时钟模式 2 的输入，最终等于 CK_PSC，然后驱动计数器 CNT 计数。
2-具体的配置 TIMx_SMCR 的位 ECE 为 1 即可选择外部时钟模式 2。

⑥使能计数器
1-经过上面的 5 个步骤之后，最后我们只需使能计数器开始计数，外部时钟模式 2 的配置就算完成。
2-使能计数器由 TIMx_CR 1 的位 CEN 配置。


###### 内部触发输入
1-内部触发输入是使用一个定时器作为另一个定时器的预分频器。硬件上高级控制定时器和通用定时器在内部连接在一起，可以实现定时器同步或级联（高级定时器给通用定时器提供时钟）。
2- 由 TIMx_SMCR 的位 TS【2:0】配置。

###### 内部触发连接

![[../../annex/21.TIM 定时器_image_18.png]]


###### TIM 1 为 TIM 2 提供时钟

![[../../annex/21.TIM 定时器_image_19.png]]


#### 二、控制器
1-控制器就是用来控制的，发送命令的
2-CR 1、CR 2、SMCR、CCER，主要学习这几个寄存器即可。

## P 104 输入捕获和输出比较功能框图详解

#### 三、时基单元

![[../../annex/21.TIM 定时器_image_20.png]]

##### 时基单元的组成
1-16 位的预分频器 PSC，PSC
2-16 位的计数器 CNT， CNT
3-8 位的重复计数器 RCR，RCR（高级定时器独有）
4-16 位的自动重装载寄存器 ARR，ARR

##### 预分频器

![[../../annex/21.TIM 定时器_image_21.png]]

##### 计数器 （上/下/两边）

![[../../annex/21.TIM 定时器_image_22.png]]

##### 自动重装载寄存器

![[../../annex/21.TIM 定时器_image_23.png]]

##### 重复计数器

![[../../annex/21.TIM 定时器_image_24.png]]



#### 四、输入捕获

![[../../annex/21.TIM 定时器_image_25.png]]

![[../../annex/21.TIM 定时器_image_26.png]]


![[../../annex/21.TIM 定时器_image_27.png]]
其中一路会被选为触发信号（发送命令，告诉定时器可以进行捕获了），对应的是周期
这个触发信号连接到控制器中的只有 2 路（TIMx_CH 1 或 TIMx_CH 2），由通道 1、2 产生
所以，使用 PWM 输入的时候只能使用 TIMx_CH 1 和 TIMx_CH 2

##### 输入捕获的作用和原理

![[../../annex/21.TIM 定时器_image_28.png]]

###### ①输入通道
当使用需要被测量的信号从定时器的外部引脚 TIMx_CH 1/2/3/4 进入，通常叫 TI 1/2/3/4，在后面的捕获讲解中对于要被测量的信号我们都以 TIx 为标准叫法。

###### ②输入滤波和边沿检测
![[../../annex/21.TIM 定时器_image_29.png]]

###### ③捕获通道
![[../../annex/21.TIM 定时器_image_30.png]]

###### ④预分频器
![[../../annex/21.TIM 定时器_image_31.png]]
即预分频器可以决定 n 个脉冲计为 1 次脉冲

###### ⑤捕获寄存器
![[../../annex/21.TIM 定时器_image_32.png]]


#### 五、输出比较

![[../../annex/21.TIM 定时器_image_33.png]]


![[../../annex/21.TIM 定时器_image_34.png]]

![[../../annex/21.TIM 定时器_image_35.png]]


##### 输出比较的作用

![[../../annex/21.TIM 定时器_image_36.png]]

###### ①输出比较寄存器
![[../../annex/21.TIM 定时器_image_37.png]]

###### ②死区发生器
![[../../annex/21.TIM 定时器_image_38.png]]

###### 带死区插入的半桥驱动电路
![[../../annex/21.TIM 定时器_image_39.png]]

###### 带死区插入的互补输出波形图
![[../../annex/21.TIM 定时器_image_40.png]]
死区时间由元器件的工艺特性决定的，一般是在 ns 纳秒级别。（死区时间类似于惯性输出，上一个关闭后并不是马上关闭）。
（在电平信号关闭后，即置 0 低电平后, 另一个不能立马打开，还要延时一段时间的低电平）

![[../../annex/Pasted image 20240127174003.png]]
死区时间要根据元器件的参考手册来配置，通常会有说明这个时间。

![[../../annex/Pasted image 20240127174242.png]]

###### ③输出控制
![[../../annex/21.TIM 定时器_image_40.png]]

![[../../annex/tmp1706348405537_21.TIM 定时器_image_41.png]]

###### ③输出控制—讲解
![[../../annex/21.TIM 定时器_image_42.png]]

###### ④输出引脚
![[../../annex/21.TIM 定时器_image_43.png]]


### 输入捕获的应用

##### 1、测量脉宽和频率
![[../../annex/21.TIM 定时器_image_44.png]]
比如说通道 1 （TI 1），首先，上升沿捕获，捕获的值为 value（value 一般值为 0），第一次捕获 CNT 的值一般清零（在中断中清零，因为第一个捕获会进入中断，在中断中让计数器清零、捕获寄存器的值夜是 0）。
读完第一次值的时候，把捕获的边沿配置成下降沿。当第二次进入中断的时候就是下降沿中断，此时同样也会捕获到这个值（也是捕获寄存器，叫 value 2）。当我们判断到捕获寄存器的值不为 0 时，即可计算脉宽的宽度（高电平的时间）。

如果第一次中断的时候，不改变捕获的边沿（还是上升沿），第二次上升沿的时候，值就是两次上升沿之间的值，测量到的就是周期
![[../../annex/Pasted image 20240127174830.png]]
这样测比较麻烦，测量了频率就不能测脉宽，测量了脉宽就不能测频率（频率和脉宽冲突）。而且测量脉宽的时候，需要在中断服务函数中，不断改变捕获的边沿。

##### 2、PWM 输入模式
![[../../annex/21.TIM 定时器_image_45.png]]

![[../../annex/21.TIM 定时器_image_46.png]]

### 输出比较的应用
![[../../annex/21.TIM 定时器_image_47.png]]

##### PWM 输出模式
PWM 输出就是对外输出脉宽（即占空比）可调的方波信号，信号频率由自动重装寄存器 ARR 的值决定，占空比由比较寄存器 CCR 的值决定。

##### PWM 输出模式—分类

![[../../annex/21.TIM 定时器_image_48.png]]

##### 边沿对齐  VS 中心对齐
1-根据 CNT 的计数方向，PWM 波形分成边沿对齐和中心对齐两种。边沿对齐主要用于直流电机，中心对齐主要用于交流电机。
2-边沿对齐时，CNT 只工作在递增或者递减。
3-中心对齐时，CNT 工作在递增和递减。

![[../../annex/21.TIM 定时器_image_49.png]]


##### PWM 1 边沿对齐模式的波形

![[../../annex/21.TIM 定时器_image_50.png]]

##### PWM 1 中心对齐模式的波形

![[../../annex/21.TIM 定时器_image_50.png]]




















































































































































































































































































































