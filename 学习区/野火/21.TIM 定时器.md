
## P 101  TIM-基本定时器-功能框图讲解

##### 定时器简介
定时器功能	：定时、输出比较、输入捕获、互补输出
定时器分类	：基本定时器、通用定时器、高级定时器
定时器资源	：F 103 系列有 2 个高级定时器 TIM 1 和 TIM 8、4 个通用定时器 TIM 2/3/4/5、2 个基本定时器 TIM 6 和 TIM7

输出比较：最常用的是外部 GPIO 输出 PWM 信号
输入捕获：可以测量一个信号的脉冲宽度/它的频率

##### 定时器分类

![[../../annex/21.TIM 定时器_image_1.png]]

##### 基本定时器功能框图讲解
###### 基本定时器功能简介
1-计数器 16 bit，只能向上计数，只有 TIM 6 和 TIM7
2-没有外部的 GPIO，是内部资源，只能用来定时
3-时钟来自 PCLK 1，为 72 M，可实现 1~65536 分频

我们知道，PCLK 1 初始化的时候配置 36 M，基本定时器的时钟来自 PCLK 1，而跟此处的 72 M 冲突了。
APB 1 是低速总线，分配系数是 2。因为系统时钟 AHB 是 72 M，二分频后就等于 36 M。
要乘以 2，所以说并不是跟 APB 1 的总线时钟矛盾。

![[../../annex/21.TIM 定时器_image_2.png]]

APB 2 总线是高速总线，默认配置成 1 分频
![[../../annex/21.TIM 定时器_image_3.png]]

![[../../annex/21.TIM 定时器_image_4.png]]
所以得到定时器 1 和 8 的时候是 72 M


![[../../annex/21.TIM 定时器_image_5.png]]

![[../../annex/21.TIM 定时器_image_6.png]]


###### 时钟源
1-时钟源来自 RCC 的 TIMx_CLK（属于内部的 CK_INT）
2-TIMx_CLK 等于多少呢？如何确定？（72 M）
具体的查看：RCC 时钟树框图

###### 控制器
1-控制器用于控制定时器的：复位、使能、计数、触发 DAC
2、涉及到的寄存器为：CR 1/2、DIER、EGR、SR

###### 时基（定时器的心脏）
定时器最主要的就是时基部分：包括<font color="#ff0000">预分频器</font>（PSC，用来对时间进行分频的）、<font color="#ff0000">计数器</font>（CNT，count）、<font color="#ff0000">自动重装载寄存器</font>（ARR）。

计数要在时钟的驱动下进行计数，时钟是方波，一个脉冲计数器就加 1。
![[../../annex/21.TIM 定时器_image_7.png]]
驱动计数器的时钟叫 CK_CNT，是由 CK_PSC （内部时钟，72 M）经过预分频器 PSC 得到的

###### 预分频器
1-16 位（最大 65535）的预分频器 PSC 对内部时钟 CK_PSC 进行分频之后，得到计数器时钟 <font color="#ff0000">CK_CNT=CK_PSC/(PSC+1)</font>.（PSC+1 是官方规定的，必须加 1）

2-计数器 CNT 在计数器时钟的驱动下开始计数，计数一次的时间为 1/CK_CNT
计数周期： 1/CK_CNT x （ARR+1）--是从 0 计数到 ARR，实际计数了 ARR+1 次

###### 计数器、自动重装载寄存器
定时器使能 (CEN 置 1)后，计数器 CNT 在 CK_CNT 驱动下计数，当 TCNT 值与 ARR 的设定值相等时就自动生成事件并 CNT 自动清零，然后自动重新开始计数，如此重复以上过程。

自动重装载寄存器（ARR）表示计数器能够计数到的最大数值。
如：配置成 1000 时，计数器从 0 计数到 1000 时，产生中断，计数器清零，重新自动装载。

###### 影子寄存器
1-PSC 和 ARR 都有影子寄存器，功能框图上有个影子
2-影子寄存器的存在起到一个<font color="#ff0000">缓冲的作用</font>，用户值->寄存器->影子寄存器->起作用，如果不使用影子寄存器则用户值在写到寄存器之后则里面起作用。
<font color="#ff0000">ARR 影子，TIMx_CR 1: APRE 位控制</font>.（由控制寄存器 1--TIMx_CR 1 的第 7 位来控制）
（计数器在这个周期计数完毕后，即产生一个更新中断后在下一个周期开始的时候我们写进去的 ARR 的值才起作用）通常情况下设置立马起作用

###### 定时时间的计算
<font color="#ff0000">如何实现 500 mS 的定时</font>？

```
1、PSC = 72-1，定时器频率=72 M/(PSC+1)=1 MHZ
2、ARR = 1000-1，从 0 计数到 999，则计了 1000 次
3、中断周期 T = 1000 *1/1000000 = 1 mS
```
<font color="#ff0000">定时器频率=72 M/(PSC+1)=1 MHZ</font>.

由此可见，想控制一次中断产生的时间，都需要控制 PSC 和 ARR 的值

##### 时基初始化结构体讲解

![[../../annex/21.TIM 定时器_image_8.png]]

[2024-01-26 23：30：19]



## P 102  TIM-基本定时器-定时代码讲解

##### 代码

```main.c
#include "stm32f10x.h"  //相当于51单片机中的    #include <reg51.h> 
#include "bsp_led.h"
#include "bsp_BasicTim.h"

uint16_t time = 0;
//在it.c中使用了，在it.c中声明一下


int main(void)
{
  //  来到这里的时候,系统的时钟已经被配置成72M。不需要自己配置，启动文件中已经配置好了。
	LED_GPIO_Config();//初始化LED端口

	BASIC_TIM_Init();//初始化完毕，这时候定时器就开始工作了，如果时间到了，定时器会进入中断，让time的值++
	
	//然后我们不断的判断time的值是否等于1000
	while(1)
	{
		if( time == 1000 )//1000ms(1s)
		{
			time = 0;
			LED1_TOGGLE;/* LED1 取反 */
		}	
			
	}
}




```

```bsp_BasicTim.c
#include "bsp_BasicTim.h"

//往初始化结构体中每个成员写配数据，然后调用init函数，就会把我们配置好的结构体成员写到相应的寄存器中


// 中断优先级配置
static void BASIC_TIM_NVIC_Config(void)
{
    NVIC_InitTypeDef NVIC_InitStructure; 
    // 设置中断组为0
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);		
		// 设置中断来源
    NVIC_InitStructure.NVIC_IRQChannel = BASIC_TIM_IRQ ;	
		// 设置主优先级为 0
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;	 
	  // 设置抢占优先级为3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;//只有1个中断源，随便配置	
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}


static void BASIC_TIM_Config(void)//static,限定函数内部调用,其他文件调用不了
{
	
    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;//首先，定义一个初始化结构体。然后往结构体中填充成员
		
		// 开启定时器时钟,即内部时钟CK_INT=72M
    BASIC_TIM_APBxClock_FUN(BASIC_TIM_CLK, ENABLE);//先开定时器的时钟
	
		// 自动重装载寄存器的值，累计TIM_Period+1个频率后产生一个更新或者中断
    TIM_TimeBaseStructure.TIM_Period = BASIC_TIM_Period;	

	  // 时钟预分频数为
    TIM_TimeBaseStructure.TIM_Prescaler= BASIC_TIM_Prescaler;//配置的是1us
	
		// 时钟分频因子 ，基本定时器没有，不用管
    //TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1;
		
		// 计数器计数模式，基本定时器只能向上计数，没有计数模式的设置
    //TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up; 
		
		// 重复计数器的值，基本定时器没有，不用管
		//TIM_TimeBaseStructure.TIM_RepetitionCounter=0;
	
	  // 初始化定时器
    TIM_TimeBaseInit(BASIC_TIM, &TIM_TimeBaseStructure);
		
		// 清除计数器中断标志位
    TIM_ClearFlag(BASIC_TIM, TIM_FLAG_Update);
	  
		// 开启计数器中断
    TIM_ITConfig(BASIC_TIM,TIM_IT_Update,ENABLE);
		
		// 使能计数器
    TIM_Cmd(BASIC_TIM, ENABLE);	
	
	
}

void BASIC_TIM_Init(void)
{
	BASIC_TIM_NVIC_Config();//首先，配置好中断优先级
	BASIC_TIM_Config();//再调用模式配置
}


```

```bsp_BasicTim.h
#ifndef __BSP_TIMEBASE_H
#define __BSP_TIMEBASE_H


#include "stm32f10x.h"

/********************基本定时器TIM参数定义，只限TIM6、7************/
#define BASIC_TIM6 // 如果使用TIM7，注释掉这个宏即可

#ifdef  BASIC_TIM6 // 使用基本定时器TIM6
#define            BASIC_TIM                   TIM6
#define            BASIC_TIM_APBxClock_FUN     RCC_APB1PeriphClockCmd //2、3、4、5、6、7挂载在APB1总线
#define            BASIC_TIM_CLK               RCC_APB1Periph_TIM6
#define            BASIC_TIM_Period            1000-1
#define            BASIC_TIM_Prescaler         71
#define            BASIC_TIM_IRQ               TIM6_IRQn
#define            BASIC_TIM_IRQHandler        TIM6_IRQHandler

#else  // 使用基本定时器TIM7
#define            BASIC_TIM                   TIM7
#define            BASIC_TIM_APBxClock_FUN     RCC_APB1PeriphClockCmd
#define            BASIC_TIM_CLK               RCC_APB1Periph_TIM7
#define            BASIC_TIM_Period            1000-1
#define            BASIC_TIM_Prescaler         71
#define            BASIC_TIM_IRQ               TIM7_IRQn
#define            BASIC_TIM_IRQHandler        TIM7_IRQHandler

#endif
/**************************函数声明********************************/


void BASIC_TIM_Init(void);




#endif	/* __BSP_TIMEBASE_H */


```

```stm32f10x_it.c
#include "bsp_BasicTim.h"

extern uint16_t time;//extern，表示变量是外部定义的

void  BASIC_TIM_IRQHandler (void)
{
	if ( TIM_GetITStatus( BASIC_TIM, TIM_IT_Update) != RESET ) 
	{	
		time++;//time应该为全局变量，main函数中定义
		TIM_ClearITPendingBit(BASIC_TIM , TIM_FLAG_Update);  		 
	}		 	
}
```

```
```


[2024-01-27 00：39：27]

```
在bsp_BasicTim.h文件中声明函数void BASIC_TIM_Init(void);时忘记加分号了，导致6个error报错
```




## P 103 TIM-高级定时器-时钟源功能框图讲解

#### 定时器简介

定时器功能	：定时、输出比较、输入捕获、断路输入
定时器分类	：基本定时器、通用定时器、高级定时器
定时器资源	：F 103 有 2 个高级定时器、4 个通用定时器、2 个基本定时器

输出比较：输出 PWM 波。输入捕获：1、测量脉冲的宽度 2、PWM 输入
高级定时器比通用定时器多了一个互补输出

![[../../annex/21.TIM 定时器_image_9.png]]



#### 高级定时器功能简介
1-计数器 16 bit，上/下/两边计数（可以加减），TIM 1 和 TIM 8，还有一个重复计数器 RCR，独有。
2-有 4 个 GPIO（不是很准确），其中通道 1~3 还有互补输出 GPIO
3-时钟来自 PCLK 2，为 72 M，可实现 1~65536 分频

#### 高级定时器 GPIO 说明

![[../../annex/21.TIM 定时器_image_10.png]]


#### 高级定时器功能框图详解

![[../../annex/21.TIM 定时器_image_11.png]]


##### 一、时钟源
1-内部时钟源 CK_INT（72 M）
2-外部时钟模式 1—外部的 GPIO Tix（x=1 2 3 4）
3-外部时钟模式 2—外部的 GPIO ETR
4-内部触发输入

###### 内部时钟源
1-内部时钟源来自 RCC 的 TIMx_CLK
2-TIMx_CLK 等于多少呢？如何确定？
具体的查看：RCC 时钟树部分

最常用的是内部时钟，无论是什么时钟源，最后都会称为 CK_PSC ，经过 PSC 预分频器之后用来驱动 CNT 计数器，称为计数器的时钟
![[../../annex/21.TIM 定时器_image_12.png]]

###### 外部时钟 1

![[../../annex/21.TIM 定时器_image_13.png]]
选定引脚后，经过滤波器滤波（高频 ->低频），滤波后经过边沿检测器（上升沿有效还是下降沿有效），产生 2 路触发信号，接着通过控制寄存器 TIMx_SMCR 的 TS 位最终选择哪一路连接到 TRGI 成为触发信号。选择外部模式后连接到 CK_PSC，最终驱动预分频器，经过分频后成为计数器的时钟。 
滤波器作用：时钟间断的频率非常的高，不需要太高的时钟，可以使 2 个脉冲才称为 1 个有效，这样就叫滤波

![[../../annex/21.TIM 定时器_image_14.png]]

①时钟信号输入引脚
1-外部的 GPIO TIx，对应：TIMx_CH 1/2/3/4
2-TIM_CCMRx 的位 CCxS【1:0】配置，其中 CCMR 1 控制 TI 1/2， CCMR 2 控制 TI 3/4

②滤波器
1-如果来自外部的时钟信号的频率过高或者混杂有高频干扰信号的话，我们就需要使用滤波器对 ETRP 信号重新采样，来达到降频或者去除高频干扰的目的，2-由 TIMx_CCMRx 的位 ICxF【3:0】配置。

![[../../annex/21.TIM 定时器_image_15.png]]

③边沿检测
1-边沿检测的信号来自于滤波器的输出，在成为触发信号之前，需要进行边沿检测，决定是上升沿有效还是下降沿有效。
2-由 TIMx_CCER 的位 CCxP 和 CCxNP 配置。

④触发选择
1-当使用外部时钟模式 1 时，触发源有两个，一个是滤波后的定时器输入 1（ TI 1 FP 1）和滤波后的定时器输入 2（ TI 2 FP 2）。
2-由 TIMx_SMCR 的位 TS【2:0】配置。

⑤从模式选择
1-选定了触发源信号后，最后我们需把信号连接到 TRGI 引脚，让触发信号成为外部时钟模式 1 的输入，最终等于 CK_PSC，然后驱动计数器 CNT 计数。
2-具体的配置 TIMx_SMCR 的位 SMS【2:0】为 000 即可选择外部时钟模式 1。

⑥使能计数器
1-经过上面的 5 个步骤之后，最后我们只需使能计数器开始计数，外部时钟模式 1 的配置就算完成。
2-使能计数器由 TIMx_CR 1 的位 CEN 配置。


###### 外部时钟 2

![[../../annex/21.TIM 定时器_image_16.png]]

高级定时器和通用定时器有 ETR，专门用于外部时钟模式 2 的时钟输入。
经过边沿检测（低电平有效/高电平有效），然后会经过分配（相当于是滤波，跟外部时钟模式 1 类似），接着经过滤波器二次分频（通过另外一个时钟对这个信号 ETFP 进行采样）
![[../../annex/21.TIM 定时器_image_17.png]]

①时钟信号输入引脚
当使用外部时钟模式 2 的时候，时钟信号来自于定时器的特定输入通道 TIMx_ETR，只有 1 个。

②外部触发极性
1-来自 ETR 引脚输入的信号可以选择为上升沿或者下降沿有效。
2-具体的由 TIMx_SMCR 的位 ETP 配置。

③外部触发预分频器
1-由于 ETRP 的信号的频率不能超过 TIMx_CLK（ 180 M）的 1/4，当触发信号的频率很高的情况下，就必须使用分频器来降频。
2-具体的由 TIMx_SMCR 的位 ETPS【1:0】配置。

④滤波器
1-如果 ETRP 的信号的频率过高或者混杂有高频干扰信号的，需要使用滤波器对 ETRP 信号重新采样，来达到降频或者去除高频干扰的目的。
2-具体的由 TIMx_SMCR 的位 ETF【3:0】配置，其中的 fDTS 是由内部时钟 CK_INT 分频得到，具体的由 TIMx_CR 1 的位 CKD【1:0】配置。

⑤从模式选择
1-经过滤波器滤波的信号连接到 ETRF 引脚后，触发信号成为外部时钟模式 2 的输入，最终等于 CK_PSC，然后驱动计数器 CNT 计数。
2-具体的配置 TIMx_SMCR 的位 ECE 为 1 即可选择外部时钟模式 2。

⑥使能计数器
1-经过上面的 5 个步骤之后，最后我们只需使能计数器开始计数，外部时钟模式 2 的配置就算完成。
2-使能计数器由 TIMx_CR 1 的位 CEN 配置。


###### 内部触发输入
1-内部触发输入是使用一个定时器作为另一个定时器的预分频器。硬件上高级控制定时器和通用定时器在内部连接在一起，可以实现定时器同步或级联（高级定时器给通用定时器提供时钟）。
2- 由 TIMx_SMCR 的位 TS【2:0】配置。

###### 内部触发连接

![[../../annex/21.TIM 定时器_image_18.png]]


###### TIM 1 为 TIM 2 提供时钟

![[../../annex/21.TIM 定时器_image_19.png]]


#### 二、控制器
1-控制器就是用来控制的，发送命令的
2-CR 1、CR 2、SMCR、CCER，主要学习这几个寄存器即可。

## P 104 输入捕获和输出比较功能框图详解

#### 三、时基单元

![[../../annex/21.TIM 定时器_image_20.png]]

##### 时基单元的组成
1-16 位的预分频器 PSC，PSC
2-16 位的计数器 CNT， CNT
3-8 位的重复计数器 RCR，RCR（高级定时器独有）
4-16 位的自动重装载寄存器 ARR，ARR

##### 预分频器

![[../../annex/21.TIM 定时器_image_21.png]]

##### 计数器 （上/下/两边）

![[../../annex/21.TIM 定时器_image_22.png]]

##### 自动重装载寄存器

![[../../annex/21.TIM 定时器_image_23.png]]

##### 重复计数器

![[../../annex/21.TIM 定时器_image_24.png]]



#### 四、输入捕获

![[../../annex/21.TIM 定时器_image_25.png]]

![[../../annex/21.TIM 定时器_image_26.png]]


![[../../annex/21.TIM 定时器_image_27.png]]
其中一路会被选为触发信号（发送命令，告诉定时器可以进行捕获了），对应的是周期
这个触发信号连接到控制器中的只有 2 路（TIMx_CH 1 或 TIMx_CH 2），由通道 1、2 产生
所以，使用 PWM 输入的时候只能使用 TIMx_CH 1 和 TIMx_CH 2

##### 输入捕获的作用和原理

![[../../annex/21.TIM 定时器_image_28.png]]

###### ①输入通道
当使用需要被测量的信号从定时器的外部引脚 TIMx_CH 1/2/3/4 进入，通常叫 TI 1/2/3/4，在后面的捕获讲解中对于要被测量的信号我们都以 TIx 为标准叫法。

###### ②输入滤波和边沿检测
![[../../annex/21.TIM 定时器_image_29.png]]

###### ③捕获通道
![[../../annex/21.TIM 定时器_image_30.png]]

###### ④预分频器
![[../../annex/21.TIM 定时器_image_31.png]]
即预分频器可以决定 n 个脉冲计为 1 次脉冲

###### ⑤捕获寄存器
![[../../annex/21.TIM 定时器_image_32.png]]


#### 五、输出比较

![[../../annex/21.TIM 定时器_image_33.png]]


![[../../annex/21.TIM 定时器_image_34.png]]

![[../../annex/21.TIM 定时器_image_35.png]]


##### 输出比较的作用

![[../../annex/21.TIM 定时器_image_36.png]]

###### ①输出比较寄存器
![[../../annex/21.TIM 定时器_image_37.png]]

###### ②死区发生器
![[../../annex/21.TIM 定时器_image_38.png]]

###### 带死区插入的半桥驱动电路
![[../../annex/21.TIM 定时器_image_39.png]]

###### 带死区插入的互补输出波形图
![[../../annex/21.TIM 定时器_image_40.png]]
死区时间由元器件的工艺特性决定的，一般是在 ns 纳秒级别。（死区时间类似于惯性输出，上一个关闭后并不是马上关闭）。
（在电平信号关闭后，即置 0 低电平后, 另一个不能立马打开，还要延时一段时间的低电平）

![[../../annex/21.TIM 定时器_image_41.png]]
死区时间要根据元器件的参考手册来配置，通常会有说明这个时间。

![[../../annex/21.TIM 定时器_image_42.png]]

###### ③输出控制
![[../../annex/21.TIM 定时器_image_40.png]]

![[../../annex/21.TIM 定时器_image_43.png]]

###### ③输出控制—讲解
![[../../annex/21.TIM 定时器_image_44.png]]

###### ④输出引脚
![[../../annex/21.TIM 定时器_image_45.png]]


### 输入捕获的应用

##### 1、测量脉宽和频率
![[../../annex/21.TIM 定时器_image_46.png]]
比如说通道 1 （TI 1），首先，上升沿捕获，捕获的值为 value（value 一般值为 0），第一次捕获 CNT 的值一般清零（在中断中清零，因为第一个捕获会进入中断，在中断中让计数器清零、捕获寄存器的值夜是 0）。
读完第一次值的时候，把捕获的边沿配置成下降沿。当第二次进入中断的时候就是下降沿中断，此时同样也会捕获到这个值（也是捕获寄存器，叫 value 2）。当我们判断到捕获寄存器的值不为 0 时，即可计算脉宽的宽度（高电平的时间）。

如果第一次中断的时候，不改变捕获的边沿（还是上升沿），第二次上升沿的时候，值就是两次上升沿之间的值，测量到的就是周期
![[../../annex/21.TIM 定时器_image_47.png]]
这样测比较麻烦，测量了频率就不能测脉宽，测量了脉宽就不能测频率（频率和脉宽冲突）。而且测量脉宽的时候，需要在中断服务函数中，不断改变捕获的边沿。

##### 2、PWM 输入模式
![[../../annex/21.TIM 定时器_image_48.png]]

输入通道和捕获通道叫直连。
![[../../annex/21.TIM 定时器_image_49.png]]

非直连：选 TI1FP2 作为触发信号，
IC 2 捕获周期，IC 1 捕获占空比
![[../../annex/21.TIM 定时器_image_50.png]]

![[../../annex/21.TIM 定时器_image_51.png]]

首先，捕获第一个上升沿。选择直连，IC 1 和 IC 2 同步捕获，进入中断。
此时复位计数器、IC 1、IC 2 的值都是 0
等到下降沿时，硬件自动 IC 2 捕获，捕获的是占空比（脉宽）。
等到第二次上升沿的时候，IC 1 捕获一次，捕获的就是周期。

TIMx_CNT 是从 0 开始计数的。切记要记得结果要捕获的计算结果要+1


当测量的时候，如果频率很小，则 IC 1 和 IC 2 的值就会很大（频率越小，周期越大）。
此时如果没有+1，算出来的结果区别很小，可能会误以为是误差。

而如果要测 100 KHz 的时候，频率很大，周期很小，IC 1 和 IC 2 的值都很小，做分母分子的时候值很小的时候，不+1 计算出来的结果影响很大。
![[../../annex/21.TIM 定时器_image_52.png]]


### 输出比较的应用
![[../../annex/21.TIM 定时器_image_53.png]]

##### PWM 输出模式
PWM 输出就是对外输出脉宽（即占空比）<font color="#ff0000">可调</font>的<font color="#ff0000">方波</font>信号，信号频率由自动重装寄存器 ARR 的值决定，占空比由比较寄存器 CCR 的值决定。

##### PWM 输出模式—分类

![[../../annex/21.TIM 定时器_image_54.png]]
最常用 PWM 1 的递增模式下。

##### 边沿对齐  VS 中心对齐
1-根据 CNT 的计数方向，PWM 波形分成边沿对齐和中心对齐两种。边沿对齐主要用于直流电机，中心对齐主要用于交流电机。
2-边沿对齐时，CNT 只工作在递增或者递减。
3-中心对齐时，CNT 工作在递增和递减。

![[../../annex/21.TIM 定时器_image_55.png]]


##### PWM 1 边沿对齐模式的波形

![[../../annex/21.TIM 定时器_image_56.png]]

##### PWM 1 中心对齐模式的波形

![[../../annex/21.TIM 定时器_image_56.png]]


![[../../annex/21.TIM 定时器_image_57.png]]



## P 105 PWM 互补输出带死区时间和刹车控制代码讲解（上）

#### 硬件设计
![[../../annex/21.TIM 定时器_image_58.png]]

![[../../annex/21.TIM 定时器_image_59.png]]

#### 实验设计
1-PWM 互补输出实验，带死区时间，带刹车控制
2-输入捕获实验，用于测量脉宽
3-输入捕获实验，用于测量 PWM 信号

互补输出占 2 个 GPIO，死区时间可以软件设置，刹车控制需要 1 个 GPIO
硬件上选择：互补输出选 TIM 的 CH 1-PA 8、CH 1 N-PB 13；刹车选 BKIN-PB 12。

通常情况下，这些板子都是复用 GPIO，想找到没有复用的 GPIO 是不可能的。
真正做项目的时候，不是拿 STM32F10X 之类的这种开发板，只适合用来进行学习。
做项目买最小系统板，或者自己做板子（一般是自己做板子）

驱动库文件，也叫板级支持包文件。


![[../../annex/21.TIM 定时器_image_60.png]]

计数器计数一次的时间由分频因子 PSC 来决定，72 M÷（PSC+1）就是计数器的时钟，表示计数器的频率

![[../../annex/21.TIM 定时器_image_61.png]]
Period 配置的是自动重装载寄存器 ARR，决定的是信号的周期。
Prescaler 分频器，决定了计数器记一次的时间。
CounterMode 计数模式。
其他两个暂时用不到。

输出比较还要用到这个寄存器：
![[../../annex/21.TIM 定时器_image_62.png]]


![[../../annex/21.TIM 定时器_image_63.png]]
这个初始化结构体不需要配置

![[../../annex/21.TIM 定时器_image_64.png]]
刹车死区时间控制寄存器结构体

ARR 的值决定了计数器要计多少个数
计数器的时钟： 72 M÷（PSC+1）
（PSC+1）÷72 表示一个计数器的时钟
（PSC+1）x（ARR+1）÷72 M 就表示整个信号的周期
72 M ÷（PSC+1）x（ARR+1）整个 PWM 信号的频率
```
// PWM 信号的频率 F = TIM_CLK/{(ARR+1)*(PSC+1)}
```
![[../../annex/21.TIM 定时器_image_65.png]]
ARR+1 是因为是从 0 开始计数的


频率为 1 M 的 PWM 信号是很少用的，这个频率已经非常高了。所以仅仅是实验，实际很少使用。
通常情况下，驱动小型直流电机、飞控等，一般都会使用 10 k 的频率足以。
一般 10 k~25 k 的 PWM 信号可以驱动电机。超过 25 k，人耳都听不到这种噪声了。



## P 106 PWM 互补输出带死区时间和刹车控制代码讲解（下）

![[../../annex/21.TIM 定时器_image_66.png]]
记得勾选 C99 标准、取消注释

![[../../annex/21.TIM 定时器_image_67.png]]
OC 代表正输出，OCN 代表互补输出
```
// 主输出使能，当使用的是通用定时器时，这句不需要
TIM_CtrlPWMOutputs(ADVANCE_TIM, ENABLE);//只要一只能这个寄存器就开始输出PWM信号了
```

1、配置时基初始化结构体，确定周期、计数器的时钟（也就决定了频率）。
2、配置 output compare 结构体（输出比较初始化结构体），决定占空比是多少、2 个通道是否使能、具体的 PWM 模式、有效电平的极性、空闲电平的极性。
3、配置刹车和死区结构体初始化，主要配置 Break 断路输出是否使能、使能的时候什么是有效（成员 BreakPolarity）决定它的有效电平极性、最后配置死区时间（由 DeadTime 成员配置）一般要根据具体 MOS 管在驱动电子器件的时候去动上调和半径的时候，MOS 管的电气特性一般是 ns 纳秒级别。
4、最后调用函数放到 TIM_Init 初始化结构体函数中

![[../../annex/21.TIM 定时器_image_68.png]]
示波器的夹子对应连接到板子上的 GPIO 口

Debug-Settings-Flash Download-Reset and Run，不设置这个按钮则程序不会自动运行，需要我们在上电板子并手动按下复位键


![[../../annex/21.TIM 定时器_image_69.png]]
黄色的是 PA 8 的波形，蓝色是 PB 13 的波形。
PB 13 的波形有毛刺，因为进行了复用，用到了 VS1053 这个 NP3 芯片中，所以会有干扰。

![[../../annex/21.TIM 定时器_image_70.png]]
我们可以看到，正通道是高电平时，互补通道是低电平；正通道是低电平的时候，互补通道是高电平。（互补即反向，但不是完全互补，重合部分是死区的时间）

![[../../annex/21.TIM 定时器_image_71.png]]
Time=50 ns，放大波形我们可以看到死区时间有 3 格多一点点，大概是 150 ns。与程序配置的基本一致。由此可见，程序正确。
```
// 这里配置的死区时间为152ns
TIM_BDTRInitStructure.TIM_DeadTime = 11;
```


通过一根杜邦线连接 PA 12，然后把 PA 12 连接 3.3 v。波形就会变成空闲状态设置的电平状态（断路刹车）
![[../../annex/21.TIM 定时器_image_72.png]]

RESET 状态（设置成低电平）
![[../../annex/21.TIM 定时器_image_73.png]]

指南者：
![[../../annex/21.TIM 定时器_image_74.png]]
正的连接 PA 8，互补的连接 PB 13
PB 12 连接 3.3 v 就会刹车，输出空闲状态时的电平。



Homework：

1-PWM 信号的频率改成 100 kHz
2-使用通用定时器输出 4 路占空比不同的 PWM 信号（通用定时器没有互补通道，所以不需要使用互补）
具体硬件用通用定时器 TIM 3 的 PA 6、PA 7、PB 0、PB 1（其中 PA 6 和 PA 7 已经引出来了）

![[../../annex/21.TIM 定时器_image_75.png]]

![[../../annex/21.TIM 定时器_image_76.png]]

![[../../annex/21.TIM 定时器_image_77.png]]
通过输出 PWM 信号驱动 RGB 灯可以实现 255 种颜色

Path：2-TIM—通用定时器-4路 PWM 输出

##### 代码

```bsp_AdvanceTim.c
#include "bsp_AdvanceTim.h"

static void ADVANCE_TIM_GPIO_Config(void)//配置成推挽复用输出，因为由第二功能了
{
	GPIO_InitTypeDef GPIO_InitStructure;

  // 输出比较通道 GPIO 初始化
	RCC_APB2PeriphClockCmd(ADVANCE_TIM_CH1_GPIO_CLK, ENABLE);
  GPIO_InitStructure.GPIO_Pin =  ADVANCE_TIM_CH1_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(ADVANCE_TIM_CH1_PORT, &GPIO_InitStructure);

  // 输出比较通道互补通道 GPIO 初始化
	RCC_APB2PeriphClockCmd(ADVANCE_TIM_CH1N_GPIO_CLK, ENABLE);
  GPIO_InitStructure.GPIO_Pin =  ADVANCE_TIM_CH1N_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(ADVANCE_TIM_CH1N_PORT, &GPIO_InitStructure);

  // 输出比较通道刹车通道 GPIO 初始化
	RCC_APB2PeriphClockCmd(ADVANCE_TIM_BKIN_GPIO_CLK, ENABLE);
  GPIO_InitStructure.GPIO_Pin =  ADVANCE_TIM_BKIN_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(ADVANCE_TIM_BKIN_PORT, &GPIO_InitStructure);
	// BKIN引脚默认先输出低电平
	GPIO_ResetBits(ADVANCE_TIM_BKIN_PORT,ADVANCE_TIM_BKIN_PIN);	
}


static void ADVANCE_TIM_Mode_Config(void)//具体配置高级定时器的工作模式//配置初始化时基和输出比较结构体
{
	// 开启定时器时钟,即内部时钟CK_INT=72M
	ADVANCE_TIM_APBxClock_FUN(ADVANCE_TIM_CLK,ENABLE);

/*--------------------时基结构体初始化-------------------------*/
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	// 自动重装载寄存器的值，累计TIM_Period+1个频率后产生一个更新或者中断
	TIM_TimeBaseStructure.TIM_Period=ADVANCE_TIM_PERIOD;	
	// 驱动CNT计数器的时钟 = Fck_int/(psc+1)
	TIM_TimeBaseStructure.TIM_Prescaler= ADVANCE_TIM_PSC;	
	// 时钟分频因子 ，配置死区时间时需要用到
	TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1;		//不能注释掉，只能随便配
	// 计数器计数模式，设置为向上计数
	TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up;		
	// 重复计数器的值，没用到不用管
	TIM_TimeBaseStructure.TIM_RepetitionCounter=0;	
	// 初始化定时器
	TIM_TimeBaseInit(ADVANCE_TIM, &TIM_TimeBaseStructure);//把上面配置的值写到寄存器中

	/*--------------------输出比较结构体初始化-------------------*/		
	TIM_OCInitTypeDef  TIM_OCInitStructure;
	// 配置为PWM模式1
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
	// 输出使能
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;//使能输出、正通道
	// 互补输出使能
	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable; //negative负通道--互补通道
	// 设置占空比大小
	TIM_OCInitStructure.TIM_Pulse = ADVANCE_TIM_PULSE;
	// 输出通道电平极性配置
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	// 互补输出通道电平极性配置
	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
	// 输出通道空闲电平极性配置
	TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;//当用到断路功能（刹车功能）的时候，两路互补输出的PWM信号就会被强制禁止。禁止之后输出此处配置的空闲状态
	// 互补输出通道空闲电平极性配置
	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset;//如果不用断路（刹车）功能的话，这两个可以不用配置
	TIM_OC1Init(ADVANCE_TIM, &TIM_OCInitStructure);//初始化上面的成员，写到寄存器里面//初始化一路OC1即可，不用配置2个互补的。(看《输出比较》的图)
	TIM_OC1PreloadConfig(ADVANCE_TIM, TIM_OCPreload_Enable);//自动重装载

	/*-------------------刹车和死区结构体初始化-------------------*/
	// 有关刹车和死区结构体的成员具体可参考BDTR寄存器的描述
	TIM_BDTRInitTypeDef TIM_BDTRInitStructure;
  TIM_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
  TIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
  TIM_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_1;
	// 输出比较信号死区时间配置，具体如何计算可参考 BDTR:UTG[7:0]的描述
	// 这里配置的死区时间为152ns
  TIM_BDTRInitStructure.TIM_DeadTime = 11;
  TIM_BDTRInitStructure.TIM_Break = TIM_Break_Enable;
	// 当BKIN引脚检测到高电平的时候，输出比较信号被禁止，就好像是刹车一样
  TIM_BDTRInitStructure.TIM_BreakPolarity = TIM_BreakPolarity_High;
  TIM_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Enable;
  TIM_BDTRConfig(ADVANCE_TIM, &TIM_BDTRInitStructure);
	
	// 使能计数器
	TIM_Cmd(ADVANCE_TIM, ENABLE);	
	// 主输出使能，当使用的是通用定时器时，这句不需要
	TIM_CtrlPWMOutputs(ADVANCE_TIM, ENABLE);//只要一使能这个寄存器就开始输出PWM信号了
}


void ADVANCE_TIM_Init(void)
{
	ADVANCE_TIM_GPIO_Config();
	ADVANCE_TIM_Mode_Config();
}





```

```bsp_AdvanceTim.h
#ifndef __BSP_ADVANCETIM_H
#define __BSP_ADVANCETIM_H

#include "stm32f10x.h"//初始化结构体在这个文件夹中定义的


/************高级定时器TIM参数定义，只限TIM1和TIM8************/
// 当使用不同的定时器的时候，对应的GPIO是不一样的，这点要注意（TIM1改为TIM8的话，其他的也要改）
// 这里我们使用高级控制定时器TIM1

#define            ADVANCE_TIM                   TIM1
#define            ADVANCE_TIM_APBxClock_FUN     RCC_APB2PeriphClockCmd
#define            ADVANCE_TIM_CLK               RCC_APB2Periph_TIM1
// PWM 信号的频率 F = TIM_CLK/{(ARR+1)*(PSC+1)}
#define            ADVANCE_TIM_PERIOD            (8-1) //PERIOD配置ARR自动重装载寄存器的值，决定周期
#define            ADVANCE_TIM_PSC               (9-1) //PSC决定计数器的分频因子。需要改周期就修改 PERIOD 和 PSC 
#define            ADVANCE_TIM_PULSE             4		 //PULSE决定占空比，对应的是比较寄存器CCR。有4个通道，所以有4个这样的寄存器

#define            ADVANCE_TIM_IRQ               TIM1_UP_IRQn
#define            ADVANCE_TIM_IRQHandler        TIM1_UP_IRQHandler

// TIM1 输出比较通道
#define            ADVANCE_TIM_CH1_GPIO_CLK      RCC_APB2Periph_GPIOA
#define            ADVANCE_TIM_CH1_PORT          GPIOA
#define            ADVANCE_TIM_CH1_PIN           GPIO_Pin_8

// TIM1 输出比较通道的互补通道
#define            ADVANCE_TIM_CH1N_GPIO_CLK      RCC_APB2Periph_GPIOB
#define            ADVANCE_TIM_CH1N_PORT          GPIOB
#define            ADVANCE_TIM_CH1N_PIN           GPIO_Pin_13

// TIM1 输出比较通道的刹车通道
#define            ADVANCE_TIM_BKIN_GPIO_CLK      RCC_APB2Periph_GPIOB
#define            ADVANCE_TIM_BKIN_PORT          GPIOB
#define            ADVANCE_TIM_BKIN_PIN           GPIO_Pin_12






void ADVANCE_TIM_Init(void);





#endif /*__BSP_ADVANCETIM_H*/


```

```main.c

#include "stm32f10x.h"
#include "bsp_usart.h"
#include "bsp_AdvanceTim.h"


/**
  * @brief  主函数
  * @param  无
  * @retval 无
  */
int main(void)
{	
  /*初始化USART 配置模式为 115200 8-N-1，中断接收*/
  USART_Config();
	
	/*高级定时器初始化*/
	ADVANCE_TIM_Init();

  while(1)
	{	
		
	}	
}
/*********************************************END OF FILE**********************/

```

```stm32f10x_conf.h
#include "stm32f10x_tim.h"取消注释
```



---


## P 107 脉宽测量代码讲解

![[../../annex/21.TIM 定时器_image_78.png]]

需要在中断更新函数中，判断这个中断是什么中断（捕获中断还是更新中断）。如果是更新中断，总的溢出时间要 x 3

[2024-01-28 00：12：32]

![[../../annex/21.TIM 定时器_image_79.png]]
最后一小段未溢出的，由捕获寄存器 CCR 中读取出来，然后把两部分的时间相加才是整个脉冲的时间。


选硬件电路
![[../../annex/21.TIM 定时器_image_80.png]]
PA 0 刚好是定时器的通道 channel 1，而且又有输入捕获的功能

![[../../annex/21.TIM 定时器_image_81.png]]
从原理图上可以看到，PA 0 接了一个按键，默认是接地；按键按下接到 3.3 v。按键松开，又接到低电平（GND 接地）
所以，按键按下检测到的电平是个方波，符合实验所需的硬件条件。
PA 0 只存在于通用定时器 TIM 2 和 5

Output Compare  结构体，输出比较结构体，产生 PWM 信号。

ICInitTypeDef 输入捕获结构体。

具体的中断源在 stm32f10x.h 文件中 IRQn_Type 结构体，定义了系统所能识别的所有中断源，编程的时候一定要跟这里的名称保持一致，否则中断响应不了。


声明和定义，声明类型，不需要占用内存 typedef struct 结构体相当于 uint 16_t/uint 32_t。而定义需要分配内存空间（	TIM_ICInitTypeDef TIM_ICInitStructure;）


![[../../annex/21.TIM 定时器_image_82.png]]

![[../../annex/21.TIM 定时器_image_83.png]]

只有 PA 0 才能这么做，因为只有 PA 0 才接了该开发版的按键中，才能产生这种方波脉冲。
![[../../annex/21.TIM 定时器_image_84.png]]


##### 代码

```main.c

#include "stm32f10x.h"
#include "bsp_usart.h"
#include "bsp_GeneralTim.h"


/**
  * @brief  主函数
  * @param  无
  * @retval 无
  */
int main(void)
{
	uint32_t time;
	
	// TIM 计数器的驱动时钟
	uint32_t TIM_PscCLK = 72000000 / (GENERAL_TIM_PSC+1);
	
	/* 串口初始化 */
	USART_Config();
	
	/* 定时器初始化 */
	GENERAL_TIM_Init();
	
	printf ( "\r\n野火 STM32 输入捕获实验\r\n" );
	printf ( "\r\n按下K1，测试K1按下的时间\r\n" );
	
	while ( 1 )
	{
		if(TIM_ICUserValueStructure.Capture_FinishFlag == 1)
		{
			// 计算高电平时间的计数器的值
			time = TIM_ICUserValueStructure.Capture_Period * (GENERAL_TIM_PERIOD+1) + (TIM_ICUserValueStructure.Capture_CcrValue+1);
			
			// 打印高电平脉宽时间
			printf ( "\r\n测得高电平脉宽时间：%d.%d s\r\n",time/TIM_PscCLK,time%TIM_PscCLK );
			
			TIM_ICUserValueStructure.Capture_FinishFlag = 0;			
		}		
	}
}
/*********************************************END OF FILE**********************/

```

```bsp_GeneralTim.c
#include "bsp_GeneralTim.h"

// 定时器输入捕获用户自定义变量结构体定义
TIM_ICUserValueTypeDef TIM_ICUserValueStructure = {0,0,0,0};


// 中断优先级配置
static void GENERAL_TIM_NVIC_Config(void)
{
    NVIC_InitTypeDef NVIC_InitStructure; 
    // 设置中断组为0
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);		
		// 设置中断来源
    NVIC_InitStructure.NVIC_IRQChannel = GENERAL_TIM_IRQ ;	
	//只配置TIM5的中断，为什么不是更新中断/输入捕获中断？定时器5中所有的中断源的叫TIM5_IRQn这个中断源。然后在中断服务函数中判断相应的标志位，来决定是哪种中断

		// 设置主优先级为 0
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;	 
	  // 设置抢占优先级为3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;	
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}

static void GENERAL_TIM_GPIO_Config(void)//配置成推挽复用输出，因为由第二功能了
{
	GPIO_InitTypeDef GPIO_InitStructure;

  // 输入捕获通道 GPIO 初始化
	RCC_APB2PeriphClockCmd(GENERAL_TIM_CH1_GPIO_CLK, ENABLE);
  GPIO_InitStructure.GPIO_Pin =  GENERAL_TIM_CH1_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//因为是输入捕获，选择浮空输入
  GPIO_Init(GENERAL_TIM_CH1_PORT, &GPIO_InitStructure);	
}


static void GENERAL_TIM_Mode_Config(void)//具体配置高级定时器的工作模式//配置初始化时基和输出比较结构体
{
	// 开启定时器时钟,即内部时钟CK_INT=72M
	GENERAL_TIM_APBxClock_FUN(GENERAL_TIM_CLK,ENABLE);

/*--------------------时基结构体初始化-------------------------*/	
  TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	// 自动重装载寄存器的值，累计TIM_Period+1个频率后产生一个更新或者中断
	TIM_TimeBaseStructure.TIM_Period=GENERAL_TIM_PERIOD;	
	// 驱动CNT计数器的时钟 = Fck_int/(psc+1)
	TIM_TimeBaseStructure.TIM_Prescaler= GENERAL_TIM_PSC;	
	// 时钟分频因子 ，配置死区时间时需要用到
	TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1;		
	// 计数器计数模式，设置为向上计数
	TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up;		
	// 重复计数器的值，没用到不用管
	TIM_TimeBaseStructure.TIM_RepetitionCounter=0;	
	// 初始化定时器
	TIM_TimeBaseInit(GENERAL_TIM, &TIM_TimeBaseStructure);

	/*--------------------输入捕获结构体初始化-------------------*/	
	TIM_ICInitTypeDef TIM_ICInitStructure;
	// 配置输入捕获的通道，需要根据具体的GPIO来配置
	TIM_ICInitStructure.TIM_Channel = GENERAL_TIM_CHANNEL_x;
	// 输入捕获信号的极性配置
	TIM_ICInitStructure.TIM_ICPolarity = GENERAL_TIM_STRAT_ICPolarity;
	// 输入通道和捕获通道的映射关系，有直连和非直连两种
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
	// 输入的需要被捕获的信号的分频系数
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
	// 输入的需要被捕获的信号的滤波系数
	TIM_ICInitStructure.TIM_ICFilter = 0;
	// 定时器输入捕获初始化
	TIM_ICInit(GENERAL_TIM, &TIM_ICInitStructure);
	
	// 清除更新和捕获中断标志位
  TIM_ClearFlag(GENERAL_TIM, TIM_FLAG_Update|GENERAL_TIM_IT_CCx);	
  // 开启更新和捕获中断  
	TIM_ITConfig (GENERAL_TIM, TIM_IT_Update | GENERAL_TIM_IT_CCx, ENABLE );
	
	// 使能计数器
	TIM_Cmd(GENERAL_TIM, ENABLE);
}


void GENERAL_TIM_Init(void)
{
	GENERAL_TIM_NVIC_Config();//编写中断源（中断服务优先级，再编写中断服务程序）
	GENERAL_TIM_GPIO_Config();
	GENERAL_TIM_Mode_Config();
}


```

```bsp_GeneralTim.h
#ifndef __BSP_GENERALTIM_H
#define __BSP_GENERALTIM_H

#include "stm32f10x.h"//初始化结构体在这个文件夹中定义的


/************通用定时器TIM参数定义，只限TIM2、3、4、5************/
// 当使用不同的定时器的时候，对应的GPIO是不一样的，这点要注意
// 我们这里默认使用TIM5

#define            GENERAL_TIM                   TIM5
#define            GENERAL_TIM_APBxClock_FUN     RCC_APB1PeriphClockCmd
#define            GENERAL_TIM_CLK               RCC_APB1Periph_TIM5
#define            GENERAL_TIM_PERIOD            0XFFFF
#define            GENERAL_TIM_PSC              (72-1)

// TIM 输入捕获通道GPIO相关宏定义
#define            GENERAL_TIM_CH1_GPIO_CLK      RCC_APB2Periph_GPIOA
#define            GENERAL_TIM_CH1_PORT          GPIOA
#define            GENERAL_TIM_CH1_PIN           GPIO_Pin_0
#define            GENERAL_TIM_CHANNEL_x         TIM_Channel_1

// 中断相关宏定义
#define            GENERAL_TIM_IT_CCx            TIM_IT_CC1
#define            GENERAL_TIM_IRQ               TIM5_IRQn
#define            GENERAL_TIM_INT_FUN           TIM5_IRQHandler

// 获取捕获寄存器值函数宏定义
#define            GENERAL_TIM_GetCapturex_FUN                 TIM_GetCapture1
// 捕获信号极性函数宏定义
#define            GENERAL_TIM_OCxPolarityConfig_FUN           TIM_OC1PolarityConfig

// 测量的起始边沿
#define            GENERAL_TIM_STRAT_ICPolarity                TIM_ICPolarity_Rising
// 测量的结束边沿
#define            GENERAL_TIM_END_ICPolarity                  TIM_ICPolarity_Falling


// 定时器输入捕获用户自定义变量结构体声明
typedef struct
{   
	uint8_t   Capture_FinishFlag;   // 捕获结束标志位
	uint8_t   Capture_StartFlag;    // 捕获开始标志位
	uint16_t  Capture_CcrValue;     // 捕获寄存器的值
	uint16_t  Capture_Period;       // 自动重装载寄存器更新标志 
}TIM_ICUserValueTypeDef;

extern TIM_ICUserValueTypeDef TIM_ICUserValueStructure;//在it.c文件中要用到


void GENERAL_TIM_Init(void);




#endif /*__BSP_GENERALTIM_H*/


```

```stm32f10x_it.c

#include "bsp_GeneralTim.h"

void GENERAL_TIM_INT_FUN(void)
{
	// 当要被捕获的信号的周期大于定时器的最长定时时，定时器就会溢出，产生更新中断
	// 这个时候我们需要把这个最长的定时周期加到捕获信号的时间里面去
	if ( TIM_GetITStatus ( GENERAL_TIM, TIM_IT_Update) != RESET )               
	{	
		TIM_ICUserValueStructure.Capture_Period ++;		
		TIM_ClearITPendingBit ( GENERAL_TIM, TIM_FLAG_Update ); 		
	}

	// 上升沿捕获中断
	if ( TIM_GetITStatus (GENERAL_TIM, GENERAL_TIM_IT_CCx ) != RESET)
	{
		// 第一次捕获
		if ( TIM_ICUserValueStructure.Capture_StartFlag == 0 )
		{
			// 计数器清0
			TIM_SetCounter ( GENERAL_TIM, 0 );
			// 自动重装载寄存器更新标志清0
			TIM_ICUserValueStructure.Capture_Period = 0;
      // 存捕获比较寄存器的值的变量的值清0			
			TIM_ICUserValueStructure.Capture_CcrValue = 0;

			// 当第一次捕获到上升沿之后，就把捕获边沿配置为下降沿
			GENERAL_TIM_OCxPolarityConfig_FUN(GENERAL_TIM, TIM_ICPolarity_Falling);
      // 开始捕获标准置1			
			TIM_ICUserValueStructure.Capture_StartFlag = 1;			
		}
		// 下降沿捕获中断
		else // 第二次捕获
		{
			// 获取捕获比较寄存器的值，这个值就是捕获到的高电平的时间的值
			TIM_ICUserValueStructure.Capture_CcrValue = GENERAL_TIM_GetCapturex_FUN (GENERAL_TIM);

			// 当第二次捕获到下降沿之后，就把捕获边沿配置为上升沿，好开启新的一轮捕获
			GENERAL_TIM_OCxPolarityConfig_FUN(GENERAL_TIM, TIM_ICPolarity_Rising);
      // 开始捕获标志清0		
			TIM_ICUserValueStructure.Capture_StartFlag = 0;
      // 捕获完成标志置1			
			TIM_ICUserValueStructure.Capture_FinishFlag = 1;		
		}

		TIM_ClearITPendingBit (GENERAL_TIM,GENERAL_TIM_IT_CCx);	    
	}		
}
```


---



## P 108 PWM 输入捕获代码讲解

![[../../annex/21.TIM 定时器_image_85.png]]

![[../../annex/21.TIM 定时器_image_86.png]]
频率最大 1 k hz（1 us），反过来 f=1/1 us，周期就是最小。

这两个配置很重要，影响着捕获成功与否
 ```
// 输入捕获能捕获到的最小的频率为 72M/{ (ARR+1)*(PSC+1) }
#define            ADVANCE_TIM_PERIOD            (1000-1)
#define            ADVANCE_TIM_PSC               (72-1)
```
配置成最小能捕获的是 1 k，大于 1 k 的都可以捕获。要调节这两个参数




![[../../annex/21.TIM 定时器_image_87.png]]


![[../../annex/21.TIM 定时器_image_88.png]]

灯会亮，因为输出的方波还有 PB 0、PB 1 的
![[../../annex/21.TIM 定时器_image_89.png]]

![[../../annex/21.TIM 定时器_image_90.png]]

[2024-01-28 20：33：50]完工！




















































































