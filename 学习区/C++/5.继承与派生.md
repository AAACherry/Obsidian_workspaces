## 五、继承和派生

### 05-00 概要.【继承与派生】
实际上是讨论到了一个延续的问题

#### 学习目的 ：
1. 不影响到原来的类，不改变原来类的代码
2. 实现对功能的扩展
3. 在原有的类的基础上快速增加新的功能
![[../../annex/0.C++总集_image_21.png]]

#### 课程内容
1. 基本概念&&名词解释
2. 语法实现
3. 深入分析
4. 菱形继承
![[../../annex/0.C++总集_image_22.png]]

#### 重难点
1. 语法
2. 父子关系
![[../../annex/0.C++总集_image_23.png]]

---

### 05-01 继承和派生.【继承与派生】

#### 1 .继承的概念（子承父业）
继承：一种在已经有了的类的基础上创建新类的方式
新创建的类可以来自一个类，也可是来自多个类——新建的类可以继承自一个或多个类

继承描述的是（原来的）类与（新的）类之间的关系。
父类<-->子类，基类<-->派生类
原有的类称为“基类”，又或者称“父类”
新创建的类被称为"派生类"，又或者称"子类"

#### 2 .继承和派生
继承和派生实际上是同一个过程，从不同的角度看的时候，那么可以对它进行一个描述。
从子类的角度上来说是从父类继承一些东西过来，而站在父类的角度来说是把东西派生给子类

#### 3. 继承分类（2 种）
分为不同的种类：单继承、多继承
单继承：只有一个父类
多继承：父类有多个。继承的父类之间不需要有什么联系

---

### 05-02  继承方式.【继承与派生】
#### 1 .语法层面
继承写在子类的后面，在子类的后面声明一下继承关系
##### 单继承
![[../../annex/0.C++总集_image_24.png]]

##### 多继承
继承的父类之间不需要有什么联系
继承个数不限
![[../../annex/0.C++总集_image_25.png]]

#### 2. 继承权限（权限授予）
三、继承权限 (跟成员的访问权限很像)//写在大括号里面 (类体中)是成员的访问权限，写在类体外面是类的继承权限

1. 公有继承 public

2. 私有继承 private

3. 保护继承 protected

多继承每个父类之间可以任意选择其中的某一种继承方式。

注意：
继承是子类继承父类的全部成员 (数据成员和成员函数都能继承过来，无论原来是什么访问权限，只是问题在于能不能用)

##### 成员权限与继承方式结合后的 9 种访问情况
继承虽然可以让子类得到父类的所有的成员，但是对于子类（子类的对象）而言，这些东西能不能被访问到？（所有东西都可被继承，但是能否被访问？）

父类的成员在子类对象的一些访问权限（由父类原有的访问权限和子类使用的继承方式决定）

父类的成员通过子类的继承方式最终**在子类中**得到的访问权限：
（左边竖列是父类原有的成员的访问权限，上边横排是子类所使用的继承方式，共有 9 种情况）
**该表格得到的是在子类中的访问权限，而在子类的外面（创建对象）再具体分析**
| 访问权限 \ 继承方式 | 公有继承（public） | 私有继承（private） | 保护继承（protected） |
|:-------------------:|:------------------:|:-------------------:|:---------------------:|
|     **public**      |       public       |       private       |       protected       |
|     **private**     |      不可访问      |      不可访问       |       不可访问        |
|    **protected**    |     protected      |       private       |       protected       | 

1. 父类的公有访问权限 public ：公有成员用什么方式继承在子类里面就是什么样的权限--在子类中的访问权限看其继承方式（继承权限）是什么样的就是什么样

2. 父类的私有访问权限 private ：私有成员无论用什么样的方式去继承总是在子类中不可访问--只有在当前的类（本类）里面才能访问到，所有无论是在什么样的继承方式下都是不可访问。（确实继承到了，只不过不能去访问它）

3. 父类的保护访问权限 protected：哪一个更严格就是哪一个，private>protected>public

##### 多级继承：分析直接的父子类

直接套用上面的这一套规定，直接分析它的一对直接父子类
分析他们的关系只需要分析跟你直接有关的这两个就可以了：分析你的直接父子类
至于从这个顶层传达下来的东西，你没有权力去直接得到，不能够预计
一级一级的继承下来，只能（只需要）一级一级的套这个规定去分析就可以了

![[../../annex/0.C++总集_image_26.png]]

1. 先分析类 1 继承给类 2 的权限
![[../../annex/0.C++总集_image_27.png]]

2. 然后分析类 2 继承给类 3 的权限
![[../../annex/0.C++总集_image_28.png]]

3. 再分析类 3 继承给类 4 的权限，得到最终的权限
![[../../annex/0.C++总集_image_29.png]]

继承的过程中数据是不会丢失的，有就能继承下来，没有就继承不了。

#### 3. 举例

单继承且只有一对父子关系
Public 继承是最常见的，一般很少用私有继承，只有在一些特殊情况才可以去用 private 继承，保护继承用的也不多

![[../../annex/0.C++总集_image_30.png]]

![[../../annex/0.C++总集_image_31.png]]

👆验证 9 种情况中的第一列的情况👇
![[../../annex/tmp1691764469006_0.C++总集_image_32.png]]
在子类中继承父类：可以访问 public 和 protected，private 无法访问
在子类外面（创建一个对象）：只可以访问 public，protected，private 不可访问

公有继承用的是最多的，超过 90%都是用公有继承，什么情况下肯定会用私有继承：如：首先会实现一些比较特殊的设计模式的时候，或者希望屏蔽掉父类中对你这个子类没有用途的这个成员的时候

##### 代码 1--继承和派生的基本概念与语法
#代码 #继承和派生 #继承和派生的基本概念与语法
```cpp
/*语法:
一、单继承:
class 父类名
{
};  

class 子类名: 继承权限 父类名
{
};  

二、多继承:
class 父类名1
{
}; 

class 父类名2：
{
};
  
class 子类名: 继承权限1 父类名1,继承权限2 父类名2,...继承权限n 父类名n
{
};
 
三、继承权限(跟成员的访问权限很像)//写在大括号里面(类体中)是成员的访问权限，写在类体外面是类的继承权限

1.公有继承 public

2.私有继承 private

3.保护继承 protected

多继承每个父类之间可以任意选择其中的某一种继承方式。

注意：
    继承是子类继承父类的全部成员(数据成员和成员函数都能继承过来，无论原来是什么访问权限，只是问题在于能不能用)
*/

/*
1.继承虽然可以让子类得到父类的所有的成员，但是对于子类（子类的对象）而言，这些东西能不能被访问到？

父类的成员在子类对象的一些访问权限（由父类原有的访问权限和子类使用的继承方式决定）
  
父类的成员通过子类的继承方式最终在子类中得到的访问权限：
（左边竖列是父类原有的成员的访问权限，上边横排是子类所使用的继承方式，共有 9 种情况）
  

| 访问权限 \ 继承方式 | 公有继承（public） | 私有继承（private） | 保护继承（protected） |

|:-------------------:|:------------------:|:-------------------:|:---------------------:|

|     **public**      |       public       |       private       |       protected       |

|     **private**     |      不可访问      |      不可访问       |       不可访问        |

|    **protected**    |     protected      |       private       |       protected       |

  
父类的公有访问权限 public ：公有成员用什么方式继承在子类里面就是什么样的权限--在子类中的访问权限看其继承方式（继承权限）是什么样的就是什么样

父类的私有访问权限 private ：私有成员无论用什么样的方式去继承总是在子类中不可访问--只有在当前的类（本类）里面才能访问到，所有无论是在什么样的继承方式下都是不可访问。（确实继承到了，只不过不能去访问它）

父类的保护访问权限 protected：哪一个更严格就是哪一个，private>protected>public 

2.继承的过程中数据是不会丢失的，有就能继承下来，没有就继承不了。

3.多级继承：分析直接的父子类

直接套用上面的这一套规定，直接分析它的一对直接父子类
分析他们的关系只需要分析跟你直接有关的这两个就可以了：分析你的直接父子类
至于从这个顶层传达下来的东西，你没有权力去直接得到，不能够预计
一级一级的继承下来，只能（只需要）一级一级的套这个规定去分析就可以了
 */

#include <iostream>
using namespace std;

class Father
{
    public:
        Father();
        ~Father();
    private:

};  

class Son : public Father//继承写在子类的后面，在子类的后面声明一下继承的关系,public继承是最常见的，一般很少用私有继承，只有在一些特殊情况才可以去用 private 继承，保护继承用的也不多
{
    public:
        Son();
        ~Son();
    private:

};

int main()
{
    return 0;
}
//将构造函数和析构函数放在主函数后面
/* Father类的相关函数*/
Father::Father()
{
}
  
Father::~Father()
{
}
/* Son类的相关函数*/
Son::Son()
{
}

Son::~Son()
{
}
```

















##### 代码 2--举例
#代码 #继承和派生 #继承和派生的基本概念与语法 -举例

```cpp
/*语法:
一、单继承:
class 父类名
{
};

class 子类名: 继承权限 父类名
{
};
  
二、多继承:
class 父类名1
{
};
  
class 父类名2：
{
};

class 子类名: 继承权限1 父类名1,继承权限2 父类名2,...继承权限n 父类名n
{
};
  
三、继承权限(跟成员的访问权限很像)//写在大括号里面(类体中)是成员的访问权限，写在类体外面是类的继承权限

1.公有继承 public

2.私有继承 private

3.保护继承 protected

多继承每个父类之间可以任意选择其中的某一种继承方式。

注意：
    继承是子类继承父类的全部成员(数据成员和成员函数都能继承过来，无论原来是什么访问权限，只是问题在于能不能用)
*/

/*
1.继承虽然可以让子类得到父类的所有的成员，但是对于子类（子类的对象）而言，这些东西能不能被访问到？ 

父类的成员在子类对象的一些访问权限（由父类原有的访问权限和子类使用的继承方式决定）
  
父类的成员通过子类的继承方式最终在子类中得到的访问权限：
（左边竖列是父类原有的成员的访问权限，上边横排是子类所使用的继承方式，共有 9 种情况）

| 访问权限 \ 继承方式 | 公有继承（public） | 私有继承（private） | 保护继承（protected） |

|:-------------------:|:------------------:|:-------------------:|:---------------------:|

|     **public**      |       public       |       private       |       protected       |

|     **private**     |      不可访问      |      不可访问       |       不可访问        |

|    **protected**    |     protected      |       private       |       protected       |

  

父类的公有访问权限 public ：公有成员用什么方式继承在子类里面就是什么样的权限--在子类中的访问权限看其继承方式（继承权限）是什么样的就是什么样

父类的私有访问权限 private ：私有成员无论用什么样的方式去继承总是在子类中不可访问--只有在当前的类（本类）里面才能访问到，所有无论是在什么样的继承方式下都是不可访问。（确实继承到了，只不过不能去访问它）

父类的保护访问权限 protected：哪一个更严格就是哪一个，private>protected>public 

2.继承的过程中数据是不会丢失的，有就能继承下来，没有就继承不了。
 
3.多级继承：分析直接的父子类

直接套用上面的这一套规定，直接分析它的一对直接父子类
分析他们的关系只需要分析跟你直接有关的这两个就可以了：分析你的直接父子类
至于从这个顶层传达下来的东西，你没有权力去直接得到，不能够预计
一级一级的继承下来，只能（只需要）一级一级的套这个规定去分析就可以了
 */
 
#include <iostream>
using namespace std;
  
class Father
{
public:
    Father();
    ~Father();

public:
    int pub;           //创建一个公有的数据成员
    void pub_func() {} //创建一个公有的成员函数
private:
    int pri;           //创建一个私有的数据成员
    void pri_func() {} //创建一个私有的成员函数
protected:
    int pro;           //创建一个保护的数据成员
    void pro_func() {} //创建一个保护的成员函数
}; 

class Son : public Father //继承写在子类的后面，在子类的后面声明一下继承的关系,public继承是最常见的，一般很少用私有继承，只有在一些特殊情况才可以去用 private 继承，保护继承用的也不多
{
public:
    Son();
    ~Son();  

public:
    int num;
    void test_Func_public()//在类的里面创建一个函数，属于在类的里面了
    {
        this->num;//在类的里面有this指针，通过this指针可以访问到它自己的num;
        this->pub; //继承过来的公有的肯定可以被访问;
        this->pub_func(); //继承过来的公有的肯定可以被访问;
        this->pro;//公有方式继承过来的父类的被保护的成员在子类中也是可以从内部访问
        this->pro_func();//同理
        // this->pri;//父类本身私有的成员无论用什么方式继承都无法访问
        // this->pri_func();//同理
    }
    
private:

protected:

};  

int main()
{
    cout << "sizeof(Father):" << sizeof(Father) << endl; //查看当前Father类类型的对象要占多少个字节的内存（3个int，3X4=12）
    cout << "sizeof(Son):" << sizeof(Son) << endl;       //查看当前Father类类型的对象要占多少个字节的内存（子类虽然什么都没写，但是继承了父类的，所以也是12个字节，自己虽然没有新增，但也是12个在字节）
    //在Son子类中新增定义一个int类型的num，内存就变为12+4=16个字节
      
    //看看Son子类能够访问的父类的访问权限
    Son obj_son;

    obj_son.num;//自身的public成员，可以访问
    
    obj_son.pub; //父类继承过来的public数据成员，可以访问
    obj_son.pub_func(); //父类继承过来的public成员函数，可以访问

    // obj_son.pri;//父类继承过来的private成员，无法访问
    // obj_son.pri_func(); //父类继承过来的private成员函数，不可访问
  
    //  obj_son.pro;//父类继承过来的protected成员，无法访问。属于是被保护的，在类外无法被访问
    //  obj_son.pro_func(); //父类继承过来的protected成员函数，不可访问，属于是被保护的，在类外无法被访问
    
    Return 0;
}
//将构造函数和析构函数放在主函数后面
/* Father类的相关函数*/
Father::Father()
{
}

Father::~Father()
{
}

/* Son类的相关函数*/
Son::Son()
{
}  

Son::~Son()
{
}
```

##### Time
[2023-07-17 12:15:42]编写代码、学习继承和派生

---

### 05-03 父子关系【继承与派生】

####  一. 派生类的构成
##### 1. 继承情况（父类的构造、析构和拷贝不会继承）     
派生类（子类）会继承除了父类的构造函数和析构函数之外所有的成员函数和数据成员
（构造和析构不会继承下来：因为有低保吃，任何一个类系统都会给你析构和构造，这个东西你自己有，自然就不需要去继承）拷贝构造属于构造的一种，是特殊的构造函数，也不会被继承
但是你这个子类可以去调用父类的构造和析构

##### 2 .继承的调用情况
派生类（子类）中是可以去添加自己的一些新的成员的，这些则需要通过该派生类（子类）的对象来去调用。父类是无法调用你新增的成员的

##### 3 .父子类具有同名数据成员的情况
如果你的派生类（子类）当中添加的成员，它的名字和基类（父类）当中的成员名字相同，那么派生类（子类）就会把基类（父类）的这个成员隐藏起来，但是你要使用它的时候，还是可以用得到。使用方式就是通过基类（父类）的这个类名+作用域符去访问基类（父类）的这个派生类（子类）同名的成员。
如果继承的是多个基类（多个父类），多个基类当中也有名字相同的成员，也可以通过类名+作用域符的方式去访问。

![[../../annex/0.C++总集_image_32.png]]

具有同名的数据成员时，父类的会被自动屏蔽，直接访问的是访问到子类的同名的数据成员。

当然，父类的同名数据成员还在，那么我们怎样才能找到这个被藏起来的父类同名数据成员 num 呢？子类中共有三个成员（父类继承过来的 val 和 num，子类本身具有的 num），所以没法用 this 指针区分开来，因为这三个东西都是属于自己的了，继承过来当然就是自己的了，是他自己的当然就无法区分开来。

通过父类类名+作用域符来访问到同名的数据成员

![[../../annex/0.C++总集_image_33.png]]

![[../../annex/0.C++总集_image_34.png]]

###### 小结

访问自己的成员 val 照常直接访问即可
访问父类继承的同名数据成员需要父类名+作用域符
如：obj_son. Father:: val (子类声明的对象 obj_son 去访问 Father 类中的同名数据成员 val)

##### 代码
#代码 #继承和派生 #父子关系

```cpp
#include <iostream>
using namespace std;

class Father_1//测试具有多个父子类有同名的数据成员的情况
{
public:
    Father_1();
    ~Father_1();  

    int val;//设置一个同名的数据成员
    int a;//其他正常使用，不受影响
};
  
class Father
{
public:
    Father();
    ~Father();  

    int val;//设置一个同名的数据成员
    int num;//在父类当中定义一个与子类具有的同名的数据成员
    int b;//其他正常使用，不受影响

};

class Son : public Father ,public Father_1
{
public:
    Son();
    ~Son();  

    int num;
    int val;//如果子类中也有同名的数据成员val
};
  
int main()
{
    Son obj_son;//创建一个子类的对象，如果查看内存则为：3X4=12个字节，val+父类的num+子类num。无法得知 调用的是谁的num
    obj_son.num;//子类的对象可以点到（访问到）自己的num
    obj_son.val;//也可以点到父类继承过来的val（在没有多个父类有同名数据成员时）
    //当有多个父类有同名的数据成员时，子类无法搞清是访问哪个val(两个val都不是自己的，都是从父类中继承过来的),如果自己也有val则可以访问，因为继承的两个同名的val都被屏蔽了 

    cout << "obj_son.num=" << obj_son.num << endl;//输出一下子类对象.num的值,看看具有同名数据成员时访问的是谁的数据成员。得到结果：99，说明我们是通过这个子类的构造函数给的99，也就是说该num使用的是子类的数据成员，说明具有同名的数据成员时，父类的会被自动屏蔽，直接访问的是访问到子类的同名的数据成员，当然，父类的同名数据成员num还在
    //当然，父类的同名数据成员还在，那么我们怎样才能找到这个被藏起来的父类同名数据成员 num 呢？子类中共有三个成员（父类继承过来的 val 和 num，子类本身具有的num）,所以没法用 this 指针区分开来，因为这三个东西都是属于自己的了，继承过来当然就是自己的了，是他自己的当然就无法区分开来。
    
    // 通过父类类名 + 作用域符来访问到同名的数据成员

    cout << "obj_son.Father::num=" << obj_son.Father::num << endl;//输出结果:20，说明访问到的是父类的同名数据成员

    //多个父子类有同名的数据成员时，同样用类名+作用域符去访问到同名的数据成员
    cout << "obj_son.val=" << obj_son.val << endl;
    cout << "obj_son.Father::val=" << obj_son.Father::val << endl;
    cout << "obj_son.Father_1::val=" << obj_son.Father_1::val << endl; 

    return 0;
}

//将构造函数和析构函数放在主函数后面
/* Father类的相关函数*/
//在父类和子类的构造中分别给数据成员一个值，用以区分子类对象访问同名数据成员时的情况
Father::Father()
{
    val = 10; //给同名的数据成员不同的一个值，用以区分访问的情况(多个父子类有同名数据成员时)
    num = 20; //给同名的数据成员不同的一个值，用以区分访问的情况单(对父子类有同名数据成员时)
    b = 2;//其他不受影响
}
Father::~Father()
{
}

/* Son类的相关函数*/
Son::Son()
{
    num = 99; //给同名的数据成员不同的一个值，用以区分访问的情况单(对父子类有同名数据成员时)
    val = 88;  //给同名的数据成员不同的一个值，用以区分访问的情况单(对父子类有同名数据成员时)
} 
Son::~Son()
{
}
  
//将Faher_1的构造和析构写在Son的构造和析构的后面，来测试如果有多个父子类的具有同名数据成员
Father_1::Father_1()
{
    val = 100; //给同名的数据成员不同的一个值，用以区分访问的情况(多个父子类有同名数据成员时)
    a = 1;     //其他不受影响
}
Father_1::~Father_1()
{
}
```

##### Time
[2023-07-17 16:28:29]编写代码、学习继承和派生

---

####  二. 派生类和基类的关系
##### 1. 子类是父类的对象，但是父类的对象不是子类的对象
子类是父类的对象，但是父类的对象不是子类的对象--派生类是基类的对象，而基类的对象不是派生类的对象
派生类的对象可以当作基类对象来使用，因为派生类是继承了基类中所有的成员，也就是说基类有的派生类也有，既然如此，那么我直接用派生类不是也可以吗
（假设：父类有 50 块钱，而子类有 100 块钱，父类可以买的东西子类也可以买下。这就是用父类的地方可以用子类去用，因为子类本身就包含了父类所有的东西，并且它还新增了自己的一些东西。所以说父类拿下的东西，子类必拿下）

##### 2 .举例 (以单继承来简单讨论一下)

1. 子类对象也给父类对象赋值，父类对象不能给子类对象赋值

2. 父类指针可以指向子类对象，而子类指针不能指向父类对象

**赋值的话给不满就不能给，读内存的话读不够也不行**

Obj_fat = obj_son;//用子类对象给父类对象赋值，可以。父类对象可以接受子类对象给的值 (父类对象可以用子类对象赋值)

// obj_son = obj_fat;//用父类对象给子类对象赋值，不行。子类对象不能接受父类对象给的值 (子类对象不能用父类对象赋值)
   
![[../../annex/0.C++总集_image_35.png]]

![[../../annex/0.C++总集_image_36.png]]

父类不能给子类赋值：给不满，子类的新增部分没有东西给他，绿色区域拿不到值，就属于没有初始化（没有给上值）
所以父类类型比较小（父类<子类）
![[../../annex/0.C++总集_image_37.png]]

子类对象可以给父类对象赋值：给得满，黄色区域可以给过去，而蓝色区域在父类中没地方接住，给不给无所谓，浪费了就浪费了，反正只要给满了，它能用就可以了。
父类对象可以完整的接收到它所需要的值就行了，但是反过来的话子类对象有一部分没值，这不行
![[../../annex/0.C++总集_image_38.png]]

两个指针跨度不一样
左边父类类型指针指向父类，右边子类类型指针指向子类 (正常情况正常读取)
![[../../annex/0.C++总集_image_39.png]]

父类指针指向子类对象，子类指针指向父类对象
![[../../annex/0.C++总集_image_40.png]]

左边不行（子类指针指向父类对象）
右边可以（父类指针指向子类对象）

父类对象没有子类对象新增的部分。
子类指针读父类的对象。指针这么大的范围，要读取这么长，这一部分又没有，所以它不行（读不到），就算读到了也是别人的内存，它不属于当前这个对象。
（子类的指针要读取的范围比父类指针读取的范围要大）
![[../../annex/C++_image_42.png]]

至于用父类指针去读子类对象的内存的时候，父类有的东西子类都有，那么这个指针还是可以去读，至于底下多出来的这一部分，读不出来就读不出来，不读就好了。反正既不会影响别人，自己又可以读取到数据。所以用父类指针可以去读子类的对象
![[../../annex/0.C++总集_image_42.png]]

**赋值的话给不满就不能给，读内存的话读不够也不行**

##### 代码
#代码 #继承和派生 #派生类和基类的关系

```cpp
// 11-2-2继承和派生父子关系-派生类和基类的关系
//(以单继承来简单讨论一下)

/*
子类是父类的对象，但是父类的对象不是子类的对象
派生类的对象可以当作基类对象来使用，因为派生类是继承了基类中所有的成员，也就是说基类有的派生类也有，既然如此，那么我直接用派生类不是也可以吗
（假设：父类有 50 块钱，而子类有 100 块钱，父类可以买的东西子类也可以买下。这就是用父类的地方可以用子类去用，因为子类本身就包含了父类所有的东西，并且它还新增了自己的一些东西。所以说父类拿下的东西，子类必拿下）
*/ 

#include <iostream>
using namespace std; 

class Father
{
public:
    Father();
    ~Father(); 

};

class Son : public Father
{
public:
    Son();
    ~Son();
    
}; 

int main()
{
    // 子类对象也给父类对象赋值，父类对象不能给子类对象赋值
    // 父类指针可以指向子类对象，而子类指针不能指向父类对象
    // 原因都在内存图（obsidian）上面。子类比父类多一些东西，赋值的话给不满就不能给，读内存的话读不够也不行
    Father obj_fat;//定义一个父类的对象
    Son obj_son;//定义一个子类的对象
  
    obj_fat = obj_son;//用子类对象给父类对象赋值，可以。父类对象可以接受子类对象给的值(父类对象可以用子类对象赋值)
    // obj_son = obj_fat;//用父类对象给子类对象赋值，不行。子类对象不能接受父类对象给的值(子类对象不能用父类对象赋值)
    
    Father *p_fat;//定义一个父类的指针
    p_fat = &obj_fat;//父类类型的指针取父类对象的首地址给它,类型匹配，毫无问题
    p_fat = &obj_son;//子类对象的首地址给父类类型的指针，父类指针可以指向子类对象
  
    Son *p_son; //定义一个子类的指针
    // p_son = &obj_fat;//子类指针不能指向父类对象
    p_son = &obj_son;//子类类型的指针取子类对象的首地址给它,类型匹配，毫无问题 

    /*
        cout << "obj_fat=" << sizeof(obj_fat) << endl;//一个字节，大小跟编译器有关
        cout << "*p_fat=" << sizeof(*p_fat) << endl;//一个字节，视频中说指针为4个字节
        cout << "obj_son=" << sizeof(obj_son) << endl;//一个字节
        cout << "*p_son=" << sizeof(*p_son) << endl;//一个字节
     */
     
    return 0;
}

//将构造函数和析构函数放在主函数后面
/* Father类的相关函数*/
//在父类和子类的构造中分别给数据成员一个值，用以区分子类对象访问同名数据成员时的情况
Father::Father()
{
}
Father::~Father()
{
}
 
/* Son类的相关函数*/
Son::Son()
{
}
Son::~Son()
{
}
```

##### Time
[2023-07-17 17:41:31]编写代码、学习派生类和基类的关系

---

####  三. 派生类的构造析构顺序
##### 11 -2-3【继承和派生】父子关系-派生类的构造析构顺序

创建子类的对象，那么就要先调父类的构造函数，调了父类构造当然就要调父类析构函数，先构造的后析构。

如果非得要显示的传参去调用这个父类的构造，那么就把父类构造写在成员初始化列表中。(先调用父类构造才能调用自己的构造)

如果有多个继承和派生的父子类有这种情况，同样是只需要调用直接父类的构造就行了，因为 (你爷爷的构造已经在你父亲那里写好了，而你只需要写你爹的就可以了。子类在成员初始化列表写父类的/去调用就可以了，而父类的父类在父类的成员初始化列表处写/调就可以了)--（俄罗斯套娃）--你只需要对自己的直接父子类去负责即可


子类当中肯定会有一部分东西是继承自父类的，这一部分东西怎么去初始化？
通过子类去调用父类的构造函数，需把它写在你的成员初始化列表里面

为什么会调用父类的构造函数呢？
其实就相当于有些地方系统悄悄的给你在成员初始化列表写了 Father 类的构造函数
不带参数也是悄悄的给你写了这么一个东西，只是你看不见，也不需要看见。

![[../../annex/0.C++总集_image_43.png]]

直接这么写没问题
![[../../annex/0.C++总集_image_44.png]]

但是你要传参的话，就要这么写（在成员初始化列表中写上父类构造）
![[../../annex/0.C++总集_image_45.png]]

成员初始化列表语法是很灵活的，想怎么放就怎么放
![[../../annex/0.C++总集_image_46.png]]

同理
![[../../annex/tmp1691764472892_0.C++总集_image_48.png]]


##### 代码
#代码 #派生类的构造和析构顺序

```cpp
// 11-2-3【继承和派生】父子关系-派生类的构造析构顺序
// 创建子类的对象，那么就要先调父类的构造函数，调了父类构造当然就要调父类析构函数，先构造的后析构。
// 如果非得要显示的传参去调用这个父类的构造，那么就把父类构造写在成员初始化列表中。(先调用父类构造才能调用自己的构造)
// 如果有多个继承和派生的父子类有这种情况，同样是只需要调用直接父类的构造就行了，因为(你爷爷的构造已经在你父亲那里写好了，而你只需要写你爹的就可以了。子类在成员初始化列表写父类的/去调用就可以了，而父类的父类在父类的成员初始化列表处写/调就可以了)--（俄罗斯套娃）--你只需要对自己的直接父子类去负责即可

#include <iostream>
using namespace std;

class Father
{
public:
    Father();
    Father(int n); //父类构造带参数
    ~Father();
  
    const int num;
};  

class Son : public Father
{
public:
    Son();
    Son(int n, int v); //子类构造带参
    ~Son();
  
    int val;
};  

int main()
{
    // Son obj_son;//创建了子类对象
    Son obj_son(3, 4); //传个参数3和4(令n =3,v=4)
    cout << "obj_son.num=" << obj_son.num
         << "obj_son.val=" << obj_son.val
         << endl;  
         
    return 0;
}

//将构造函数和析构函数放在主函数后面
/* Father类的相关函数*/

/*//父类中int num为公有时
 Father::Father()
{
    num = 0; //父类的构造中给num赋值0
    cout << "父类构造" << endl;
}
Father::Father(int n)
{
    num = n; //父类的构造中形参传给num
    cout << "父类带参构造" << endl;
}
*/
Father::Father():num(0)//父类中num为const修饰时
{
    cout << "父类构造" << endl;
}
Father::Father(int n):num(n)
{
    cout << "父类带参构造" << endl;
}
Father::~Father()
{
    cout << "父类析构" << endl;
}
  
/* Son类的相关函数*/
Son::Son()
{
    val = 10; //子类的构造中给val赋值10
    cout << "子类构造" << endl;
}

//怎么样才能把子类当中的n传倒父类当中的num？

Son::Son(int n, int v) :Father(n),val(v)//这样才是调用父类的构造函数，在成员初始化列表里面调用。其他地方是不能被我们主动调用的，只是把它写在初始化列表里面，本质上还是由系统自动调用，执行到初始化列表的时候还是会给他出一下（这样就能拿到3和4）
//成员初始化列表中写了Father类构造函数，后面同样可以照常写val(v)。
{
    val = v;
    // num = n;//当父类中的num被const修饰时，子类当中同样不能这样去给它值了
    // Father(n);//这么做不是在调构造函数，而是在创建一个父类的、没有名字的对象，传了一个参数为n（这不属于把n传过去）
    cout << "子类构造" << endl;
}
Son::~Son()
{
    cout << "子类析构" << endl;
}  
// 如果你要创建子类对象，会先调用父类的构造

```

##### Time
[2023-07-18 17:12:37]编写代码、学习 C++派生类的构造和析构的顺序

---

### 05-04 菱形继承（用虚指针）【继承与派生】
菱形继承是通过类的结构图的样子来取名字的

![[../../annex/0.C++总集_image_47.png]]

类 A 派生出了类 A 1, A 2。
类 A 1, 类 A 2 又共同派生出了新的类，类 AA。

![[../../annex/0.C++总集_image_48.png]]

假设类 A 中有一个成员 n，然后派生出类 A 1，类 A 2 时，理所当然的就各自会有一个 n。
再由类 A 1，类 A 2 共同派生出来的类 AA，继承会把父类里面所有的成员都继承过来，所以相当于类 AA 中有了两个同样的 n，究其根本这两个 n 都是来自于类 A。
这两个东西重复了。重复了没必要（臃肿、多余）。甚至有时候可能会出现问题：比如去访问他们的时候出现问题。
而且有一个致命的问题，在此处 int 类型只有 4 个字节，那么对于类 AA 来讲就只多了 4 个字节。但假设类 A 中有 100 个这样的 n（很容易就做到，如：类 A 中有一个 int 类型的数组，长度 100，那就是 400 个字节了），然后类 A 1，类 A 2 正常继承，没问题。但是给到类 AA 的时候，类 AA 就等于多余了 100 个 int 类型的内存，相当于浪费了 400 个字节内存。

![[../../annex/0.C++总集_image_49.png]]

类 AA 同时继承了两份类 A 的成员，浪费。

![[../../annex/0.C++总集_image_50.png]]

可以通过类名+成员名的形式，直接父类的类名就可以去得到它的这两个变量
类名 : : 成员名

![[../../annex/0.C++总集_image_51.png]]

这两个变量确实可以访问到，确确实实的不同的两个变量，来自两个不同的父类，只不过是追根溯源的时候，来自同一个类（类 A），这是没有必要的。
若类 A 中有很多这样的成员，各自继承下去给类 A 1, 类 A 2，这就不合适了，名字一样，来自不同父类，但是这不同父类之间又有亲戚关系，这就很容易混淆。

像这种方法虽然可以访问。但是治标不治本，内存还是浪费


为了解决这种事情，于是有了虚继承这个东西
![[../../annex/0.C++总集_image_52.png]]

在继承的时候加上 virtual，对于类 A 1，类 A 2 没有任何影响，实际上是会有一个虚指针存在，这个虚指针最大的作用是标记一下你类 A 1 从类 A 中继承了哪些东西，你类 A 2 的虚指针就标记一下你类 A 2 从类 A 中继承了哪些东西，然后由类 A 1，A 2 共同派生出类 AA 时，虚指针起作用：派生时会去查看，我们俩重复了部分内容，那就只给他(类 AA)一份内容
![[../../annex/0.C++总集_image_53.png]]

用了虚指针，原来不行的 obj_aa. N 现在可以了，就不需要类名去限定。
![[../../annex/0.C++总集_image_54.png]]


可以这么去理解：不从类 A 1，类 A 2 中拿了，直接从类 A 中拿过来。
用了虚指针，最终子类就只会有一份来自于最先父类的这么一个内存
![[../../annex/0.C++总集_image_55.png]]

##### 代码
#代码 #菱形继承 （用虚指针）

```cpp
// 11 - 3菱形继承（虚指针）

#include <iostream>
using namespace std;
//类的结构图写成代码
class A
{
public:
    int n;
};
  
class A_1 : virtual public A //加上virtual，虚指针，用这种方式类A2就分别会多出4个字节的内存，这4个字节的内存存这个虚指针
{
public:
    int a1;
}; 

//有一个兄弟类A_2
class A_2 : virtual public A //加上virtual，虚指针，用这种方式类A2就分别会多出4个字节的内存，这4个字节的内存存这个虚指针
{
public:
    int a2;
};  

class AA : public A_1, public A_2
{
public:
    int aa;
};  

int main()
{
    AA obj_aa; //用AA来定义一个对象
    obj_aa.aa; //可以访问到
    obj_aa.a1; //可以访问到
    obj_aa.a2; //可以访问到
    // obj_aa.n; //有问题，不能直接访问（这里是不明确的问题）
    
    obj_aa.n; //用了虚指针，原来不行的 obj_aa.n 现在可以了，就不需要类名去限定。即便用类名去限定也是同一份内容。

    obj_aa.A_1::n; //这种方法可以访问，对象+.+类名+作用域符+成员
    obj_aa.A_2::n; //这种方法可以访问，可以用这个来区分清楚n是哪一个的问题
    //这两个变量确实可以访问到，确确实实的不同的两个变量，来自两个不同的父类，只不过是追根溯源的时候，来自同一个类（类A），这是没有必要的。若类 A 中有很多这样的成员，各自继承下去给类 A 1, 类 A 2，这就不合适了，名字一样，来自不同父类，但是这不同父类之间又有亲戚关系，这就很容易混淆。只有一个n都这么麻烦，这么做不合适。
    //治标不治本，内存还是浪费

    // obj_aa.A::n;//不是直接父类，所以不行，这里不知道为啥可以，视频里是不行的。（这里是属于A不是直接父类，所以不行）
  
    //如何解决：虚继承--在继承的时候加上 virtual，对于类 A1，类 A 2 没有任何影响，实际上是会有一个虚指针存在，这个虚指针最大的作用是标记一下你类A1从类A中继承了哪些东西，你类A2的虚指针就标记一下你类A2从类A中继承了哪些东西，然后由类A1，A2共同派生出类AA时，虚指针起作用：派生时会去查看，我们俩重复了部分内容，那就只给他(类AA)一份内容。

    // 用这种方式类A1,类A2就分别会多出4个字节的内存，这4个字节的内存就是存这个虚指针的。用4个字节的内存去换取不知道多少个的内存就很划算，并且还解决的类AA重复的问题

    //可以这么去理解：不从类 A1，类 A2 中拿了，直接从类 A 中拿过来。

    // 用了虚指针，最终子类就只会有一份来自于最先父类的这么一个内存

    return 0;

}
```

##### Time
[2023-07-19 00：14：14]编写代码、学习菱形继承、虚指针

---



