
传送门
	[【从C语言过渡到C++】01-02.bool类型_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Vm4y1w7s3/?p=4&vd_source=7b80e536fe7c5eb4e2dc69bd9c706d86)
	![](../../annex/0.C++总集_image_1.png)

## 一、C 语言过渡至 C++
### 1 .bool 类型

用来描述“**真**”和“**假**”

sizeof(bool)   **占一个字节**

取值范围： true（真） false（假）  （并不是-128~127）
给了（0 或1）数据以外的值：数据**溢出
遵循“**非0为真**”原则

#### 代码
#代码 #bool类型
- [2023-07-02 10:45:44]
```cpp
#include <stdio.h>

int main()
{
   bool a = true;
   a = false；
   a = 123;
   a = 3.14;
   a = 0;
   //   a = 1;
  
   printf("%d\n", sizeof(bool));
   //   printf("%d\n", a);
   return 0;
}
```

---
### 2 .内联函数 inline
- [2023-07-01 17:55:36]

内联函数是函数；通过“内存膨胀”的方式，以**空间换取时间**；其目的是**提高程序运行的速度**。

有循环尽量不要使用内联。**代码简单**（返回/赋值等使用频率高）则使用内联。

尽可能用消耗更少的空间来换取多的时间。


```
语法：在返回值类型前面加上inline
inline 返回值类型 函数名（）

{
      函数体；
}

```

![[../../annex/1.C 语言过渡至 C++_image_1.png]]

#### 代码
#代码 #内联函数
- [2023-07-02 10:39:49]

```cpp
#include <stdio.h>

inline void func(int num);

int main()
{
    func(6);
}

inline void func(int num)
{
    printf("void func(int num);num=%d\n", num);
}
/*语法：在返回值类型前面加上inline
inline 返回值类型 函数名（）
{
      函数体；
}
*/
```

### 3 .函数重载

在同一个项目中定义的**函数名字可以重复**。

函数名必须**一致**。

函数的**参数列表不同**—— 个数不相同/对应位置上类型不同。

返回值类型不进行讨论（不影响）（void/int/float...）
小数默认为双精度(字面量默认双精度)
根据实参的情况去匹配同名的重载函数。（先读参数，再调用函数）

函数不明确要调用的对应类型的函数（二义性如何解决）：
	可以传对应类型的参数、
	强转参数类型、
	加一个对应类型的函数的重载、
	可以直接不写/不用重载

要使参数明确的让编译器调用具体哪个函数。
（函数调用不明确——**二义性**（有多重含义））
- [2023-07-02 10:09:40]
![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps1.jpg) 
#### 代码
#代码 #函数重载
- [2023-07-02 10:39:13]
```cpp
#include <stdio.h>

int func(int n)
{
}

float func(float a)
{
} 

void func(double b)
{
}

double func(int n, float v)
{
}

int main()
{
    func(3.14);      //小数默认为双精度(字面量默认双精度)
    func((int)3.14); //强转为int类型
    func(5);
    func(3, 3.5f); //规定3.5为float类型
    return 0;
}
```

---
### 4 .函数参数缺省

缺省缺的是实参，因为形参只用定义一次，实参可能需要使用多次。
目的：降低写代码的工作量

声明函数某个参数（形参）的时候指定一个**默认值**。
调用该函数时如果采用默认值，无需指定该参数。

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps2.jpg) 

#### 代码 
#代码 #函数参数缺省 
[2023-07-02 10:37:21]
```cpp 
#include <stdio.h>

void function(int num = 0, float val = 0.0f);
//先声明后定义时，缺省只需在声明部分，定义部分不要再缺省。

void function();

int main()
{
    function(6, 3.14f); //传参是由前往后的；
    function(8);
    /*function();报错：有两种函数均可被调用，编译器出错*/
    function(0); 
    //要么给一个参数，要么选择将函数二选一删除。
}
void function(int num, float val) 
//因此设置默认值(缺省)应该从后往前。
{//缺省的值要为常量，不可在前面定义一个变量赋给它。
    printf("num=%d,val=%f\n", num, val);
}

void function()

{
    printf("void function();");
}
```

#### Time
[2023-07-02 10:37:21]代码编写
[2023-07-02 11:10:04]重温

---
### 5 .引用

对一个变量或者对象取的**别名**。

定义引用的时候必须要**初始化**。

引用只是单独给它一个别名，不存在单独一段内存给它——**对应同一段内存**

引用必须要先初始化。&只起标志性的作用，类型要一致。

引用只能给变量取一个别名，无法取多个。
```初始化：
int& 引用名=原变量名;
```


![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps3.jpg) 

#### 代码
#代码 #引用

```cpp
#include <stdio.h>
void main()
{
    //&解析引用符，作为取舍地址使用，
    //也可作为位运算符使用，还可表示定义的是个引用。
    int number = 0; // int类型4个字节大小内存。
    int &dd = number;
    //引用，dd与number具有同等法律效力，同一段内存不同名
    printf("number=%d\n", number);
    printf("number=%d\n", dd);
    printf("dd=%d\n", number);
    printf("ddr=%d\n", dd);
    dd = 10; // dd与number对应同一段内存。
    printf("number=%d\n", number);
    printf("number=%d\n", dd);
    printf("dd=%d\n", number);
    printf("dd=%d\n", dd);
    int gamecontrolnumber = 9;
    int &gcn = gamecontrolnumber;
    //引用的价值：方便使用变量名。
}
```

#### Time
[2023-07-02 11:10:53]~[2023-07-02 11:17:40]代码编写
[2023-07-02 11:18:02]~[2023-07-02 11:23:56]重温

---

### 6 .命名空间

为了避免，在大规模程序的设计中，以及在程序员使用各种各样的 C++库时，这些标识符的命名发生冲突，标准 C++引入关键字 namespace（命名空间/名字空间/名称空间），可以更好地控制标识符的作用域。

命名空间是用来<font color="#ff0000">组织和重用</font>代码的<font color="#ff0000">编译单元</font>。

通过命名空间来**避免冲突**，解决重名现象。

```
作用域运算符    ：：
访问：  命名空间名+作用域符+变量名 
例 ：   Name_1 : : num
可译作：命名空间 Name_1 里面的（当中的）num 变量
```
不能在函数里面定义命名空间，只能在命名空间中定义命名空间。
命名空间中可以定义各种变量和函数体。

当命名空间标识符过长或不方便记忆时，可取一个别名来**简化代码**，**增加可读性**

工程越大，名称互相冲突性的可能性越大。
 **命名空间只能全局范围内定义（以下为错误写法）**
 ![[../../annex/1.C 语言过渡至 C++_image_2.png]]

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps4.jpg) 

#### 代码
#代码 #命名空间
```cpp
#include <stdio.h>

namespace Name_1
{
    namespace Name_1_1 //可嵌套定义命名空间
    {
        int num = 8;
    }
    int num = 10;//可定义变量
    float val;//可定义变量
    void func_1()//可定义函数
    {
        printf("fun_1");
    }
    void fun_2();
} //(作用域)不要加分号;(相当于空语句，与前面无关)
/*
struct Mystruct{
}；
要加分号，因为该结构体内是定义域。

void fun_2()
{
	printf("fun_2");
}
不加作用域符::就是普遍全局变量，不是命名空间中的函数;作用域符::可理解为“里面的”。
*/
void Name_1::fun_2() //(Name_1里面的fun_2();)
//若此函数表示为namespace命名空间中先声明过的函数，则要添加命名空间名+作用域符
{
    printf("fun_2");
}  

namespace Name_1 //同一个命名空间（命名污染），也可以特意在不同的地方定义同一个命名空间（都可被访问），可在不同的地方完善它
{
    char ch;
}
  
namespace N = Name_1; //取别名———可简化命名空间名，增加可读性
  
int main()
{
    int num = 9;
    printf("num=%d\n", num);
    printf("num=%d\n", Name_1::num);
    printf("num=%d\n",Name_1::Name_1_1::num);
}
```

#### Time
[2023-07-02 11:24:33]~[2023-07-02 11:36:11]代码编写
[2023-07-02 11:36:22]~[2023-07-02 12:00:51]重温

---
### 补充：C++ 命名空间 namespace，缺省参数，引用，重载，引用与指针的区别
###### 一、命名空间 namespace：

1.命名空间定义了一个新的作用域

2.Std 是 C++标准库的命名空间

3.命名空间有三种写法来使用标准空间：using namespace std、std:: xx 和 using std::xx

4.可以使用 namespace name_space{}; 定义自己新的命名空间

###### 二、缺省参数

1.缺省参数就是在定义或声明时给出的函数参数的默认值

2.C 不支持缺省参数 C++支持

3.半缺省不是单纯的参数少一半，还要注意必须从右往左缺省，否则会编译出错

4.缺省参数的意义：在调用有缺省参数的函数时，如果没有指定实参则使用该默认值，否则使用指定的实参

###### 三、引用

1.引用必须初始化，必须在定义引用时明确引用的是哪个变量或对象，否则语法错误，指针可以不用，当不初始化时指针的初始值是随机的

2.引用一旦定义时初始化指定，就不能再修改，指针可以改变指向

3.不存在指向空值的引用，但可以有指向空值的指针，即不能出现空引用，而指针可以赋空

4.引用本质和指针一样都是传地址，只不过这个工作由编译器来做

5.函数调用为了提高效率，常使用引用或指针来作为函数参数传递对象或参数

###### 四、重载

1.必须是函数参数列表有所不同（包括个数和类型），才构成重载

2.函数重载不能依靠返回值不同来判断是否构成重载，因为调用时无法根据参数列表确定调用哪个重载函数

3.构成重载的条件：函数名相同且参数列表不同

4.重载函数的返回值可以相同

###### 五、引用与指针的区别

1.指针通过某个指针变量指向以后，可通过指针间接对变量进行操作

引用就是目标变量的别名，可通过引用直接对变量进行操作；

2.程序中使用指针，相对于引用来说，程序的可读性变差

3.指针的使用需要开辟空间，而引用不必，所以引用比指针更节省存储空间

4.空指针没有任何指向删除无害，引用是别名删除就是删除真实对象

---
版权声明：本文为 CSDN 博主「梦想很美」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接： https://blog.csdn.net/weixin_61488314/article/details/128313821 

---
### 7 .cin 和 cout

cin的作用类似scanf，输入。既不是关键字，也不是函数，是对象。

cout的作用类似printf，输出。既不是关键字，也不是函数，是对象。

他们在具体使用的时候有些区别，区别在于**不需要指定格式符**，如%d

```
#include<iostream>cin和cout存在于std的命名空间中的。
```
前面定义的时候如果写了 using namespace std 就可以不用写 std::

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps5.jpg) 

#### 代码
#代码 #cin和cout

```cpp
#include <stdio.h>
#include <iostream> //要想使用cin和cout先引入头文件
// using namespace std;
using std::cin;
using std::cout;
using std::endl; // std空间太大，只需使用这三个时，可这样操作

int main()
{
    int num;
    std::cin >> num;
    std::cout << num << std::endl; // endl是换行
    // cin和cout和endl都在命名空间std中
    int num2;
    cin >> num2;
    cout << "num2=" << num2 << endl;
    //要想简化代码，省去STD，先using namespace std;
    int a, b, c, d, e, f;
    cin >> a >> b >> c >> d >> e >> f;
    cout << a << b << c << d << e << f << endl;
}
```

#### Time
[2023-07-02 12:01:37]~[2023-07-02 12:09:02]编写代码
[2023-07-02 16:01:09]~[2023-07-02 16:56:05]重温

---

### 8 .new 和 delete 关键字（蓝色）

<font color="#00b0f0">new</font>的作用类似于malloc，（申请）分配内存

<font color="#00b0f0">delete</font>的作用类似于free,（归还）释放内存。

C 语言中用的时候是malloc 和 free 是函数，
C++中用的时候是new 和 delete 是关键字。

```
初始化用圆括号（），指定内存大小用中括号[]
```


![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps6.jpg) 
![[../../annex/1.C 语言过渡至 C++_image_3.png]]
#### 代码
#代码 #new和delete

```cpp
#include <iostream>

using namespace std;

int main()
{
    // 1.申请单个内存
    int *p1 = new int; // new是分配（申请）内存的关键字
    *p1 = 0;
    
    // 2.申请单个内存且初始化
    int *p2 = new int(999);        //圆括号--值
    cout << "*p2=" << *p2 << endl; //输出：*p2=999

    // 3.批量申请(连续内存)连续内存就无法给初值了(无法初始化)，因为没有空位
    //只能给定长度，后续再进行赋值
    int *p3 = new int[10]; //中括号--个数
    for (size_t i = 0; i < 10; i++)
    {
        p3[i] = i;
        // cout<<"*p3[%d]="<<p3[i]<<endl;
        cout << "p3[" << i << "]=" << p3[i] << endl;
    }

    // delete释放内存（归还）
    //  delete 变量;   这种写法只能释放一个
    delete p1; //直接释放掉p1
    delete p2; // p2同理
    // delete p3;   p3不可这样操作，这样只释放一个

    delete[] p3; // delete后面加上中括号[]即可释放一段连续的内存,全释放
    //连续释放内存，中括号[]后的必须是首地址（p3），否则会有一部分释放不掉
    //从当前位置开始向后释放到标记位置
    /* 自测
        cout << "*p1=" << *p1 << endl;
        cout << "*p2=" << *p2 << endl;
        for (size_t i = 0; i < 10; i++)
        {
            p3[i] = i;
            //cout<<"*p3[%d]="<<p3[i]<<endl;
            cout << "p3[" << i << "]=" << p3[i] << endl;
        }
    */
}
```

#### Time
[2023-07-02 16:57:46]~[2023-07-02 17:33:35]代码编写、重温

---
## 二、面向对象思想

**学习目的**
明确面向过程与面向对象的区别
掌握面向对象编程思想
掌握类与对象的关系

**学习内容**
回顾总结面向过程
全面了解**面向对象**√
深入学习类与对象
学会使用**String类**√

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps7.jpg) 

#### 1 .面向过程

提出问题——分析问题——处理问题 语言和编程思想之间不具备必然联系

大问题--->小问题<===>做好这一步，再做下一步，直到做完所有。

优点：
问题简单化、条理清晰；
符合生活习惯；
通常全局可见/用；
程序结构简单（顺序、选择、循环三种结构）、不需要很复杂的语法；
对整个问题把控清楚，随时随地修改；

缺点：
代码的操作（函数）和数据是分开的，通过传参、读文件等方式联系起来。
数据发生变化，代码修改的代价大；
数据公开透明，数据不具备封装性（未隐藏和加密及其他特殊处理），容易被篡改；
标识符重名等问题，大型工程项目时多人协同开发难以配合，牵一发而动全身。

#### 2 .面向对象编程思想

面向对象的程序设计是面向过程的继承和发展

面向对象可以理解为：现实世界是由对象组成的

对象在程序中抽象为两个部分：属性、行为（数据、函数）

具有相同属性和行为的东西组成的集合就是类

从类中实例化一个对象，通过对象解决问题

特点：
将数据和行为结合到一起---->对象

数据和行为/函数是分开的

**三大特性**：**封装**（隐藏数据，不需要明白原理，只需会使用）、**继承**（子承父业，继承父类的特性并可增加自己新特性）、**多态**（不同情况下可做不同事情）、抽象（提取出都具备的属性和行为再结合起立成类）

代码维护方便、扩展容易、可重复使用率高（重用）

多线程——多个同时工作

低耦合（耦合（彼此间结合的很紧密）——内聚（自己管自己，不去看/比别人））——互相之间不怎么影响

组件编程——多人协同去开发一个东西，每人分配不同组件完成后再组装成完整

代码托管——自己无需去管理后续的事情

适配器模式——无需自己造轮子，直接去使用即可

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps8.jpg) 

#### 3 .类与对象

空类占一个字节，而不是没有

类是一种用户自定义的数据类型（可以有函数、数据）

类可以理解为结构体的升级版，结构体中最起码不能有函数，类中可以有函数

类是具有相同的属性和行为的对象的集合（类是所有东西的统称）

**类是对象的抽象，对象是类的具体**.
用 C 语言来看待：类是一种数据类型，对象就是该数据类型所定义的变量
对象：通过使用‘类’类型定义的变量

1.定义类

2.定义对象

3.访问成员

4 .class 和 struct 关键字

class是关键字
class 类名
{
};
类名要求必须是合法标识符，一般情况下类名的首字母会大写。
{ }中是类的范围，
}后要加分号;     
原因：定义一个类，大括号{ }中的区域就是定义域，定义域要加分号;而作用域不用加分号。

{ }中可以定义数据成员（数据：（int/float 等）类型的变量）、另一个‘类’类型的变量（对象）、结构体变量、成员函数（函数可在类里面声明，外面定义）。

public/private/protected 关键字，访问权限。
从该关键字到下一关键字之前，无论是函数还是数据都是这种访问权限。

1.公有权限 public:到 private 之间的内容都是公有权限（在类的内部和外部都可随意访问）

2.私有权限 private：只在当前‘类’的内部可见

3.被保护的权限 protect：与继承相关，被继承的类可以看得见，别的地方看不见
protected 与后面要学的继承有很大的因果关系

若直接定义成员，则该成员默认为私有的。因为实现这个类就是要实现这个封装（藏起来）。

##### 代码 1
#代码 #class
```cpp
//语法
class 类名
{
//默认是私有的
	//成员：1 数据 2 函数

//访问权限修饰关键字
public：     //公有的
	//成员：1 数据 2 函数
private：    //私有的
	//成员：1 数据 2 函数
protected： //被保护的
	//成员：1 数据 2 函数
};
```

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps9.jpg) 

##### 代码 2
#代码 #class和struct
```
#include <stdio.h>
#include <iostream>
#include <string.h>
using namespace std;

/*类和结构体之间的联系和区别*/
//类和结构体是两个不同的东西
/*区别：
1.结构体属于C语言，C语言中不能有类
类属于C++，但C++中可以有结构体，
结构体中不允许存在函数，类中可以存在函数
2.在C++语言中，可用class去定义一个类，也可用struct去定义一个类，
在C++中struct不再是单纯的结构体的关键字，可以用来定义一个类，身兼数职。
在C语言中不行，struct结构体中不能有函数
3.一般情况下，如果使用C++，使用面向对象编程思想，
去声明一个类，定义一个类，就用class，因为class声明出来的类是私有的，符合封装性
定义结构体用struct，struct声明出来的类默认是公有的，不具有封装性
*/

struct Name // struct可以声明类，但初学不建议
{
    int num;
    void fun()
    {
    
    }
};

class Sheep //类的内存占多少个内存--内存对齐，与结构体一致
{           //如果这个类中有另一个类的对象就展开再对齐
    int a;  //默认私有的

public:
    char name[32];
  
private:
    int age;
    
public:
    void setAge(int n) //函数是公有的，外部可以访问
    {
        age = n; //赋值给私有变量age
    }
    void eat()
    {
        cout << "闲着没事，吃点草" << endl;
    }
    void speak();

private:
    void speakEnglish()
    {
        cout << "My name is:" << name << ",I am" << age << "." << endl;
    }
};

void Sheep::speak() //不加Sheep::是普通全局变量，加了后指定为类中的函数
{
    cout << "我叫" << name << "，我" << age << "岁了。" << endl;
}

int main()
{
    Sheep xiYY; //对象的定义，‘类’类型+对象名;
    xiYY.eat();
    // xiYY.name="喜羊羊"; 错误的，该name为char型字符数组
    strcpy(xiYY.name, "喜羊羊");
    // xiYY.age=10; 错误的，age是私有属性，不能直接访问
    xiYY.setAge(19); //通过公有成员函数去访问不能直接访问的私有变量
    xiYY.speak();    //访问函数用点号。
    Sheep *py;       /* 这种方法不被允许，语法没错，
           但该指针没有具体指向哪个对象，否则该指针只有4个字节的指针变量 */
    py = &xiYY;      //要先取上某一个对象的首地址，让指针有了指向后才能再去访问
    py->eat();       //指针用箭头->去访问
    py->speak();
}
```

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps10.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps11.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps12.jpg) 

##### Time
[2023-07-03 14:33:26]编写代码

---
#### 4 .String 类


String 是C++中的字符串

类似于C语言中的字符数组

比字符数组高级，其中包括许多方法，使用时需要额外包括
```
<string>
```

##### 代码
#代码 #string类

```cpp
#include <stdio.h>
#include <iostream>
#include <string.h> //C语言中是string.h
#include <string>   //C++的头文件不需要加.h，二者不是一个文件
// C++中是string，C++兼容C，所以用string.h也可以访问到，并不会报错
using namespace std;

class Sheep
{
public:
    char name[32];
    string name_str;
};
  
int main()
{
    string str;
    str = "abc123";   //字符数组中不可以，string中可以
    char ch = str[2]; //直接得到下标为2的字符（c）
    ch = str.at(1);   //得到下标为1的字符（b）
    str.length();     //求string的长度
    // str.clear();//清空字符串，清空string中的内容
    str.empty(); //判断是否为空，是就true，否就false
    str == str;  //直接通过==去对比两个字符串 

    Sheep xiYY;
    xiYY.name_str = "xiYY";
    cout << "My name is:" << xiYY.name_str << endl;
}
```
![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps13.jpg) 
##### Time
[2023-07-04 10:37:29]编写代码
[2023-07-04 11:08:50]重温 String 类

---
## 三、构造函数与析构函数

学习构造析构函数

完成对象数据成员的初始化和清理工作

掌握对象的构造和析构方法

普通构造函数、拷贝构造函数、析构函数

### 01 .普通构造函数

构造函数是一种特殊的成员函数
主要用来在创建对象时初始化对象——为对象的成员变量赋初始值

构造函数名和类名相同
构造函数没有返回值类型，也没有返回值
构造函数可以重载，需要满足函数重载的条件

在创建一个新的对象的时候会自动调用

如果一个类中没有给出构造函数，系统会自动地给出一个构造函数（公有属性）。（有函数名，但参数表为空，函数体也为空（低保））该函数直接在类的里面实现，默认为内联函数，它会通过内存膨胀，牺牲空间去换取时间。
但是如果写了任何一个构造函数，即便没有实现，只是声明了该构造函数，也将无法获得系统自动给出的构造函数。
所以平时写函数尽量先声明（可在类中声明）在类中，而定义（实现）写在类的外面。

有多个构造函数时，系统自动分配的构造函数就没有了

在创建一个新的对象的时候，系统会主动的、自动的帮我们去调用构造函数
如果一个类中没有显式的给出构造函数
系统就会自动地给出一个（无参）构造函数（公有属性）
注：因为创建对象后自动去调用构造函数，此时相当于是在类的外部去访问成员函数，如果是私有属性，无法访问，所以系统给的构造函数是公有属性的。

与函数重载一样，也有二义性。所以我们要尽可能的避免在写函数的时候冲突（不声明/定义 同类名、同参数表的函数）。

构造函数也可以缺省（也可以声明函数某个参数（形参）的时候指定一个**默认值**。）。

Const 在 C 语言中的作用是将一个变量修饰的只有“只读”的属性（只能读取，不能直接修改），变量还是变量，只是具有了“只读”的属性；在 C++中，const 直接改变性质，成为一个常量。
Const 修饰时就必须初始化它。

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps16.jpg) 

Const：这么初始化语法上没有错误，但后续无法进行修改它

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps17.jpg) 

有时数据成员必须初始化，而不能再构造函数中赋值——用成员初始化列表的方式给数据成员赋值。

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps18.jpg) 

成员初始化列表：帮助我们把需要要初始化的内容初始化（如 const 和引用，都可以用这种方法去初始化）

方法：在构造函数的参数列表后面加上冒号：，冒号后接上需要初始化的成员，成员后加上括号（），括号中加入需要赋值的传参（其前后要一致），也可不传参，直接赋常量值。
多个成员初始化列表时，成员之间用逗号隔开。
在成员初始化列表结尾不加分号。

Myclass(类型 变量1):成员1(变量1)，成员2 常量

先声明后定义的构造函数，其照常声明构造函数，声明构造函数的时候不用初始化列表，初始化列表是加在实现该函数的时候
（成员初始化列表写在定义函数的时候，参数表的后面。如果先声明后定义，声明的时候不用写初始化列表，也写在定义后面。）

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps19.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps20.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps21.jpg) 

  
#### 代码
#代码 #普通构造函数
```cpp
#include <stdio.h>
#include <iostream>
#include <string>
using namespace std;
  
class Myclass
{
public:
    int num;
private:
    int val; 
public:
    Myclass() //无参构造函数
    {
        cout << "Myclass()" << endl;
    }
    //构造函数，只要是成员函数都可以声明在类里面，定义在外面
    //系统默认的构造函数：
    /*Myclass()
    {
    }
    */
    /*如果把成员函数的函数体直接实现在类中，
    这个构造函数就默认是一个内联函数，
    通过内存膨胀，牺牲空间去换取时间。
    一般情况下，尽量在类中声明，外面去实现*/
    Myclass(int n, int v) //带参构造函数
    {
        cout << "Myclass(int n,int v)" << endl;
        num = n;
        val = v;
    }
    void setVal(int v);
    int getVal();
};

void Myclass::setVal(int v)
{
    val = v;
}
 
int Myclass::getVal()
{
    return val;
}
  
/*
Myclass::Myclass()//构造函数写在外面
{
}
*/
  
int main()
{
    Myclass obj; //构造函数在创建一个对象的时候会自动帮你去调用
    // obj.Myclass();
    //不能通过对象去调用这个构造函数(我们不能主动的去调用这个构造函数)
    //由系统自动调用这个构造函数，并且是在创建一个新的对象的时候
    obj.num = 0;
    cout << obj.num << endl;
  
    obj.setVal(10);
    cout << obj.getVal() << endl;
}
```
![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps14.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps15.jpg) 
#### Time
[2023-07-04 11:32:14]编写代码
[2023-07-04 23:44:44]重温

---
### 02析构函数

析构函数是一种特殊的函数，其主要作用是在对象生命周期结束时进行清理，系统是可以自动调用析构函数的

C语言和C++中唯一一个函数名不仅仅是合法标识符组成的，函数名包括~这一部分。 函数名与类名相同，在前面加上一个 ~

析构函数没有返回值类型和返回值，也没有参数（参数表必须是空的，但是括号还是要写，只是为空）

析构函数有低保，没写系统会给默认的析构函数

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps22.jpg) 

上图未报错，该图中红圈内未报错，说明这种语法没错，有析构函数~Myclass，系统自动分配了一个低保。具体如下图

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps23.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps24.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps25.jpg) 

析构函数可以主动通过对象调用

析构函数必须是公有属性下
//对象是定义及使用在类外面，其在生命周期结束时调用析构函数，属于类外去调用一个成员函数，所以析构函数是公有属性

在对象生命周期结束时，会自动调用一次析构函数
//如上图，创建对象后运行结果出现了构造函数和析构函数中cout出来的内容，说明创建对象时系统自动调用构造函数，并在对象结束时自动调用析构函数

析构函数不是因为调用了析构函数导致生命周期结束，而是生命周期结束时会自动调用析构函数（注意因果关系）（调析构函数的时候不会释放对象，但是释放对象时系统一定会调析构函数）

任何希望在对象生命周期结束时要做的，都可以写到析构函数中

任何一个类都只有一个析构函数（函数名确定了，参数表无参数，不可能产生重载了）并且肯定会有一个析构函数 

#### 代码
#代码 #析构函数

```cpp
#include <iostream>
using namespace std;
/*实际上Myclass中是这样的//有一个构造、一个析构
class Myclass
{
    public:
        Myclass();
        ~Myclass();

        private:
};
  
Myclass::Myclass()//系统默认的构造函数
{
    cout<<"构造"<<endl;
}

Myclass::~Myclass()//系统默认的析构函数
{
    cout<<"析构"<<endl;
}
*/

class Myclass
{
    public:
        int id;
};
  
int main()
{
    Myclass obj_0;
    obj_0.~Myclass();//没写析构函数的话，系统会自动给默认的析构函数
  
    return 0;

}
```
#### Time
[2023-07-05 00:03:06]编写、重温

---
### ❗03拷贝构造函数

拷贝构造函数是一种特殊的构造函数，通过拷贝构造函数可以完成一个复制过程，从一个对象复制出另一个对象，数据内容一致，注意，对象是两个不同的。

全称：拷贝构造-（构造）函数，不是拷贝（构造）-构造函数

特殊：第一个参数必须是本类的对象的引用：拷贝构造函数的第一个参数是当前这个函数的引用，其他的参数可以不一样

拷贝构造函数先是构造函数，然后才可能是拷贝构造函数

拷贝构造函数有低保：没写系统会自动给，将成员一一对应赋值，也可以自定义

空类中有三个默认的函数——默认的构造函数、默认的析构函数、默认的拷贝构造函数,如图：(注：实际上有很多的“低保”可以吃，但是目前了解的是这三个)

什么情况下会触发拷贝构造函数的调用（拷贝构造函数的调用时机）
调用时机：**注意：网课的编译器不一样，学习调用时机处的代码运行结果显示与自身不一样**
1.使用一个对象给另一个对象进行初始化
同类对象给一个对象初始化的时候会调用（m 2）
2.使用一个对象构造另一个对象
一个对象去构造另一个对象的时候会调用（m 3）
3.函数的参数是类的对象
4.函数的返回值是类的对象
注意：return 的前后属于函数体内外。函数体内的要拷贝构造一份复制体使用然后释放自己，函数体外部的则无需拷贝，直接使用。拷贝后传过去的复制体如果在后续没有使用，则也会释放自己。

先进来创建一个对象调用无参构造，然后返回的时候它本身（obj）必定被释放。此时通过复制体返回出去，所以说返回值返回的是复制体而不是它本身。所以 return obj; 处会调用一次拷贝构造。
掉完拷贝构造之后，马上就会结束这个函数体就过来了（来到 main 主函数），于是 obj 此时就要被释放，释放就要调用一次析构。
完毕后，此时 main 主函数这边返回复制体出来了，复制体既然返回出来了，那么这里就有了一个复制体，马上主函数结束。主函数结束之后，这个复制体返回出来的复制体也会被释放掉，所以也会调用析构一次。
更精确的描述：复制体返回出来后，在第（76 行），没有任何一个当前类的对象去接收你的这个复制体。于是就会在这一行直接释放掉。如果后面还有其他的语句在执行，在执行后面的其他语句之前，这个复制体在这种写法的情况下，它已经释放掉了。
但是如果是 Monster monster=test_func_2 (); 这种写法下，有东西去接收它（obj 的复制体）

深拷贝与浅拷贝
浅拷贝：默认的都是浅拷贝（它属于是一一对应赋值）——好比考试时无脑抄袭
深拷贝：需要自己根据实际情况实现（有点脑子）——好比考试时该抄的地方抄，不该抄的谨慎（就像别人的学号、名字别抄过来了（指针问题））

怎么防止默认拷贝发生？（防不胜防）
我们可以主动让程序报错（主动报错更好去发现和修改）
在一个类中如果声明了指针，但是没有定义，在没调用这个函数的情况下，它不会有问题。
但凡调用了，有声明，没定义的话，就会报错。
所以我们可以声明一个私有的拷贝构造函数，但是不对它进行定义（<font color="#ff0000">私有的、不定义</font>），没有函数体。那么只要出现了拷贝构造，首先你写了一个自己的声明的拷贝构造，那么就不会有低保了。如果需要调用这个拷贝构造，首先它是私有的，访问不到。其次没有函数体，会告诉我们未定义。（双重保险）让我们只要调用了拷贝构造，我们就会发现，再进行调整。

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps26.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps27.jpg) 

![](../../annex/0.C++总集_image_5.png)

![[../../annex/0.C++总集_image_6.png]]

![[../../annex/0.C++总集_image_7.png]]

![[../../annex/0.C++总集_image_8.png]]

在 return 后面的叫匿名对象。
![[../../annex/0.C++总集_image_9.png]]

指针再拷贝构造函数中的问题
![[../../annex/0.C++总集_image_10.png]]
![[../../annex/0.C++总集_image_11.png]]
![[../../annex/0.C++总集_image_12.png]]
![[../../annex/0.C++总集_image_13.png]]

#### 代码 1--基础拷贝构造函数认知
#代码 #拷贝构造函数

```cpp
#include <iostream>
using namespace std;
#include <string>

class Monster
{
public:
    string m_name;
    int m_hp;
    float m_speed;

public:
    Monster();
    Monster(char *name, int hp, float speed);
    Monster(Monster &obj);
    Monster(Monster &obj, int val); //重载一个拷贝构造
    ~Monster();
    
    void showData(); //声明一个对象去显示数据 
    
private:

};
  
Monster::Monster()
{
    cout << "无参构造" << endl; //
    m_name = "名字";
    m_hp = 100;
    m_speed = 10.0f;

}
  
Monster::Monster(char *name, int hp, float speed)
{
    cout << "带参构造" << endl; //
    m_name = name;
    m_hp = hp;
    m_speed = speed;
}

  

Monster::Monster(Monster &obj) //默认的拷贝构造，有什么就抄一份
{
    cout << "默认的拷贝构造(1号)" << endl; //
    m_name = obj.m_name;
    m_hp = obj.m_hp;
    m_speed = obj.m_speed;
}

//拷贝构造函数重载，一般不这么用，只用上面那种默认的
Monster::Monster(Monster &obj, int val)
{
    cout << "拷贝构造2号" << endl; //
    m_name = obj.m_name;
    m_hp = val; //用val来取代血量
    m_speed = obj.m_speed;
}
 
/*
析构函数中什么都不做，因为成员都可以被系统自动释放
什么时候用做：比如说有一个成员申请了堆区的内存，申请了要释放，就写到析构函数中
这样就不存在忘记释放内容，因为写到析构函数中去后，任何一个对象在生命周期结束的时候系统都会自动的调用这个析构函数，肯定就不会忘记释放堆区的内存
*/

Monster::~Monster()
{
    cout << "析构函数" << endl; //
}

void Monster::showData()
{
    cout << "角色名称:" << m_name << endl;
    cout << "当前血量:" << m_hp << endl;
    cout << "移动速度:" << m_speed << endl;
    cout << "***********" << endl<< endl;
}

int main()
{
    Monster m0;                       //没带参数，调用无参构造
    Monster m1("皮卡丘", 120, 10.0f); //调用带参构造函数
    Monster m2 = m0;                  //调用默认的拷贝构造函数（1号）
    //调用时机：同类对象给一个对象初始化的时候会调用（m 2）
    Monster m3(m0);                   //与m2一样，都是调用拷贝构造1号，写法不同
    //调用时机：一个对象去构造另一个对象的时候会调用
    Monster m4(m1, 180);              // m4掉拷贝构造函数2号
  
    Monster *p = new Monster; //无参数，调用无参构造
    //不会自动释放，因为是堆区的。不还就不会收
    //以上掉用了六次构造，却只有五次析构
    //    delete p;
    //    p = NULL;//哪里释放内存就在哪里析构，所以会在下面几条代码之前执行
  
    m0.showData();
    m1.showData();
    m2.showData();
    m3.showData();
    m4.showData();
    p->showData(); //默认的无参构造
    //上面delete后此处p->showData();就不能用了
    
    //哪一个先调用构造函数，哪一个就最后再析构(先构造的后析构)
    //如这里先析构的是m4，因为m4最后构造出来的
    //堆区不在考虑范围之内，堆区的(析构)释放由自己决定
    return 0;

}
```
#### 代码 2--调用时机
#代码 #拷贝构造函数 

```cpp
#include <iostream>
using namespace std;
#include <string>

class Monster
{
public:
    string m_name;
    int m_hp;
    float m_speed;
  
public:
    Monster();
    Monster(char *name, int hp, float speed);
    Monster(Monster &obj);
    Monster(Monster &obj, int val); //重载一个拷贝构造
    ~Monster();
 
    void showData(); //声明一个对象去显示数据  
private:

};

//---前面与上一节代码同样。下面为调用时机



//在全局区来添加一个普通的全局函数
// 3.函数的参数是类的对象
void test_func_1(Monster obj)
{
    //只要它参数是类的对象，函数体不写也没事
}

// 4.函数的返回值是类的对象
Monster test_func_2() //返回值类型是类的类型（此处为Monster）
{
    Monster obj; //先在里面创建一个这样的对象
//  Monster obj();//带参构造的话也可以传参数
    return obj;  //然后把这个对象返回出去
}  

Monster test_func_3() //返回值类型是类的类型（此处为Monster）
{
    return Monster();//这个叫匿名对象(就是没有名字的一个对象)。此处创建匿名对象。
} 

int main()
{
//    Monster m0;                       //没带参数，调用无参构造
//    Monster m1("皮卡丘", 120, 10.0f); //调用带参构造函数  
//   test_func_1(m1); //调用函数，参数传类的对象。实参的值拷贝给形参
    //把m1传给obj的时候去调用的(结果显示：默认的拷贝构造(1号))
    //三个析构。第一个析构是test的，第二个是m1的，第三个是m0的
    /*构造和析构函数的调用顺序的问题
    因为test_func_1这个函数调用完毕之后才会回到主调函数，
    回到主调函数来的时候test_func_1结束了，
    test函数的参数表中的obj也就结束了生命周期了，
    所以它要先释放，所以要先析构
    回来后才会结束这个主函数main，结束这个主函数的时候就结束m0，m1的生命周期
    那么就形成了先构造的后析构
    */
//    test_func_2();//调用该函数时就无需传参数了。//像这种没有东西去接收这个复制体的话，那么系统就会给你创建一个看不见摸不着的
//    对象。(在test_func_2外面创建一个对象)，然后把obj拷贝给外面这个不知名对象。
//    Monster monster=test_func_2(); //返回出去，在此处接收的其实不是obj，因为obj在这个test_func_2中已经被释放掉了
//    而如果有一个对象去接收这个复制体的话，系统会直接把obj复制给对象(monster)，所以这种有对象接收的就不会再额外调用拷贝构造了
    test_func_2();//拷贝出去的这一份就在函数的调用的地方返回出去了
    //所以return obj;实际上返回出去的是obj的复制体。既然要返回出去，则要拷贝一份出去
    /*首先从主调函数进入被调函数，该过程无参数，所以不存在调用别的函数
    接下来执行函数体，
    执行函数体时需要定义一个object，在此处object属于无参构造(函数体内第一段代码Monster obj;)
    返回的时候object作为一个栈区的对象，是不会被直接返回出去的
    类似这样的栈区对象，它会在这个函数体结束的时候就会被系统自动回收内存，它就没了。
    既然它在这个函数里面没了，就必不可能被返回出去*/  
    
    /*
    先进来创建一个对象调用无参构造，然后返回的时候它本身（obj）必定被释放。此时通过复制体返回出去，所以说返回值返回的是复制体而不是它本身。所以 return obj; 处会调用一次拷贝构造。
    掉完拷贝构造之后，马上就会结束这个函数体就过来了（来到 main 主函数），于是 obj 此时就要被释放，释放就要调用一次析构。
    完毕后，此时 main 主函数这边返回复制体出来了，复制体既然返回出来了，那么这里就有了一个复制体，马上主函数结束。主函数结束之后，这个复制体返回出来的复制体也会被释放掉，所以也会调用析构一次。
    更精确的描述：复制体返回出来后，在第（76 行），没有任何一个当前类的对象去接收你的这个复制体。于是就会在这一行直接释放掉。如果后面还有其他的语句在执行，在执行后面的其他语句之前，这个复制体在这种写法的情况下，它已经释放掉了。
    */

    Monster monster = test_func_2(); 
    
    test_func_3(); // return 匿名对象; 此时结果显示无参构造且析构。
    /*为什么可以直接无参构造且析构，没有拷贝构造了？
    因为以return语句为界线，以它为一个分界点。
    return后面的可以认为是函数外面的。
    所以此处在return后面去创建各种东西不用再去拷贝了。
    即，如果是返回函数里面的东西，则要拷贝出来。
    而如果是函数外部的(return后面的)则无需拷贝构造了。
    */
    Monster monster = test_func_3();/*如果是用一个对象去接收它也是同理，
    不会去额外的调用拷贝构造，而是直接把创建的东西直接给到对象(monster)*/

    return 0;

}
```


#### 代码 3--深浅拷贝
#代码 #拷贝构造函数 


```cpp
// 1.在默认构造里面给指针p制空
// 2.在带参构造里面给指针p = new int[10];
// 3.默认的拷贝构造中的问题--指针指向同一个地方
// 4.给你的这个新对象重新开辟一段内存，并且让它重新指向这里
// 5.怎么防止默认拷贝构造的发生

#include <iostream>
using namespace std;
#include <string>
class Monster
{
public:
    string m_name;
    int m_hp;
    float m_speed;
    int *p;
  
public:
    Monster();
    Monster(char *name, int hp, float speed);
    Monster(Monster &obj);
    Monster(Monster &obj, int val); //重载一个拷贝构造
    ~Monster();

    void showData(); //声明一个对象去显示数据
 
private:

}; 
  
//在默认构造里面给指针p制空
Monster::Monster()
{
    cout << "无参构造" << endl; //
    m_name = "名字";
    m_hp = 100;
    m_speed = 10.0f;
    p = NULL;
}

//在带参构造里面给指针p = new int[10];
Monster::Monster(char *name, int hp, float speed)
{
    cout << "带参构造" << endl; //
    m_name = name;
    m_hp = hp;
    m_speed = speed;
    p = new int[10];
}
  
//默认的拷贝构造中的问题--指针指向同一个地方
Monster::Monster(Monster &obj) //默认的拷贝构造，有什么就抄一份
{
    cout << "默认的拷贝构造(1号)" << endl; //低保构造
    m_name = obj.m_name;
    m_hp = obj.m_hp;
    m_speed = obj.m_speed;
//    p = obj.p;这种情况不对，指针不能这么用。两个指针指向同一个地方
    /*低保构造还是这样去给。即一一对应赋值。但是这样并没有什么含义，这样给它是会有问题的。
    这样两个指针是给过去指向(把指向给过去了)。这样有问题。
    两个对象的指针都是指向同一块内存。
    所以像这样有指针的情况就不能这样去指向。
    那就应该给你的这个新对象重新开辟一段内存，并且让它重新指向这里。*/
}

//拷贝构造函数重载，一般不这么用，只用上面那种默认的
//给你的这个新对象重新开辟一段内存，并且让它重新指向这里
Monster::Monster(Monster &obj, int val)
{
    cout << "拷贝构造2号" << endl;
    m_name = obj.m_name;
    m_hp = val; //用val来取代血量
    m_speed = obj.m_speed;
    p = new int[10];//先自行申请一段新的内存
    for (size_t i = 0;i<10;i++)//因为内存为10，所以用一个for循环
    {
        p[i] = obj.p[i];//如果只有一个直接拿过去即可，就无需for循环
        //*(p + i) = *(obj.p + i);//两种写法均可
    }
    //申请完后，你可以把这张内存里面的数据拷贝过来，不能指针指过去
}
  
/*
析构函数中什么都不做，因为成员都可以被系统自动释放
什么时候用做：比如说有一个成员申请了堆区的内存，申请了要释放，就写到析构函数中
这样就不存在忘记释放内容，因为写到析构函数中去后，任何一个对象在生命周期结束的时候系统都会自动的调用这个析构函数，肯定就不会忘记释放堆区的内存
*/

//在析构函数中delete指针，且把指针制空。要用if语句先确认后释放。
Monster::~Monster()
{
    cout << "析构函数" << endl; //
    if(p!=NULL)//要先确定指针是否为空，如果已经为空是不能够重复delete的。先确认，再释放
    {
        delete p;
        p = NULL;
    }  
}
  
void Monster::showData()
{
    cout << "角色名称:" << m_name << endl;
    cout << "当前血量:" << m_hp << endl;
    cout << "移动速度:" << m_speed << endl;
    cout << "***********" << endl << endl;
}
  
int main()
{
    Monster m0;                       //没带参数，调用无参构造
    Monster m1("皮卡丘", 120, 10.0f); //调用带参构造函数
    Monster m2 = m0;                  //调用默认的拷贝构造函数（1号）
    //调用时机：同类对象给一个对象初始化的时候会调用（m2）
    Monster m3(m0); //与m2一样，都是调用拷贝构造1号，写法不同
    //调用时机：一个对象去构造另一个对象的时候会调用
    Monster m4(m1, 180); // m4掉拷贝构造函数2号  
    Monster *p = new Monster; //无参数，调用无参构造
    //不会自动释放，因为是堆区的。不还就不会收
    //以上掉用了六次构造，却只有五次析构
    //    delete p;
    //    p = NULL;//哪里释放内存就在哪里析构，所以会在下面几条代码之前执行

    m0.showData();
    m1.showData();
    m2.showData();
    m3.showData();
    m4.showData();
    p->showData(); //默认的无参构造
    //上面delete后此处p->showData();就不能用了 
    //哪一个先调用构造函数，哪一个就最后再析构(先构造的后析构)
    //如这里先析构的是m4，因为m4最后构造出来的
    //堆区不在考虑范围之内，堆区的(析构)释放由自己决定
    return 0;
}

/*怎么防止默认拷贝发生？（防不胜防）
我们可以主动让程序报错（主动报错更好去发现和修改）
在一个类中如果声明了指针，但是没有定义，在没调用这个函数的情况下，它不会有问题。
但凡调用了，有声明，没定义的话，就会报错。
所以我们可以声明一个私有的拷贝构造函数，但是不对它进行定义（<font color="#ff0000">私有的、不定义</font>），没有函数体。那么只要出现了拷贝构造，首先你写了一个自己的声明的拷贝构造，那么就不会有低保了。如果需要调用这个拷贝构造，首先它是私有的，访问不到。其次没有函数体，会告诉我们未定义。（双重保险）让我们只要调用了拷贝构造，我们就会发现，再进行调整。*/
```

#### Time
[2023-07-02 18:31:41]~[2023-07-02 18:55:50] 重温+检索 GitHub:luc_github:
[2023-07-05 23:17:49]重温拷贝构造函数的基本认知，并学习调用时机和深浅拷贝

---

## 四、一些特殊情况
![[../../annex/0.C++总集_image_14.png]]
掌握类中的特殊成员——可能是数据成员，也可能是成员函数
**掌握友元关系**
掌握单例模式

![[../../annex/0.C++总集_image_15.png]]
四大模块：
this 指针
**static 成员**（**静态成员**）可能是成员函数，可能是数据成员（可能是属性，也可能是行为）
const 成员（常量成员）可能是成员函数，可能是数据成员（可能是属性，也可能是行为）
friend

### 1 .this 指针

this 指针是系统自动生成的，且隐藏的（低保）。自己也不能去定义这么一个指针，但是可以使用
this 指针不是对象的一部分，作用域在类的内部（属于类中，不会属于任何对象）
类的普通函数访问类的普通成员时，this 指针总是指向调用者对象。
this 指针存放在普通成员函数里面（所有普通成员函数中都会有 this 指针），而指针指向就看谁去调用这个成员函数，它就会指向谁。
普通数据成员是每个对象都有单独的一份，而成员函数整个类都只有一份，即函数是公用的，但是对象是不同的。用的时候哪个对象需要去调用这个成员函数，就归哪个对象在调用

![[../../annex/0.C++总集_image_16.png]]

如何区分自己的成员和同名的参数
用 this 指针来区分


#### 代码
#代码 #this指针

```cpp
#include <iostream>
using namespace std; 

class MyClass
{
    int num;  

public:
    //    void setNum(int n)
    //    {
    //        num = n;
    //    }
    //区分成员和同名的参数
    // this指针不能改指向，本身是常量(MyClass *this)(默认且隐藏)在参数表中 

    void setNum(int num)
    {
        //      num = num;
        this->num = num;
    }
    int getNum()
    {
        return num;
        // return this->num;
    }
    /*
    MyClass getThis()
    {
        return *this;
    }  
    MyClass* getThisP()
    {
        return this;
    }
    */
};
  
int main()
{
    MyClass obj_1;
    obj_1.setNum(10);
    //↑ obj_1.setNum(&obj_1,10);每一次调用的时候其实就相当于是自己把这个对象去取首地址传过去
    cout << "num=" << obj_1.getNum() << endl;
}
```


#### Time
[2023-07-07 11:22:59]编写代码、学习指针

---

### 2.static 成员
Static：静态
在 C++类中声明成员时，加上 static 关键字
静态的寿命比较长
静态成员分为静态数据成员和静态函数成员
#### 静态数据成员
普通的静态成员变量存储在静态全局区，它的声明周期是从程序开始到结束
静态的成员是不能够用初始化列表的
所有类的对象共享同一个静态成员的内存空间 (类不管有多少个对象，都共用同一个静态成员的内存空间)
静态成员只存在于类中，对于单独的某一个对象来说，是没有这一份内存的。

![[../../annex/0.C++总集_image_17.png]]

静态成员的寿命比类都要长，自然也比对象的寿命要长
静态成员属于类，而不属于对象。对象共用，所以可以直接类名+作用域符访问到静态成员（num），其他的类型的成员访问不到（如直接 int val，无法直接访问到）。即：只有静态成员才可以直接用类名+作用域符的形式去访问到。

#### 静态成员函数
静态成员函数只须在声明的时候加上 static，在实现的时候无需加上。
写成内联的，实现在类里面，也可以。（直接在类中声明且实现）（总之 static 只须写在类中，类的外面，无论是数据成员还是成员函数都无需加上 static 了）
任何需要依靠对象存在的东西都不能出现在静态函数里面（包括普通数据成员、this 指针、普通函数等）

#### 单例模式
单例模式：设计模式。是解决一类问题的通用的方法/思维模式
最基础要求：创建一个只能实例化一个对象的类
怎样让一个类只能创建一个对象，要从构造函数的角度去限制，创建对象是必然要去调用构造函数的。
如果我们把一个类的构造函数进行一波限制，让它只能创建一个对象，就能满足我们的要求了。

我们也不能直接去限制一个函数的调用次数。（C++中做不到）。
但是我们可以让构造函数在其他地方调用不了。（把构造函数写出私有的），在外面调用不了，这样一来在所有地方（类的外面）就都调用不了这个函数，那就不能创建对象了。
既然我们这样在类的外部不能创建一个对象，那我们就可以在类的内部创建一个对象，然后写一些条件判断，让他只要创建了对象，就不再去调用这个函数就好了。

#### 代码 1--静态数据成员
#代码 #static成员

```cpp
#include <iostream>
using namespace std;

class ClassName
{
public:
    ClassName();
    ~ClassName();

    static int num;
};
int ClassName::num = 0;
  
ClassName::ClassName()
{
    // num = 0;//只要创建对象就会调构造函数，调构造函数就会使num=0，
    //那么这个成员之前所记载的数据只要创建一个对象就被清空为0，这种做法不合适
}
  
ClassName::~ClassName()
{
}

int main()
{
    ClassName obj_1;
    cout << "obj_1.num=" << obj_1.num << endl; //输出:0
  
    obj_1.num = 10; 

    ClassName obj_2;
    cout << "obj_2.num=" << obj_2.num << endl; //输出：10
    // obj_1.num的值0改为10，而obj_2.num的值变成了10，
    //第一个对象的值改动后影响到了第二个对象的值，这就说明了大家用的是同一份内存。

    cout << "sizeof(obj_1)=" << sizeof(obj_1) << endl; // 1个字节
    // static int num应该是4个字节，它不属于obj_1的对象，同理不属于obj_2
    //也就是说这个num不存在于任何一个对象里面，它存在于类中

    cout << "sizeof(ClassName)=" << sizeof(ClassName) << endl; // 1个字节
    //类型是不能够求字节数，类名属于类型，此处这样求，实际上是悄悄的创建了一个这种类型的对象。

    return 0;

}
```

#### 代码 2--静态成员函数
#代码 #static成员

```cpp
#include <iostream>
using namespace std;

class ClassName
{
public:
    ClassName();
    ~ClassName();
  
    int val; // 其他的类型的成员访问不到（如直接 int val，无法直接访问到）。

    void test()
    {
        val;
    }

    static int num;  
    
    static void testFun_1();
    
    static void testFun_2()//类中声明并实现
    {
        // val;无法访问普通数据成员
        // this->val;无法调用this指针
        // test();无法调用普通成员函数，防止通过普通函数去访问到普通成员，所以统统禁止。
        cout << "testFun_2" << endl;
    }
};

int ClassName::num = 0;
  
void ClassName::testFun_1()//类中声明，类外实现，static只须写在类中
{
    cout << "ClassName::testFun_1" << endl;
}  

ClassName::ClassName()
{
    // num = 0;//只要创建对象就会调构造函数，调构造函数就会使num=0，
    //那么这个成员之前所记载的数据只要创建一个对象就被清空为0，这种做法不合适
    num++;//可以用来记数，每创建一个对象就+1，可以统计创建了几个对象
}  

ClassName::~ClassName()
{

}
  
int main()
{
    ClassName obj_1;
    cout << "obj_1.num=" << obj_1.num << endl; //输出:0
    
    obj_1.num = 10;
 
    ClassName obj_2;
    cout << "obj_2.num=" << obj_2.num << endl; //输出：10
    // obj_1.num的值0改为10，而obj_2.num的值变成了10，
    //第一个对象的值改动后影响到了第二个对象的值，这就说明了大家用的是同一份内存。 

    cout << "sizeof(obj_1)=" << sizeof(obj_1) << endl; // 1个字节
    // static int num应该是4个字节，它不属于obj_1的对象，同理不属于obj_2
    //也就是说这个num不存在于任何一个对象里面，它存在于类中 

    cout << "sizeof(ClassName)=" << sizeof(ClassName) << endl; // 1个字节
    //类型是不能够求字节数，类名属于类型，此处这样求，实际上是悄悄的创建了一个这种类型的对象。 
    
    ClassName::num;
    // 静态成员的寿命比类都要长，自然也比对象的寿命要长
    // 静态成员属于类，而不属于对象。对象共用，所以可以直接类名 + 作用域符访问到静态成员（num）
    // ClassName::val;
    // 其他的类型的成员访问不到（如直接 int val，无法直接访问到）。  

    obj_2.testFun_1();
    (&obj_1)->testFun_2();//取首地址就是一个指针
    // ClassName *p = &obj_1;
    // p->testFun_2();
  
    ClassName::num;//可以用类名直接访问到这样的(static)成员
    ClassName::testFun_1();//可以用类名直接访问到这样的（static）函数
    ClassName::testFun_2();//可以没创建任何对象的情况下去访问这些东西
    //在静态函数中是不能够去访问这些普通的数据成员（int val;）甚至this指针也没有
    //普通的数据成员、this指针，都是要先有对象后，才会从传参过来。
    //而调用这些静态成员时却连对象都不需要有。
 
    return 0;

}
```


#### 代码 3--单例模式举例

```cpp
#include <iostream>
using namespace std; 
//单例模式：设计模式
/*
最基础要求：创建一个只能实例化一个对象的类

怎样让一个类只能创建一个对象，要从构造函数的角度去限制，创建对象是必须要去调用构造函数的  

核心思路：
如果我们把一个类的构造函数进行一波限制，让它只能创建一个对象，就能满足我们的要求了。  
我们也不能直接去限制一个函数的调用次数。（C++中做不到），我们只是让构造函数在其他地方调用不了
简单来说就是把构造函数写成私有的。在外面调用不了，这样一来在所有地方（类的外面）就都调用不了这个函数，那就不能创建对象了。
既然我们这样在类的外部不能创建对象，那我们就可以在类的内部创建一个对象，然后写一些条件判断，让他只要创建了对象，就不再去调用这个函数就好了。
*/  

//具体写法：
/*
先创建类、析构函数、构造函数
第一步先想办法把构造函数写成私有的（只要写成私有的了，这个类在外面就不能创建对象了）
    当然，为了防止防止一些问题，我们把拷贝构造，所以我们把拷贝构造也写成私有的。不能创建也不能拷贝（复制对象）。
我们总要实现些东西——通过static
我们首先先在私有成员这一块，搞一个当前这个类的这个类型的指针
然后通过对指针在构造函数中进行操作......
这些都完成后其实实际上就是实现了这个所谓的单例模式
在类的外面去使用的时候，就只需要调这个getInstance，那么你就能够得到当前类类型的这么一个指针
 */
class SingleInstance
{
    public:
        // SingleInstance();
        ~SingleInstance();
        static SingleInstance *getInstance();//静态修饰的，返回值类型是当前类类型指针的这么一个函数
  
    private:
        SingleInstance();
        SingleInstance(const SingleInstance& obj);
        static SingleInstance *pInstance; //修饰为static，我们首先先在私有成员这一块，搞一个当前这个类的这个类型的指针，静态的指针也是静态的数据成员，那就只能在静态成员函数里面访问
    public:
        int num;//把基本的要求实现之后，如果说有一些数据需要用它，那么这些就可以去用了。
};

SingleInstance *SingleInstance::pInstance = NULL;//简单制个空 

SingleInstance::SingleInstance()
{
    num = 0;//一开始创建的时候，在构造函数里面，还是可以给这些num初值什么的都可以。
}
  
/* SingleInstance::SingleInstance(const SingleInstance& obj);
{  
} */
 
SingleInstance::~SingleInstance()
{  
}  

//我们在实现这个函数时的状态是成员函数
SingleInstance* SingleInstance::getInstance()
{
    // SingleInstance();//成员函数里面可以去访问当前这个类的构造函数
    if(pInstance==NULL)//申请内存的时候给判断一下，如果指针为空就去申请,如果不为空则什么都不做，保持原指向即可
    {
    pInstance = new SingleInstance; //给静态指针一个指向,new一个当前这个类的对象，给他申请出来内存
    }
    //当然，这里有返回值，不管这么样，我们都需要把这个指针给他返回出去
    return pInstance;//其实就是返回它的指向
}  

int main()
{
    SingleInstance::getInstance();//在类外我们可以直接通过类名去访问这个static函数，返回值是声明时那种类型的指针
    
    SingleInstance *p1 = SingleInstance::getInstance();//在类外面去使用时，就只需要调用这个getInstance，那么你就能够得到一个当前类类型的这么一个指针，不管这个东西去使用多少次，都是一样的
    cout << "num=" << p1->num << endl;//然后通过p1去创建出来，然后输出普通的数据成员num（p1->num）的状态。（一开始多少）
    SingleInstance *p2 = SingleInstance::getInstance();
    p2->num = 99; //然后我们可以通过p2把num给个值，如99（改一下num的值）
    SingleInstance *p3 = SingleInstance::getInstance();
    cout << "num=" << p3->num << endl; //然后通过p3把它输出出来（输出改后的状态）。结果说明这三个指针确实指向同一个对象。任何一个指针对它（num）的操作大家都可以看得到。这样一种情况就适合在你的程序里面的一些所谓的管理者的时候去使用这些东西（只需要一份的时候）。因为任何一个程序，都可能会有叫做权限最高的这么一个管理，用它可以去纵观整个程序的全局（可以看到所有东西） 

    cout << hex << p1 << endl; // hex表示要输出16进制，理由：因为我要看这几个指针是不是相同的
    cout << hex << p2 << endl;
    cout << hex << p3 << endl; //执行起来发现，指针都是一样的（结果显示都是0xf66620），但我确确实实的调用了这个函数三次    （SingleInstance *p2 = SingleInstance::getInstance();）。这是因为只要这个对象在这里创建过了不为空的指针，初始化的时候给的为空，只要创建的时候创建成功了，他就不会为空，不会为空就不会进这个if，不进if就一直都是原来这一个对象。这就是所谓的单例模式。 

    return 0;
}
```

#### Time
[2023-07-09 15:59:52]、[2023-07-09 18:16:43]编写代码、学习 static

---

### 3.const 成员

在 C++类中声明对象成员时加上 const 关键字

常量成员分为<font color="#ff0000">常量数据成员</font>和<font color="#ff0000">常量函数成员</font>。

this 的作用域范围是这个类里面（类的大括号里面以及函数的大括号里面）


#### 代码
#代码 #const成员

```cpp
/*
obj_1~obj_3是常量数据成员，obj_4是常量成员函数，obj_5，obj_6是常量对象
作用：
const 防止我们对数据进行修改
比如说我们有一个私有的private数据成员，我们想把它保护起来，所以写成了私有的进行封装
但是有时候在外面需要拿出来看一下怎么办》->那么就在这个函数里面加上const。就只能看，无法修改
特例：静态成员可以在const中修改。静态成员是公有的，普通数据成员是自己有的。(从生命周期来思考)
 */
#include <iostream>
using namespace std; 

class ClassName{
public:
    ClassName();
    ClassName(int v);//也可去重载这个构造函数
    ClassName(int v, int num);
    ~ClassName();
  
    int num;
    // const int val = 0;//这种写法是不允许的。不这样写。即便语法上允许，但是这么做不合适
    //不能这么给值，但是又想要给值，怎么办？当然是用成员初始化列表，写法：
    //在这个构造函数后面给个冒号，然后把需要初始化的东西（注意：静态的不能在这里写）
    const int val;
    static int n;  

    void test_func1()//普通成员函数
    {
        cout << "test_func1()" << endl;
        cout << "val=" << val << endl;//普通的成员函数里面是可以访问这个常量成员的
        cout << "num=" << num << endl;
    }//也可以在里面声明，外面定义  

    void test_func2() const//常(量)成员函数的const是加在函数参数表后面
    {
        cout << "test_func2()" << endl;
        cout << "val=" << val << endl; //普通的成员函数里面是可以访问这个常量成员的
        cout << "num=" << num << endl;
        // val=0;无法修改
        // num=0;普通成员也无法修改， 也就是说在常（量）成员函数中是不能够去修改任何的这个数据成员的值的
        //语法规定：常量成员函数不能够对当前这个类的任何的数据成员进行修改。也就是说，你这个类中任何只要能够通过this指针指出来的东西在这里面都改不了。但是可以访问(如上面cout)，这样的做的目的是只要函数加上了const，那么在当前的函数体中就不能修改自己的任何成员
        // this->num=0;//无法修改
        n = 10;//n可以直接修改
        this->n = 99;//this指针也可以访问到
    } //也可以在里面声明，外面定义  

    void test_func3() const;//先声明，后实现
};
int ClassName::n = 0;//在类外进行实现一下，给静态成员一个初始值

void ClassName::test_func3() const //注意：实现的时候const不能丢掉。类的外面实现const函数的时候，const不能丢掉，因为const是整个函数的一部分
{
    cout << "test_func3()" << endl;
    cout << "val=" << val << endl;
    cout << "num=" << num << endl;
}//先声明，后实现
  
ClassName::ClassName() : val(0)//给一个默认值
{  
}

//使用成员初始化列表对非静态成员进行一个初始化(不一定是常量成员，不是常量成员也可。但是常量成员必须要用成员初始化列表去初始化)
ClassName::ClassName(int v) : val(v)//相当于重载了 一个构造函数
{
}

ClassName::ClassName(int v, int num) : val(v), num(num) //外面的自己的，里面的是参数，this 的作用域范围是这个类里面（类的大括号里面以及函数的大括号里面）.this-> num(n)报错,因为参数表的位置不在函数里面也不是在类里面。但是还是可以区分开来两个同名的东西——括号里面的就是参数，括号外面的就是自己的成员
{
}
  
ClassName::~ClassName()
{
}
  
int main()
{
    ClassName obj_1;
    cout << "obj_1.val=" << obj_1.val << endl;
  
    ClassName obj_2;//对象共用const成员
    cout << "obj_2.val=" << obj_2.val << endl;//所有对象，只要是同一个成员就都是同一个值
    // obj_2 = 10; //不允许被修改，因为为常量  
    
    ClassName obj_3(6);//调用的是只有一个参数的重载
    cout << "obj_3.val=" << obj_3.val << endl;//输出结果为6
    // obj_3.val = 9;//一样还是改不了，但是输出的val不再是0了，可以通过传参数对它进行初始化了
  
    ClassName obj_4(9,8);//val得到9,num得到8
    obj_4.test_func1();//直接去调用
    obj_4.test_func2();
    obj_4.test_func3();  
    
    //常对象的任何普通数据成员都改不了，但是静态的还是可以改一下
    //常对象只能调用const成员函数，常对象只能调用常成员函数，并且所有的数据成员都不能够通过常对象本身去修改，静态成员不属于这个对象，所以就能修改
    const ClassName obj_5(3,4);//常（量）对象
    // obj_5.num = 0;//无法修改，既然const修饰了对象，则常对象的任何成员都改不了
    obj_5.n = 0;//静态的成员可以修改，不受const影响。
    //常成员函数本来就不能够去修改它的数据成员，所以说能调用，至于这个普通的成员函数，它有可能去修改你的普通的数据成员，为了不被修改，（谁也无法保证你在这样的普通成员里会不会修改你的普通数据成员），所以常对象就一刀切，但凡是普通成员函数有这个修改风险的（有这个可能性的），统统干掉，不让我们去调用.即为了保证它不被修改，把有可能修改的函数直接不让我们去调用
    // obj_5.test_func1();//常对象不能调用普通成员函数
    obj_5.test_func2();//可以调用常函数   

    ClassName const obj_6(5,7);//这样也能const
    obj_6.n = 0;//静态成员还是可以修改
    // obj_6.num = 9;//一样的，也改不了
    
    return 0;

}
```

#### Time
[2023-07-14 17:10:52]编写代码、学习 const 成员

---

### 4.友元关系
友元实际上是两者之间的一个关系

类的特性之一是封装，友元是打破封装的手段

友元分为友元函数和友元类

友元类可以创建友元对象
友元类：除 A 外还有别的类，A 把 B 当成朋友，把自己有的给它用，但是 B 的自己不一定可以用（你把他当朋友，他把你当傻狗）

友元函数本质上是一个普普通通的函数

![[../../annex/0.C++总集_image_18.png]]

单方向：A 把 B 当好朋友，B 可以用 A 的所有，A 却无法用 B 的成员（一厢情愿）（单方向的）
![[../../annex/0.C++总集_image_19.png]]

不传递：A 把 B 当好朋友，B 把 C 当好朋友，A 和 C 之间不存在传递的友元关系（不传递）（不会默认传递，但是自己可以去声明一下）
![[../../annex/0.C++总集_image_20.png]]

不继承：当前这个类有友元关系，这个友元关系不会继承到子类中去：你爸爸的朋友不是你的朋友

#### 代码 1--友元函数
#代码 #友元关系

```cpp
#include <iostream>
using namespace std;

class A
{
    int num;                        //直接写的成员，默认是私有的。
    friend void test_Func_1(A obj); //友元的声明，可以写在public/private/protect，只要是在类中这样声明的就是友元。friend友元关键字,把哪个函数当朋友就把哪个函数的函数头放过来//A类把test_Func_1当成好朋友,此时test_Func_1函数中的obj.num就可以用了。
public:
    A() { num = 0; } //写一个A类的共有的构造函数,在A类中给num=0（给个初始化值）
};
  
void test_Func_1(A obj) //普通全局函数，友元并不是把这个函数变成它的成员函数，而是在类中先friend
{
    obj.num = 10; //私有成员，除了在类中，在类外是访问不到的
}
 
int main()
{
    A a;            //创建一个A类的对象
    test_Func_1(a); //调用这个函数需要A类的对象
}
```


#### 代码 2--友元类
#代码 #友元关系

```cpp
/*
友元：
1.单方向
2.不传递(不会默认传递，但是自己可以去声明一下)
3.不继承（父类的友元关系不继承给子类）
*/

#include <iostream>
using namespace std; 

class A
{
    int num;
    friend class B; //创建友元关系，在类B中所有区域都可以访问A类的私有成员
    //friend class C;//可以自己去声明一下
};
  
class B
{
    friend class C; 
    
public:
    void testFunc(A obj)
    {
        obj.num; //私有的，无法访问//希望在b类的这个函数里面可以访问到它，做法：将类B声明为A的友元
    }
};
  
class C
{
};
```

#### Time
[2023-07-16 00:01:24]编写代码、学习 C++友元关系

---

## 五、继承和派生

### 05-00 概要.【继承与派生】
实际上是讨论到了一个延续的问题

#### 学习目的 ：
1.不影响到原来的类，不改变原来类的代码
2.实现对功能的扩展
3.在原有的类的基础上快速增加新的功能
![[../../annex/0.C++总集_image_21.png]]

#### 课程内容
1.基本概念&&名词解释
2.语法实现
3.深入分析
4.菱形继承
![[../../annex/0.C++总集_image_22.png]]

#### 重难点
1.语法
2.父子关系
![[../../annex/0.C++总集_image_23.png]]

---

### 05-01 继承和派生.【继承与派生】

#### 1 .继承的概念（子承父业）
继承：一种在已经有了的类的基础上创建新类的方式
新创建的类可以来自一个类，也可是来自多个类——新建的类可以继承自一个或多个类

继承描述的是（原来的）类与（新的）类之间的关系。
父类<-->子类，基类<-->派生类
原有的类称为“基类”，又或者称“父类”
新创建的类被称为"派生类"，又或者称"子类"

#### 2 .继承和派生
继承和派生实际上是同一个过程，从不同的角度看的时候，那么可以对它进行一个描述。
从子类的角度上来说是从父类继承一些东西过来，而站在父类的角度来说是把东西派生给子类

#### 3. 继承分类（2 种）
分为不同的种类：单继承、多继承
单继承：只有一个父类
多继承：父类有多个。继承的父类之间不需要有什么联系

---

### 05-02  继承方式.【继承与派生】
#### 1 .语法层面
继承写在子类的后面，在子类的后面声明一下继承关系
##### 单继承
![[../../annex/0.C++总集_image_24.png]]

##### 多继承
继承的父类之间不需要有什么联系
继承个数不限
![[../../annex/0.C++总集_image_25.png]]

#### 2.继承权限（权限授予）
三、继承权限(跟成员的访问权限很像)//写在大括号里面(类体中)是成员的访问权限，写在类体外面是类的继承权限

1.公有继承 public

2.私有继承 private

3.保护继承 protected

多继承每个父类之间可以任意选择其中的某一种继承方式。

注意：
继承是子类继承父类的全部成员(数据成员和成员函数都能继承过来，无论原来是什么访问权限，只是问题在于能不能用)

##### 成员权限与继承方式结合后的 9 种访问情况
继承虽然可以让子类得到父类的所有的成员，但是对于子类（子类的对象）而言，这些东西能不能被访问到？（所有东西都可被继承，但是能否被访问？）

父类的成员在子类对象的一些访问权限（由父类原有的访问权限和子类使用的继承方式决定）

父类的成员通过子类的继承方式最终**在子类中**得到的访问权限：
（左边竖列是父类原有的成员的访问权限，上边横排是子类所使用的继承方式，共有 9 种情况）
**该表格得到的是在子类中的访问权限，而在子类的外面（创建对象）再具体分析**
| 访问权限 \ 继承方式 | 公有继承（public） | 私有继承（private） | 保护继承（protected） |
|:-------------------:|:------------------:|:-------------------:|:---------------------:|
|     **public**      |       public       |       private       |       protected       |
|     **private**     |      不可访问      |      不可访问       |       不可访问        |
|    **protected**    |     protected      |       private       |       protected       | 

1.父类的公有访问权限 public ：公有成员用什么方式继承在子类里面就是什么样的权限--在子类中的访问权限看其继承方式（继承权限）是什么样的就是什么样

2.父类的私有访问权限 private ：私有成员无论用什么样的方式去继承总是在子类中不可访问--只有在当前的类（本类）里面才能访问到，所有无论是在什么样的继承方式下都是不可访问。（确实继承到了，只不过不能去访问它）

3.父类的保护访问权限 protected：哪一个更严格就是哪一个，private>protected>public

##### 多级继承：分析直接的父子类

直接套用上面的这一套规定，直接分析它的一对直接父子类
分析他们的关系只需要分析跟你直接有关的这两个就可以了：分析你的直接父子类
至于从这个顶层传达下来的东西，你没有权力去直接得到，不能够预计
一级一级的继承下来，只能（只需要）一级一级的套这个规定去分析就可以了

![[../../annex/0.C++总集_image_26.png]]

1.先分析类1 继承给类2 的权限
![[../../annex/0.C++总集_image_27.png]]

2.然后分析类 2继承给类3 的权限
![[../../annex/0.C++总集_image_28.png]]

3.再分析类 3 继承给类 4 的权限，得到最终的权限
![[../../annex/0.C++总集_image_29.png]]

继承的过程中数据是不会丢失的，有就能继承下来，没有就继承不了。

#### 3. 举例

单继承且只有一对父子关系
public 继承是最常见的，一般很少用私有继承，只有在一些特殊情况才可以去用 private 继承，保护继承用的也不多

![[../../annex/0.C++总集_image_30.png]]

![[../../annex/0.C++总集_image_31.png]]

👆验证 9 种情况中的第一列的情况👇
![[../../annex/五、继承与派生_image_12.png]]
在子类中继承父类：可以访问 public 和 protected，private 无法访问
在子类外面（创建一个对象）：只可以访问 public，protected，private 不可访问

公有继承用的是最多的，超过 90%都是用公有继承，什么情况下肯定会用私有继承：如：首先会实现一些比较特殊的设计模式的时候，或者希望屏蔽掉父类中对你这个子类没有用途的这个成员的时候

##### 代码 1--继承和派生的基本概念与语法
#代码 #继承和派生 #继承和派生的基本概念与语法
```cpp
/*语法:
一、单继承:
class 父类名
{
};  

class 子类名: 继承权限 父类名
{
};  

二、多继承:
class 父类名1
{
}; 

class 父类名2：
{
};
  
class 子类名: 继承权限1 父类名1,继承权限2 父类名2,...继承权限n 父类名n
{
};
 
三、继承权限(跟成员的访问权限很像)//写在大括号里面(类体中)是成员的访问权限，写在类体外面是类的继承权限

1.公有继承 public

2.私有继承 private

3.保护继承 protected

多继承每个父类之间可以任意选择其中的某一种继承方式。

注意：
    继承是子类继承父类的全部成员(数据成员和成员函数都能继承过来，无论原来是什么访问权限，只是问题在于能不能用)
*/

/*
1.继承虽然可以让子类得到父类的所有的成员，但是对于子类（子类的对象）而言，这些东西能不能被访问到？

父类的成员在子类对象的一些访问权限（由父类原有的访问权限和子类使用的继承方式决定）
  
父类的成员通过子类的继承方式最终在子类中得到的访问权限：
（左边竖列是父类原有的成员的访问权限，上边横排是子类所使用的继承方式，共有 9 种情况）
  

| 访问权限 \ 继承方式 | 公有继承（public） | 私有继承（private） | 保护继承（protected） |

|:-------------------:|:------------------:|:-------------------:|:---------------------:|

|     **public**      |       public       |       private       |       protected       |

|     **private**     |      不可访问      |      不可访问       |       不可访问        |

|    **protected**    |     protected      |       private       |       protected       |

  
父类的公有访问权限 public ：公有成员用什么方式继承在子类里面就是什么样的权限--在子类中的访问权限看其继承方式（继承权限）是什么样的就是什么样

父类的私有访问权限 private ：私有成员无论用什么样的方式去继承总是在子类中不可访问--只有在当前的类（本类）里面才能访问到，所有无论是在什么样的继承方式下都是不可访问。（确实继承到了，只不过不能去访问它）

父类的保护访问权限 protected：哪一个更严格就是哪一个，private>protected>public 

2.继承的过程中数据是不会丢失的，有就能继承下来，没有就继承不了。

3.多级继承：分析直接的父子类

直接套用上面的这一套规定，直接分析它的一对直接父子类
分析他们的关系只需要分析跟你直接有关的这两个就可以了：分析你的直接父子类
至于从这个顶层传达下来的东西，你没有权力去直接得到，不能够预计
一级一级的继承下来，只能（只需要）一级一级的套这个规定去分析就可以了
 */

#include <iostream>
using namespace std;

class Father
{
    public:
        Father();
        ~Father();
    private:

};  

class Son : public Father//继承写在子类的后面，在子类的后面声明一下继承的关系,public继承是最常见的，一般很少用私有继承，只有在一些特殊情况才可以去用 private 继承，保护继承用的也不多
{
    public:
        Son();
        ~Son();
    private:

};

int main()
{
    return 0;
}
//将构造函数和析构函数放在主函数后面
/* Father类的相关函数*/
Father::Father()
{
}
  
Father::~Father()
{
}
/* Son类的相关函数*/
Son::Son()
{
}

Son::~Son()
{
}
```

















##### 代码 2--举例
#代码 #继承和派生 #继承和派生的基本概念与语法-举例

```cpp
/*语法:
一、单继承:
class 父类名
{
};

class 子类名: 继承权限 父类名
{
};
  
二、多继承:
class 父类名1
{
};
  
class 父类名2：
{
};

class 子类名: 继承权限1 父类名1,继承权限2 父类名2,...继承权限n 父类名n
{
};
  
三、继承权限(跟成员的访问权限很像)//写在大括号里面(类体中)是成员的访问权限，写在类体外面是类的继承权限

1.公有继承 public

2.私有继承 private

3.保护继承 protected

多继承每个父类之间可以任意选择其中的某一种继承方式。

注意：
    继承是子类继承父类的全部成员(数据成员和成员函数都能继承过来，无论原来是什么访问权限，只是问题在于能不能用)
*/

/*
1.继承虽然可以让子类得到父类的所有的成员，但是对于子类（子类的对象）而言，这些东西能不能被访问到？ 

父类的成员在子类对象的一些访问权限（由父类原有的访问权限和子类使用的继承方式决定）
  
父类的成员通过子类的继承方式最终在子类中得到的访问权限：
（左边竖列是父类原有的成员的访问权限，上边横排是子类所使用的继承方式，共有 9 种情况）

| 访问权限 \ 继承方式 | 公有继承（public） | 私有继承（private） | 保护继承（protected） |

|:-------------------:|:------------------:|:-------------------:|:---------------------:|

|     **public**      |       public       |       private       |       protected       |

|     **private**     |      不可访问      |      不可访问       |       不可访问        |

|    **protected**    |     protected      |       private       |       protected       |

  

父类的公有访问权限 public ：公有成员用什么方式继承在子类里面就是什么样的权限--在子类中的访问权限看其继承方式（继承权限）是什么样的就是什么样

父类的私有访问权限 private ：私有成员无论用什么样的方式去继承总是在子类中不可访问--只有在当前的类（本类）里面才能访问到，所有无论是在什么样的继承方式下都是不可访问。（确实继承到了，只不过不能去访问它）

父类的保护访问权限 protected：哪一个更严格就是哪一个，private>protected>public 

2.继承的过程中数据是不会丢失的，有就能继承下来，没有就继承不了。
 
3.多级继承：分析直接的父子类

直接套用上面的这一套规定，直接分析它的一对直接父子类
分析他们的关系只需要分析跟你直接有关的这两个就可以了：分析你的直接父子类
至于从这个顶层传达下来的东西，你没有权力去直接得到，不能够预计
一级一级的继承下来，只能（只需要）一级一级的套这个规定去分析就可以了
 */
 
#include <iostream>
using namespace std;
  
class Father
{
public:
    Father();
    ~Father();

public:
    int pub;           //创建一个公有的数据成员
    void pub_func() {} //创建一个公有的成员函数
private:
    int pri;           //创建一个私有的数据成员
    void pri_func() {} //创建一个私有的成员函数
protected:
    int pro;           //创建一个保护的数据成员
    void pro_func() {} //创建一个保护的成员函数
}; 

class Son : public Father //继承写在子类的后面，在子类的后面声明一下继承的关系,public继承是最常见的，一般很少用私有继承，只有在一些特殊情况才可以去用 private 继承，保护继承用的也不多
{
public:
    Son();
    ~Son();  

public:
    int num;
    void test_Func_public()//在类的里面创建一个函数，属于在类的里面了
    {
        this->num;//在类的里面有this指针，通过this指针可以访问到它自己的num;
        this->pub; //继承过来的公有的肯定可以被访问;
        this->pub_func(); //继承过来的公有的肯定可以被访问;
        this->pro;//公有方式继承过来的父类的被保护的成员在子类中也是可以从内部访问
        this->pro_func();//同理
        // this->pri;//父类本身私有的成员无论用什么方式继承都无法访问
        // this->pri_func();//同理
    }
    
private:

protected:

};  

int main()
{
    cout << "sizeof(Father):" << sizeof(Father) << endl; //查看当前Father类类型的对象要占多少个字节的内存（3个int，3X4=12）
    cout << "sizeof(Son):" << sizeof(Son) << endl;       //查看当前Father类类型的对象要占多少个字节的内存（子类虽然什么都没写，但是继承了父类的，所以也是12个字节，自己虽然没有新增，但也是12个在字节）
    //在Son子类中新增定义一个int类型的num，内存就变为12+4=16个字节
      
    //看看Son子类能够访问的父类的访问权限
    Son obj_son;

    obj_son.num;//自身的public成员，可以访问
    
    obj_son.pub; //父类继承过来的public数据成员，可以访问
    obj_son.pub_func(); //父类继承过来的public成员函数，可以访问

    // obj_son.pri;//父类继承过来的private成员，无法访问
    // obj_son.pri_func(); //父类继承过来的private成员函数，不可访问
  
    //  obj_son.pro;//父类继承过来的protected成员，无法访问。属于是被保护的，在类外无法被访问
    //  obj_son.pro_func(); //父类继承过来的protected成员函数，不可访问，属于是被保护的，在类外无法被访问
    
    return 0;
}
//将构造函数和析构函数放在主函数后面
/* Father类的相关函数*/
Father::Father()
{
}

Father::~Father()
{
}

/* Son类的相关函数*/
Son::Son()
{
}  

Son::~Son()
{
}
```

##### Time
[2023-07-17 12:15:42]编写代码、学习继承和派生

---

### 05-03 父子关系【继承与派生】

####  一.派生类的构成
##### 1. 继承情况（父类的构造、析构和拷贝不会继承）     
派生类（子类）会继承除了父类的构造函数和析构函数之外所有的成员函数和数据成员
（构造和析构不会继承下来：因为有低保吃，任何一个类系统都会给你析构和构造，这个东西你自己有，自然就不需要去继承）拷贝构造属于构造的一种，是特殊的构造函数，也不会被继承
但是你这个子类可以去调用父类的构造和析构

##### 2 .继承的调用情况
派生类（子类）中是可以去添加自己的一些新的成员的，这些则需要通过该派生类（子类）的对象来去调用。父类是无法调用你新增的成员的

##### 3 .父子类具有同名数据成员的情况
如果你的派生类（子类）当中添加的成员，它的名字和基类（父类）当中的成员名字相同，那么派生类（子类）就会把基类（父类）的这个成员隐藏起来，但是你要使用它的时候，还是可以用得到。使用方式就是通过基类（父类）的这个类名+作用域符去访问基类（父类）的这个派生类（子类）同名的成员。
如果继承的是多个基类（多个父类），多个基类当中也有名字相同的成员，也可以通过类名+作用域符的方式去访问。

![[../../annex/0.C++总集_image_32.png]]

具有同名的数据成员时，父类的会被自动屏蔽，直接访问的是访问到子类的同名的数据成员。

当然，父类的同名数据成员还在，那么我们怎样才能找到这个被藏起来的父类同名数据成员 num 呢？子类中共有三个成员（父类继承过来的 val 和 num，子类本身具有的 num），所以没法用 this 指针区分开来，因为这三个东西都是属于自己的了，继承过来当然就是自己的了，是他自己的当然就无法区分开来。

通过父类类名+作用域符来访问到同名的数据成员

![[../../annex/0.C++总集_image_33.png]]

![[../../annex/0.C++总集_image_34.png]]

###### 小结

访问自己的成员 val 照常直接访问即可
访问父类继承的同名数据成员需要父类名+作用域符
如：obj_son. Father:: val (子类声明的对象 obj_son 去访问 Father 类中的同名数据成员 val)

##### 代码
#代码 #继承和派生 #父子关系

```cpp
#include <iostream>
using namespace std;

class Father_1//测试具有多个父子类有同名的数据成员的情况
{
public:
    Father_1();
    ~Father_1();  

    int val;//设置一个同名的数据成员
    int a;//其他正常使用，不受影响
};
  
class Father
{
public:
    Father();
    ~Father();  

    int val;//设置一个同名的数据成员
    int num;//在父类当中定义一个与子类具有的同名的数据成员
    int b;//其他正常使用，不受影响

};

class Son : public Father ,public Father_1
{
public:
    Son();
    ~Son();  

    int num;
    int val;//如果子类中也有同名的数据成员val
};
  
int main()
{
    Son obj_son;//创建一个子类的对象，如果查看内存则为：3X4=12个字节，val+父类的num+子类num。无法得知 调用的是谁的num
    obj_son.num;//子类的对象可以点到（访问到）自己的num
    obj_son.val;//也可以点到父类继承过来的val（在没有多个父类有同名数据成员时）
    //当有多个父类有同名的数据成员时，子类无法搞清是访问哪个val(两个val都不是自己的，都是从父类中继承过来的),如果自己也有val则可以访问，因为继承的两个同名的val都被屏蔽了 

    cout << "obj_son.num=" << obj_son.num << endl;//输出一下子类对象.num的值,看看具有同名数据成员时访问的是谁的数据成员。得到结果：99，说明我们是通过这个子类的构造函数给的99，也就是说该num使用的是子类的数据成员，说明具有同名的数据成员时，父类的会被自动屏蔽，直接访问的是访问到子类的同名的数据成员，当然，父类的同名数据成员num还在
    //当然，父类的同名数据成员还在，那么我们怎样才能找到这个被藏起来的父类同名数据成员 num 呢？子类中共有三个成员（父类继承过来的 val 和 num，子类本身具有的num）,所以没法用 this 指针区分开来，因为这三个东西都是属于自己的了，继承过来当然就是自己的了，是他自己的当然就无法区分开来。
    
    // 通过父类类名 + 作用域符来访问到同名的数据成员

    cout << "obj_son.Father::num=" << obj_son.Father::num << endl;//输出结果:20，说明访问到的是父类的同名数据成员

    //多个父子类有同名的数据成员时，同样用类名+作用域符去访问到同名的数据成员
    cout << "obj_son.val=" << obj_son.val << endl;
    cout << "obj_son.Father::val=" << obj_son.Father::val << endl;
    cout << "obj_son.Father_1::val=" << obj_son.Father_1::val << endl; 

    return 0;
}

//将构造函数和析构函数放在主函数后面
/* Father类的相关函数*/
//在父类和子类的构造中分别给数据成员一个值，用以区分子类对象访问同名数据成员时的情况
Father::Father()
{
    val = 10; //给同名的数据成员不同的一个值，用以区分访问的情况(多个父子类有同名数据成员时)
    num = 20; //给同名的数据成员不同的一个值，用以区分访问的情况单(对父子类有同名数据成员时)
    b = 2;//其他不受影响
}
Father::~Father()
{
}

/* Son类的相关函数*/
Son::Son()
{
    num = 99; //给同名的数据成员不同的一个值，用以区分访问的情况单(对父子类有同名数据成员时)
    val = 88;  //给同名的数据成员不同的一个值，用以区分访问的情况单(对父子类有同名数据成员时)
} 
Son::~Son()
{
}
  
//将Faher_1的构造和析构写在Son的构造和析构的后面，来测试如果有多个父子类的具有同名数据成员
Father_1::Father_1()
{
    val = 100; //给同名的数据成员不同的一个值，用以区分访问的情况(多个父子类有同名数据成员时)
    a = 1;     //其他不受影响
}
Father_1::~Father_1()
{
}
```

##### Time
[2023-07-17 16:28:29]编写代码、学习继承和派生

---

####  二. 派生类和基类的关系
##### 1.子类是父类的对象，但是父类的对象不是子类的对象
子类是父类的对象，但是父类的对象不是子类的对象--派生类是基类的对象，而基类的对象不是派生类的对象
派生类的对象可以当作基类对象来使用，因为派生类是继承了基类中所有的成员，也就是说基类有的派生类也有，既然如此，那么我直接用派生类不是也可以吗
（假设：父类有 50 块钱，而子类有 100 块钱，父类可以买的东西子类也可以买下。这就是用父类的地方可以用子类去用，因为子类本身就包含了父类所有的东西，并且它还新增了自己的一些东西。所以说父类拿下的东西，子类必拿下）

##### 2 .举例(以单继承来简单讨论一下)

1.子类对象也给父类对象赋值，父类对象不能给子类对象赋值

2.父类指针可以指向子类对象，而子类指针不能指向父类对象

**赋值的话给不满就不能给，读内存的话读不够也不行**

obj_fat = obj_son;//用子类对象给父类对象赋值，可以。父类对象可以接受子类对象给的值(父类对象可以用子类对象赋值)

// obj_son = obj_fat;//用父类对象给子类对象赋值，不行。子类对象不能接受父类对象给的值(子类对象不能用父类对象赋值)
   
![[../../annex/0.C++总集_image_35.png]]

![[../../annex/0.C++总集_image_36.png]]

父类不能给子类赋值：给不满，子类的新增部分没有东西给他，绿色区域拿不到值，就属于没有初始化（没有给上值）
所以父类类型比较小（父类<子类）
![[../../annex/0.C++总集_image_37.png]]

子类对象可以给父类对象赋值：给得满，黄色区域可以给过去，而蓝色区域在父类中没地方接住，给不给无所谓，浪费了就浪费了，反正只要给满了，它能用就可以了。
父类对象可以完整的接收到它所需要的值就行了，但是反过来的话子类对象有一部分没值，这不行
![[../../annex/0.C++总集_image_38.png]]

两个指针跨度不一样
左边父类类型指针指向父类，右边子类类型指针指向子类 (正常情况正常读取)
![[../../annex/0.C++总集_image_39.png]]

父类指针指向子类对象，子类指针指向父类对象
![[../../annex/0.C++总集_image_40.png]]

左边不行（子类指针指向父类对象）
右边可以（父类指针指向子类对象）

父类对象没有子类对象新增的部分。
子类指针读父类的对象。指针这么大的范围，要读取这么长，这一部分又没有，所以它不行（读不到），就算读到了也是别人的内存，它不属于当前这个对象。
（子类的指针要读取的范围比父类指针读取的范围要大）
![[../../annex/0.C++总集_image_41.png]]

至于用父类指针去读子类对象的内存的时候，父类有的东西子类都有，那么这个指针还是可以去读，至于底下多出来的这一部分，读不出来就读不出来，不读就好了。反正既不会影响别人，自己又可以读取到数据。所以用父类指针可以去读子类的对象
![[../../annex/0.C++总集_image_42.png]]

**赋值的话给不满就不能给，读内存的话读不够也不行**

##### 代码
#代码 #继承和派生 #派生类和基类的关系

```cpp
// 11-2-2继承和派生父子关系-派生类和基类的关系
//(以单继承来简单讨论一下)

/*
子类是父类的对象，但是父类的对象不是子类的对象
派生类的对象可以当作基类对象来使用，因为派生类是继承了基类中所有的成员，也就是说基类有的派生类也有，既然如此，那么我直接用派生类不是也可以吗
（假设：父类有 50 块钱，而子类有 100 块钱，父类可以买的东西子类也可以买下。这就是用父类的地方可以用子类去用，因为子类本身就包含了父类所有的东西，并且它还新增了自己的一些东西。所以说父类拿下的东西，子类必拿下）
*/ 

#include <iostream>
using namespace std; 

class Father
{
public:
    Father();
    ~Father(); 

};

class Son : public Father
{
public:
    Son();
    ~Son();
    
}; 

int main()
{
    // 子类对象也给父类对象赋值，父类对象不能给子类对象赋值
    // 父类指针可以指向子类对象，而子类指针不能指向父类对象
    // 原因都在内存图（obsidian）上面。子类比父类多一些东西，赋值的话给不满就不能给，读内存的话读不够也不行
    Father obj_fat;//定义一个父类的对象
    Son obj_son;//定义一个子类的对象
  
    obj_fat = obj_son;//用子类对象给父类对象赋值，可以。父类对象可以接受子类对象给的值(父类对象可以用子类对象赋值)
    // obj_son = obj_fat;//用父类对象给子类对象赋值，不行。子类对象不能接受父类对象给的值(子类对象不能用父类对象赋值)
    
    Father *p_fat;//定义一个父类的指针
    p_fat = &obj_fat;//父类类型的指针取父类对象的首地址给它,类型匹配，毫无问题
    p_fat = &obj_son;//子类对象的首地址给父类类型的指针，父类指针可以指向子类对象
  
    Son *p_son; //定义一个子类的指针
    // p_son = &obj_fat;//子类指针不能指向父类对象
    p_son = &obj_son;//子类类型的指针取子类对象的首地址给它,类型匹配，毫无问题 

    /*
        cout << "obj_fat=" << sizeof(obj_fat) << endl;//一个字节，大小跟编译器有关
        cout << "*p_fat=" << sizeof(*p_fat) << endl;//一个字节，视频中说指针为4个字节
        cout << "obj_son=" << sizeof(obj_son) << endl;//一个字节
        cout << "*p_son=" << sizeof(*p_son) << endl;//一个字节
     */
     
    return 0;
}

//将构造函数和析构函数放在主函数后面
/* Father类的相关函数*/
//在父类和子类的构造中分别给数据成员一个值，用以区分子类对象访问同名数据成员时的情况
Father::Father()
{
}
Father::~Father()
{
}
 
/* Son类的相关函数*/
Son::Son()
{
}
Son::~Son()
{
}
```

##### Time
[2023-07-17 17:41:31]编写代码、学习派生类和基类的关系

---

####  三. 派生类的构造析构顺序
##### 11 -2-3【继承和派生】父子关系-派生类的构造析构顺序

创建子类的对象，那么就要先调父类的构造函数，调了父类构造当然就要调父类析构函数，先构造的后析构。

如果非得要显示的传参去调用这个父类的构造，那么就把父类构造写在成员初始化列表中。(先调用父类构造才能调用自己的构造)

如果有多个继承和派生的父子类有这种情况，同样是只需要调用直接父类的构造就行了，因为(你爷爷的构造已经在你父亲那里写好了，而你只需要写你爹的就可以了。子类在成员初始化列表写父类的/去调用就可以了，而父类的父类在父类的成员初始化列表处写/调就可以了)--（俄罗斯套娃）--你只需要对自己的直接父子类去负责即可


子类当中肯定会有一部分东西是继承自父类的，这一部分东西怎么去初始化？
通过子类去调用父类的构造函数，需把它写在你的成员初始化列表里面

为什么会调用父类的构造函数呢？
其实就相当于有些地方系统悄悄的给你在成员初始化列表写了 Father 类的构造函数
不带参数也是悄悄的给你写了这么一个东西，只是你看不见，也不需要看见。

![[../../annex/0.C++总集_image_43.png]]

直接这么写没问题
![[../../annex/0.C++总集_image_44.png]]

但是你要传参的话，就要这么写（在成员初始化列表中写上父类构造）
![[../../annex/0.C++总集_image_45.png]]

成员初始化列表语法是很灵活的，想怎么放就怎么放
![[../../annex/0.C++总集_image_46.png]]

同理
![[../../annex/五、继承与派生_image_27.png]]


##### 代码
#代码 #派生类的构造和析构顺序

```cpp
// 11-2-3【继承和派生】父子关系-派生类的构造析构顺序
// 创建子类的对象，那么就要先调父类的构造函数，调了父类构造当然就要调父类析构函数，先构造的后析构。
// 如果非得要显示的传参去调用这个父类的构造，那么就把父类构造写在成员初始化列表中。(先调用父类构造才能调用自己的构造)
// 如果有多个继承和派生的父子类有这种情况，同样是只需要调用直接父类的构造就行了，因为(你爷爷的构造已经在你父亲那里写好了，而你只需要写你爹的就可以了。子类在成员初始化列表写父类的/去调用就可以了，而父类的父类在父类的成员初始化列表处写/调就可以了)--（俄罗斯套娃）--你只需要对自己的直接父子类去负责即可

#include <iostream>
using namespace std;

class Father
{
public:
    Father();
    Father(int n); //父类构造带参数
    ~Father();
  
    const int num;
};  

class Son : public Father
{
public:
    Son();
    Son(int n, int v); //子类构造带参
    ~Son();
  
    int val;
};  

int main()
{
    // Son obj_son;//创建了子类对象
    Son obj_son(3, 4); //传个参数3和4(令n =3,v=4)
    cout << "obj_son.num=" << obj_son.num
         << "obj_son.val=" << obj_son.val
         << endl;  
         
    return 0;
}

//将构造函数和析构函数放在主函数后面
/* Father类的相关函数*/

/*//父类中int num为公有时
 Father::Father()
{
    num = 0; //父类的构造中给num赋值0
    cout << "父类构造" << endl;
}
Father::Father(int n)
{
    num = n; //父类的构造中形参传给num
    cout << "父类带参构造" << endl;
}
*/
Father::Father():num(0)//父类中num为const修饰时
{
    cout << "父类构造" << endl;
}
Father::Father(int n):num(n)
{
    cout << "父类带参构造" << endl;
}
Father::~Father()
{
    cout << "父类析构" << endl;
}
  
/* Son类的相关函数*/
Son::Son()
{
    val = 10; //子类的构造中给val赋值10
    cout << "子类构造" << endl;
}

//怎么样才能把子类当中的n传倒父类当中的num？

Son::Son(int n, int v) :Father(n),val(v)//这样才是调用父类的构造函数，在成员初始化列表里面调用。其他地方是不能被我们主动调用的，只是把它写在初始化列表里面，本质上还是由系统自动调用，执行到初始化列表的时候还是会给他出一下（这样就能拿到3和4）
//成员初始化列表中写了Father类构造函数，后面同样可以照常写val(v)。
{
    val = v;
    // num = n;//当父类中的num被const修饰时，子类当中同样不能这样去给它值了
    // Father(n);//这么做不是在调构造函数，而是在创建一个父类的、没有名字的对象，传了一个参数为n（这不属于把n传过去）
    cout << "子类构造" << endl;
}
Son::~Son()
{
    cout << "子类析构" << endl;
}  
// 如果你要创建子类对象，会先调用父类的构造

```

##### Time
[2023-07-18 17:12:37]编写代码、学习 C++派生类的构造和析构的顺序

---

### 05-04 菱形继承（用虚指针）【继承与派生】
菱形继承是通过类的结构图的样子来取名字的

![[../../annex/0.C++总集_image_47.png]]

类 A 派生出了类 A1, A2。
类 A1,类 A2 又共同派生出了新的类，类 AA。

![[../../annex/0.C++总集_image_48.png]]

假设类 A 中有一个成员 n，然后派生出类 A 1，类 A 2 时，理所当然的就各自会有一个 n。
再由类 A 1，类 A 2 共同派生出来的类 AA，继承会把父类里面所有的成员都继承过来，所以相当于类 AA 中有了两个同样的 n，究其根本这两个 n 都是来自于类 A。
这两个东西重复了。重复了没必要（臃肿、多余）。甚至有时候可能会出现问题：比如去访问他们的时候出现问题。
而且有一个致命的问题，在此处 int 类型只有 4 个字节，那么对于类 AA 来讲就只多了 4 个字节。但假设类 A 中有 100 个这样的 n（很容易就做到，如：类 A 中有一个 int 类型的数组，长度 100，那就是 400 个字节了），然后类 A1，类 A2 正常继承，没问题。但是给到类 AA 的时候，类 AA 就等于多余了 100 个 int 类型的内存，相当于浪费了 400 个字节内存。

![[../../annex/0.C++总集_image_49.png]]

类 AA 同时继承了两份类 A 的成员，浪费。

![[../../annex/0.C++总集_image_50.png]]

可以通过类名+成员名的形式，直接父类的类名就可以去得到它的这两个变量
类名 : : 成员名

![[../../annex/0.C++总集_image_51.png]]

这两个变量确实可以访问到，确确实实的不同的两个变量，来自两个不同的父类，只不过是追根溯源的时候，来自同一个类（类A），这是没有必要的。
若类 A 中有很多这样的成员，各自继承下去给类 A 1, 类 A 2，这就不合适了，名字一样，来自不同父类，但是这不同父类之间又有亲戚关系，这就很容易混淆。

像这种方法虽然可以访问。但是治标不治本，内存还是浪费


为了解决这种事情，于是有了虚继承这个东西
![[../../annex/0.C++总集_image_52.png]]

在继承的时候加上 virtual，对于类 A1，类 A 2 没有任何影响，实际上是会有一个虚指针存在，这个虚指针最大的作用是标记一下你类A1从类A中继承了哪些东西，你类A2的虚指针就标记一下你类A2从类A中继承了哪些东西，然后由类A1，A2共同派生出类AA时，虚指针起作用：派生时会去查看，我们俩重复了部分内容，那就只给他(类AA)一份内容
![[../../annex/0.C++总集_image_53.png]]

用了虚指针，原来不行的 obj_aa.n 现在可以了，就不需要类名去限定。
![[../../annex/0.C++总集_image_54.png]]


可以这么去理解：不从类 A1，类 A2 中拿了，直接从类 A 中拿过来。
用了虚指针，最终子类就只会有一份来自于最先父类的这么一个内存
![[../../annex/0.C++总集_image_55.png]]

##### 代码
#代码 #菱形继承（用虚指针）

```cpp
// 11 - 3菱形继承（虚指针）

#include <iostream>
using namespace std;
//类的结构图写成代码
class A
{
public:
    int n;
};
  
class A_1 : virtual public A //加上virtual，虚指针，用这种方式类A2就分别会多出4个字节的内存，这4个字节的内存存这个虚指针
{
public:
    int a1;
}; 

//有一个兄弟类A_2
class A_2 : virtual public A //加上virtual，虚指针，用这种方式类A2就分别会多出4个字节的内存，这4个字节的内存存这个虚指针
{
public:
    int a2;
};  

class AA : public A_1, public A_2
{
public:
    int aa;
};  

int main()
{
    AA obj_aa; //用AA来定义一个对象
    obj_aa.aa; //可以访问到
    obj_aa.a1; //可以访问到
    obj_aa.a2; //可以访问到
    // obj_aa.n; //有问题，不能直接访问（这里是不明确的问题）
    
    obj_aa.n; //用了虚指针，原来不行的 obj_aa.n 现在可以了，就不需要类名去限定。即便用类名去限定也是同一份内容。

    obj_aa.A_1::n; //这种方法可以访问，对象+.+类名+作用域符+成员
    obj_aa.A_2::n; //这种方法可以访问，可以用这个来区分清楚n是哪一个的问题
    //这两个变量确实可以访问到，确确实实的不同的两个变量，来自两个不同的父类，只不过是追根溯源的时候，来自同一个类（类A），这是没有必要的。若类 A 中有很多这样的成员，各自继承下去给类 A 1, 类 A 2，这就不合适了，名字一样，来自不同父类，但是这不同父类之间又有亲戚关系，这就很容易混淆。只有一个n都这么麻烦，这么做不合适。
    //治标不治本，内存还是浪费

    // obj_aa.A::n;//不是直接父类，所以不行，这里不知道为啥可以，视频里是不行的。（这里是属于A不是直接父类，所以不行）
  
    //如何解决：虚继承--在继承的时候加上 virtual，对于类 A1，类 A 2 没有任何影响，实际上是会有一个虚指针存在，这个虚指针最大的作用是标记一下你类A1从类A中继承了哪些东西，你类A2的虚指针就标记一下你类A2从类A中继承了哪些东西，然后由类A1，A2共同派生出类AA时，虚指针起作用：派生时会去查看，我们俩重复了部分内容，那就只给他(类AA)一份内容。

    // 用这种方式类A1,类A2就分别会多出4个字节的内存，这4个字节的内存就是存这个虚指针的。用4个字节的内存去换取不知道多少个的内存就很划算，并且还解决的类AA重复的问题

    //可以这么去理解：不从类 A1，类 A2 中拿了，直接从类 A 中拿过来。

    // 用了虚指针，最终子类就只会有一份来自于最先父类的这么一个内存

    return 0;

}
```

##### Time
[2023-07-19 00：14：14]编写代码、学习菱形继承、虚指针

---

## 六、多态
#### 06 -00 概要
##### 学习目的
* 了解多态的作用
* 熟悉纯虚函数的使用
* 能够在实际开发中使用多态
![[../../annex/0.C++总集_image_56.png]]

##### 课程内容
* 联编
* 多态
* 纯虚函数
* final
![[../../annex/0.C++总集_image_57.png]]

##### 重点难点
* 多态
* 纯虚函数
![[../../annex/0.C++总集_image_58.png]]

### 06-01 联编
#### 1 、什么是联编
其实就是计算机彼此关联的一个过程，就可以称之为是联编的过程，反映出映射的关系。
比如说在写代码时，在一个函数中调用了另一个函数，这两个函数就联合起来去实现某些功能，这个就可以理解为是一种联合关系。
举例：在函数重载时，我们可以通过实参的不同去决定调用哪一个具体的对于的函数，这个就是通过你函数的调用和你具体的函数体之间有一种对应的关系，可以称之为一种映射关系，通过你的实参就可以决定具体调用哪一个函数，这个也属于是一种联编。

#### 2、动/静态联编
动态联编（动态约束晚期联编）、静态联编（静态约束、早期联编）
1、都属于联编，只不过这两者有一些区别，动态联编的难度更大。
2、静态联编指的是你联编工作是出现在你写代码的这个阶段，也就是说出现的时间比较早。在写代码阶段局已经确定下来（在写代码时就确定调用哪个函数、在哪个地方执行哪一段代码），在代码编译就已经确定了 (函数的实现/函数的调用之间的关系)
3、动态联编出现的时间段是在你程序运行阶段。指的就是有一些时候在编译的阶段，我们不确定你接下来（要调用的函数/在某一个操作下需要执行的代码），不知道它是什么，必须等到程序运行时你才能去确定究竟要调用哪个函数。这就是所谓的动态联编
4、简单来说，联编是属于代码执行的问题。
5、动态联编和静态联编最大的一个区别就是所发生的时间段不一样

#### 3、实现动态联编的条件
静态联编我们经常在用，那么动态联编我们怎么才能去实现它呢？
动态联编是通过多态去体现出来的。

<center>（第1、2 点属于先决条件，第 3点是表现形式）</center>
1、先决条件
必须要把动态联编的行为定义为叫做类的虚函数（要有类、要有虚函数，在一个类中必须要有虚函数才行）（要有一个拥有虚函数成员的类）

2、先决条件
要有继承关系，并且拥有虚函数的类要是个父类。

3、表现形式
如何去使用这些东西？
举例：父类类型的指针能够指向派生类的子类的对象。
那么，在这里我们要体现多态，就需要先用基类指针或引用去指向或引用这个派生类对象，然后通过这个指针或引用去调用写成了虚函数的函数成员就可以了（体现多态）

#### Time
[2023-07-19 23：36：35] 学习 C++多态的概要和联编的基础知识

---
### 06-02 多态
#### 1 、多态的概念
它实际上就是说当你的类之间存在层次结构，并且类之间是通过继承去关联的时候，就可以用到这个多态。
也就是说，你现在有一些类，类之间有父子关系之类的时候，就可以用多态了。
在 C++中，多态其实就意味着你在调用类的成员函数的时候，会根据调用当前这个函数的对象，它的类型不同，可以去执行不同的函数。

![[../../annex/0.C++总集_image_59.png]]

![[../../annex/0.C++总集_image_60.png]]
结果：
![[../../annex/0.C++总集_image_61.png]]

不知为何，vscode 2022 会报错
![[../../annex/0.C++总集_image_62.png]]

虽然两个子类（Son_1, Son_2）都是公有继承自 Father 类，不过他们自己写了一个同名函数的情况下，直接调用是由于父类的同名成员会被自动隐藏，所以会调用自己的成员（前面讲过）

1、虚函数成员的父类

2、同名函数成员的子类

3、指针

##### 代码
#代码 #多态

```cpp
/* 要有这3个条件才能有多态
1、虚函数成员的父类
2、同名函数成员的子类
3、指针
*/
  
#include <iostream>
using namespace std;
  
class Father
{
public:
    void Fat_func();
};  

class Son_1 : public Father//公有继承父类
{//显然，除了构造析构都会继承下来
    void Fat_func();//在子类中写一个同名的函数
};

class Son_2 : public Father //公有继承父类
{                           //显然，除了构造析构都会继承下来
    void Fat_func();        //在子类中写一个同名的函数
};  

int main()
{
/*只是有一些普通的同名函数，属于不该出现的情况。
     Father obj_fat;
    obj_fat.Fat_func();

    Son_1 obj_son1;
    obj_son1.Fat_func(); 

    Son_2 obj_son2;
    obj_son2.Fat_func();
    */ 

    return 0;
} 

//放到主函数后面
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
}
  
void Son_1::Fat_func()
{
    cout << "void Son_1::Fat_func()" << endl;
}
  
void Son_2::Fat_func()
{
    cout << "void Son_2::Fat_func()" << endl;
}
```


##### Time
[2023-07-20 12：34：16]编写代码


#### 2、虚函数以及虚函数的特点
虚函数在动态里面应该出现在父类里面，被子类继承下去
声明虚函数：你在声明函数成员的时候，如果在函数前面加上 virtual 关键字。virtual +函数名+参数表
虚函数的最大作用：开枝散叶。在派生出类后（在类族中）帮助你去实现多态。（只是其中一个条件）
实现多态的前提条件：
1、要有虚函数成员
2、要有子类
至于怎么样去体现多态，就是第 3 点，要用指针去指
![[../../annex/0.C++总集_image_63.png]]

虚函数的特点：
1、给类中的函数添加 virtual 关键字后，系统会给你当前这个类维护一个叫做虚函数表的东西

2、虚函数表的作用：所有虚函数都会储存在虚函数表里。

3、如果有虚函数，就不存在隐藏父类的同名函数了。相当于在子类中把父类的同名函数的函数体重新去实现了一遍。甚至可以认为，在加了 virtual 的情况下，这两个同名函数（父子类同名函数）就是同一个函数，只不过在这个子类中拥有一次把这个函数的函数体重新定义的机会。（这就是我们说的在子类中重写父类的虚函数，为什么叫重写：因为不是重新写了一个函数，而是把原来的函数重新定义了一遍，重写了函数体）

4、虚函数表是不会被继承下去的。在继承的过程里面，子类是不会继承父类的虚函数表的。Why？
系统给了就没必要去继承，当父类写了虚函数后，系统给父类自动维护了虚函数表，相当于系统给了一个低保，用虚函数表把类中所有的虚函数给存起来。子类把父类的虚函数重写一下的话，虚函数就不会被继承了，因为如果子类需要虚函数表，系统也会自动给他一个虚函数表
（子类也能吃到低保，父类不用去继承给子类）
虚函数表可以理解为数组类型的结构/链表类型的结构之类的

5、虚函数表究竟存的是什么？（有虚函数时）
虚函数表会把所有虚函数给记录下来，所以如何去记录这些函数？
用函数指针是最合适的。
所以虚函数表中记录的就是你当前类里面的这些虚函数的函数指针。
也就是说在虚函数表里面保存了你这些虚函数的首地址。
并且你的虚函数表又会有另外的一个低保可以帮你访问虚函数表。（有一个指针去指向虚函数表）系统默认给你这个指针专门指虚函数表的，这个也可以叫虚指针。
有一个 4 个字节的指针，这个指针有一个特殊的名字叫虚指针。系统给的。它的作用是指向这个虚函数表。Why？因为不知道你这个类中到底有多少个虚函数，也就是说这个虚函数表你也不知道有多大。要访问这个虚函数表就选择用一个4 个字节的指针指向这个虚函数表。
虚指针里面存储的是虚函数表的首地址，而在虚函数表中的每一个这样的节点/元素，它里面存储的就是你当前的这个类里面每一个虚函数的首地址。（按从上到下、从前到后，顺序排列放置）
如果你有 10个，那么这个虚函数表的长度就为 10。
虚函数表不会被继承，但是虚函数表里面的项（也就是虚函数）会被继承。
普通函数平时直接访问即可，但是在这里我们需要先通过虚指针：找到虚函数表，然后在虚函数表里面找到这一个当前虚函数的指针，然后通过虚函数指针去调用当前函数。但是实际上函数指针我们直接用指针名就可以去调用这个函数了。

#### 3、通过类的继承和虚函数实现多态

![[../../annex/0.C++总集_image_64.png]]

##### 代码-通过类的继承和虚函数实现多态
#代码 #多态 

```cpp
/* 要有这3个条件才能有多态
1、虚函数成员的父类
2、同名函数成员的子类
3、指针：父类类型的指针，指向不同对象（父类或者子类）对象  

类族
指针-->虚函数表
*/ 

#include <iostream>
using namespace std; 

class Father
{
public:
    virtual void Fat_func(); //声明虚函数：你在声明函数成员的时候，如果在函数前面加上 virtual 关键字
};
  
class Son_1 : public Father //公有继承父类
{                           //显然，除了构造析构都会继承下来
    void Fat_func();        //在子类中写一个同名的函数
};
  
class Son_2 : public Father //公有继承父类
{                           //显然，除了构造析构都会继承下来
    void Fat_func();        //在子类中写一个同名的函数
};

int main()
{
    /*只是有一些普通的同名函数，属于不该出现的情况。不写虚函数的情况下（普通情况下），就会根据对象当前的这个类型去调用当前类型的函数，是一个正常的操作。属于是静态联编的一种情况。
        Father obj_fat;
        obj_fat.Fat_func();

        Son_1 obj_son1;
        obj_son1.Fat_func();

        Son_2 obj_son2;
        obj_son2.Fat_func();
        */
  
    Father *p_fat;//创建父类类型的指针
    //创建三个不同类型的对象
    Father obj_fat;
    Son_1 obj_son1;
    Son_2 obj_son2;

    p_fat = &obj_fat;//父类类型的指针去取父类对象的首地址
    p_fat->Fat_func();//通过这个指针我们可以去调用这个函数

    p_fat = &obj_son1; //父类类型的指针还可以去接受一下子类对象的首地址
    p_fat->Fat_func(); //通过这个指针我们可以去调用这个函数
  
    p_fat = &obj_son2;  //父类类型的指针还可以去接受一下子类对象的首地址，父类指针小一点，读内容的时候不会影响到其他地方
    p_fat->Fat_func();  //通过这个指针我们可以去调用这个函数

    //如果去掉父类中的virtual，执行后全都是父类的：Father::Fat_func()
    //如果根据指针指向的内容，它的这个类型去调对应类型的这个函数。如果不加virtual，那就根据指针本身的类型，指针本身它是father类的类型，所以全都是father。动态根据参数，静态根据不同的子类。

    return 0;
}

//放到主函数后面
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
} 

void Son_1::Fat_func()
{
    cout << "void Son_1::Fat_func()" << endl;
}
  
void Son_2::Fat_func()
{
    cout << "void Son_2::Fat_func()" << endl;
}
```


#### 4、多态情况下去释放内存的注意事项
##### delete 的释放内存的问题--只调用父类析构函数
你的父类（基类）当中有虚函数，并且是通过父类指针去分配的子类对象的时候，释放内存的时候只能通过父类的指针去释放。再使用 delete 父类类型的指针。调用的其实会是父类的虚构函数，它不会去调用这个子类的析构函数，所以说在这种情况下，就要把父类的析构函数也定义为虚析构。也就是说把父类的虚构函数也定义为虚函数。虚函数的析构函数也就是虚析构函数，简称虚析构，这样就能正常的去调用子类的析构函数了。

创建子类对象之前要先调用父类构造，所以说红框里面没有问题，
p_father 是父类类型的指针，它所指向的是你申请出来的匿名子类对象，所以输出出来 test_func ()(fat_func ())，因为确实是子类的对象

![[../../annex/0.C++总集_image_65.png]]

这是堆区申请的内存，没有写对应 new delete，那么这个内存就没有释放。所以我们没有出现调用析构函数的情况。

![[../../annex/0.C++总集_image_66.png]]


那就释放一下指针。并且我们可以把它制空。

![[../../annex/0.C++总集_image_67.png]]

问题出现在你释放的时候，只调用了父类的析构函数，说明在这里 delete 的时候还是按照这个指针本身的类型去调的这个析构函数。

![[../../annex/0.C++总集_image_68.png]]

这样做就会有一个缺点，我们知道子类是在父类的基础上增加了一些东西，如果子类在父类的基础上新增的这些内容里面写了一些代码需要在子类的析构函数里面完成，才能够正确的进行对子类对象内存的释放，这种写法下不会去调用你子类的析构函数，就会导致释放失败。

delete 释放的时候是根据你这个指针的类型去释放、去调析构，释放多长的内存？

我们知道，假设父类是 100 个字节，子类有 300 个字节，多出来了 200 个字节，delete 按照父类的析构去操作的话，实际上申请了 300 个字节，但是根据 delete 去释放只能释放 100 个，那么还有 200 个就没有被释放，从此以后也不可能再释放了。这就产生了内存碎片、内存泄漏。多了以后就会造成问题，如蓝屏、死机，所以这种写法不对。

##### 解决方案

①那么我们如何才能解决这个问题呢？
可以用子类类型的指针去接收子类类型的对象（类型匹配），那为什么会有父类类型的指针去接收子类对象的写法呢？
因为在开发阶段，你要用到一些别人已经写好了的代码。
举个例子，不管游戏还是软件里面，你至少都会出现一个叫按钮的东西，这个按钮让你从无到有去做很麻烦，并且你需要不断的去使用这个只有一点点不同的按钮，此时我们可以直接提供一个按钮的类，直接从按钮的类里面去继承一个新类下来，然后再根据自己想要的去做一点点修改，那么就能得到自己的按钮了。
可是你用的是别人已经写好的代码，这些属于库文件之类的东西，那么你在使用其他相关联的一些支持的时候。
比如说在自己做了按钮之后，这个按钮点下去要实现某一个功能，这个功能你可能又需要去使用本来就有的代码，但是它本来就有的代码里面，可能有一个函数需要传参传一个按钮过来，它需要的参数就是本来系统就有的这个按钮类，而不是你自己新写的按钮子类，那么这个时候他参数的类型就应该是按钮父类，但是自己的按钮是按钮子类，参数传过去它不认识，怎么办？
你就用按钮父类类型的指针指向你自己的这个按钮子类的对象，然后再把按钮父类类型的指针传过去就可以用。
这种情况下迫于无奈只能这么操作, 不然参数传不过去，代码用不了。当然，后续还是可以把这个指针类型转换回来，然后自己在子类加的东西还是可以去用。

②有两种不同的解决方案 ：
1、直接解决提出问题的人，就把叫你写不同类型的就把它的类型改过来。
2、老实本分的去解决问题，从父类的析构函数上入手，受刚才的启发，这个指针指向什么样类型的函数，指向什么样类型的对象，就会去调用它的同名函数。那么析构函数能不能也这么操作呢？

![[../../annex/0.C++总集_image_69.png]]

我们实现这一套多态，我们所根据的就是把父类当前的类写成虚函数，那么子类当中就相当于重写了内容，就可以根据指针指向的对象的类型去调用对应的函数，那么现在我们是不是可以根据这个指针它所指向的对象的类型去调这个析构函数，当然析构函数永远是跟类名相同的。反正大家都是只有一个析构函数，名字不同就无所谓了。
也就是说在这里需要解决这个问题的话，我们就需要做一件事情：把父类的析构函数也定义为虚函数，那就是说在父类的析构函数前面加上 virtual。加上 virtual 后，就会发现该例子的情况下去调函数，前面照常，子类的析构也确实可以调出来了

![[../../annex/0.C++总集_image_70.png]]
👆（↑在析构函数前面加了 virtual 后↓）👇
![[../../annex/0.C++总集_image_71.png]]

但凡 delete，就意味着生命周期结束了，结束了就需要由系统自动去调析构函数。调析构的时候：
原来如果没有虚析构的情况下，那直接调这个指针类型的这么一个析构，就调父类析构去了。
现在有了虚析构，先看当前指针所指向的对象是什么类型的，然后去调这种类型的析构

![[../../annex/0.C++总集_image_72.png]]

然后在这个里面又继续调父类的析构。

![[../../annex/0.C++总集_image_73.png]]

虽然在这里出现了子类析构和父类析构，但是根据这个指针去调的，只有子类的析构。因为在子类析构当中会自动调用父类析构。delete p_father 的时候，由于这个 p_father 这个父类里面是虚析构了，所以说就不会直接就看什么类型的指针就调什么类型的析构了，而是根据这个指针所指向的这个对象的类型，去调这个对象类型的析构函数。

![[../../annex/0.C++总集_image_74.png]]

也就是说现在这一行 father 类的析构，不是通过这个 p_father 去调的 father 的析构, 而是通过 p_father 去调 Son 的析构的时候，释放子类对象会调父类的析构。

![[../../annex/0.C++总集_image_75.png]]

写成所谓的虚析构-->保证能够调到子类的析构函数，只要调到子类的析构函数，那它就会自动的调父类析构，就搞定了。

##### 代码
#代码 #多态的注意事项

```cpp
/* 要有这3个条件才能有多态
1、虚函数成员的父类
2、同名函数成员的子类
3、指针：父类类型的指针，指向不同对象（父类或者子类）对象  

类族
指针-->虚函数表
*/

#include <iostream>
using namespace std; 

class Father
{
public:
    Father();
    ~Father();
    virtual void Fat_func(); //声明虚函数：你在声明函数成员的时候，如果在函数前面加上 virtual 关键字
};  

class Son : public Father //公有继承父类
{
public:
    Son();
    ~Son();          //显然，除了构造析构都会继承下来
    void Fat_func(); //在子类中写一个同名的函数
};

int main()
{
    Father *p_father = new Son; //后半段(new Son)从堆区申请了一个这样的内存，使用new会自动给你返回一个当前这种类型的指针，也就是说在这里给你返回一个Son类型的指针，而Son类型的指针就是你所申请的Son对象的内存的首地址。
    //我们知道父类类型的指针可以指向子类对象，所以我们确确实实的在语法上面可以通过父类指针去接收你new出来的Son的这一段内存。
    //父类指针指向子类对象，只不过这个对象属于是匿名对象(确确实实有个对象，有一段内存，但是它没有名字，只能搞个指针才能访问到)
    // new Son给出去的就是首地址，我们可以用父类指针去接收这个地址
    p_father->Fat_func(); //用起来正常使用。
    delete p_father;      //释放指针
    p_father = NULL;      //制空
    return 0;
} 

//放到主函数后面
Father::Father() //父类构造
{
    cout << "Father::Father()" << endl;
}
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
}
Father::~Father() //父类析构
{
    cout << "Father::~Father()" << endl;
}
  
Son::Son() //子类构造
{
    cout << "Son::Son()" << endl;
}
void Son::Fat_func()
{
    cout << "void Son::Fat_func()" << endl;
}
Son::~Son() //子类析构
{
    cout << "Son::~Son()" << endl;
}
```

















































多态情况下去释放内存的注意事项你的父类（基类）当中有虚函数，并且是通过父类指针去分配的子类对象的时候，释放内存的时候只能通过父类的指针去释放。再使用 delete 父类类型的指针。调用的其实会是父类的虚构函数，它不会去调用这个子类的析构函数，所以说在这种情况下，就要把父类的析构函数也定义为虚析构。也就是说把父类的虚构函数也定义为虚函数。虚函数的析构函数也就是虚析构函数，简称虚析构，这样就能正常的去调用子类的析构函数了。

创建子类对象之前要先调用父类构造，所以说红框里面没有问题， p_father 是父类类型的指针，它所指向的是你申请出来的匿名子类对象，所以输出出来 test_func ()(fat_func ())，因为确实是子类的对象

![[../../annex/0.C++总集_image_65.png]]

这是堆区申请的内存，没有写对应 new delete，那么这个内存就没有释放。所以我们没有出现调用析构函数的情况。

![[../../annex/0.C++总集_image_66.png]]

那就释放一下指针。并且我们可以把它制空。

![[../../annex/0.C++总集_image_67.png]]

问题出现在你释放的时候，只调用了父类的析构函数，说明在这里 delete 的时候还是按照这个指针本身的类型去调的这个析构函数。

![[../../annex/0.C++总集_image_68.png]]

这样做就会有一个缺点，我们知道子类是在父类的基础上增加了一些东西，如果子类在父类的基础上新增的这些内容里面写了一些代码需要在子类的析构函数里面完成，才能够正确的进行对子类对象内存的释放，这种写法下不会去调用你子类的析构函数，就会导致释放失败。

delete 释放的时候是根据你这个指针的类型去释放、去调析构，释放多长的内存？

我们知道，假设父类是 100 个字节，子类有 300 个字节，多出来了 200 个字节，delete 按照父类的析构去操作的话，实际上申请了 300 个字节，但是根据 delete 去释放只能释放 100 个，那么还有 200 个就没有被释放，从此以后也不可能再释放了。这就产生了内存碎片、内存泄漏。多了以后就会造成问题，如蓝屏、死机，所以这种写法不对。

那么我们如何才能解决这个问题呢？ 可以用子类类型的指针去接收子类类型的对象（类型匹配），那为什么会有父类类型的指针去接收子类对象的写法呢？ 因为在开发阶段，你要用到一些别人已经写好了的代码。 举个例子，不管游戏还是软件里面，你至少都会出现一个叫按钮的东西，这个按钮让你从无到有去做很麻烦，并且你需要不断的去使用这个只有一点点不同的按钮，此时我们可以直接提供一个按钮的类，直接从按钮的类里面去继承一个新类下来，然后再根据自己想要的去做一点点修改，那么就能得到自己的按钮了。 可是你用的是别人已经写好的代码，这些属于库文件之类的东西，那么你在使用其他相关联的一些支持的时候。 比如说在自己做了按钮之后，这个按钮点下去要实现某一个功能，这个功能你可能又需要去使用本来就有的代码，但是它本来就有的代码里面，可能有一个函数需要传参传一个按钮过来，它需要的参数就是本来系统就有的这个按钮类，而不是你自己新写的按钮子类，那么这个时候他参数的类型就应该是按钮父类，但是自己的按钮是按钮子类，参数传过去它不认识，怎么办？ 你就用按钮父类类型的指针指向你自己的这个按钮子类的对象，然后再把按钮父类类型的指针传过去就可以用。 这种情况下迫于无奈只能这么操作, 不然参数传不过去，代码用不了。当然，后续还是可以把这个指针类型转换回来，然后自己在子类加的东西还是可以去用。

有两种不同的解决方案： 1、直接解决提出问题的人，就把叫你写不同类型的就把它的类型改过来。 2、老实本分的去解决问题，从父类的析构函数上入手，受刚才的启发，这个指针指向什么样类型的函数，指向什么样类型的对象，就会去调用它的同名函数。那么析构函数能不能也这么操作呢？

![[../../annex/0.C++总集_image_69.png]]

我们实现这一套多态，我们所根据的就是把父类当前的类写成虚函数，那么子类当中就相当于重写了内容，就可以根据指针指向的对象的类型去调用对应的函数，那么现在我们是不是可以根据这个指针它所指向的对象的类型去调这个析构函数，当然析构函数永远是跟类名相同的。反正大家都是只有一个析构函数，名字不同就无所谓了。 也就是说在这里需要解决这个问题的话，我们就需要做一件事情：把父类的析构函数也定义为虚函数，那就是说在父类的析构函数前面加上 virtual。加上 virtual 后，就会发现该例子的情况下去调函数，前面照常，子类的析构也确实可以调出来了

![[../../annex/0.C++总集_image_70.png]] 👆（↑在析构函数前面加了 virtual 后↓）👇 ![[../../annex/0.C++总集_image_71.png]]

但凡 delete，就意味着生命周期结束了。多态情况下去释放内存的注意事项你的父类（基类）当中有虚函数，并且是通过父类指针去分配的子类对象的时候，释放内存的时候只能通过父类的指针去释放。再使用 delete 父类类型的指针。调用的其实会是父类的虚构函数，它不会去调用这个子类的析构函数，所以说在这种情况下，就要把父类的析构函数也定义为虚析构。也就是说把父类的虚构函数也定义为虚函数。虚函数的析构函数也就是虚析构函数，简称虚析构，这样就能正常的去调用子类的析构函数了。

创建子类对象之前要先调用父类构造，所以说红框里面没有问题， p_father 是父类类型的指针，它所指向的是你申请出来的匿名子类对象，所以输出出来 test_func ()(fat_func ())，因为确实是子类的对象

![[../../annex/0.C++总集_image_65.png]]

这是堆区申请的内存，没有写对应 new delete，那么这个内存就没有释放。所以我们没有出现调用析构函数的情况。

![[../../annex/0.C++总集_image_66.png]]

那就释放一下指针。并且我们可以把它制空。

![[../../annex/0.C++总集_image_67.png]]

问题出现在你释放的时候，只调用了父类的析构函数，说明在这里 delete 的时候还是按照这个指针本身的类型去调的这个析构函数。

![[../../annex/0.C++总集_image_68.png]]

这样做就会有一个缺点，我们知道子类是在父类的基础上增加了一些东西，如果子类在父类的基础上新增的这些内容里面写了一些代码需要在子类的析构函数里面完成，才能够正确的进行对子类对象内存的释放，这种写法下不会去调用你子类的析构函数，就会导致释放失败。

Delete 释放的时候是根据你这个指针的类型去释放、去调析构，释放多长的内存？

我们知道，假设父类是 100 个字节，子类有 300 个字节，多出来了 200 个字节，delete 按照父类的析构去操作的话，实际上申请了 300 个字节，但是根据 delete 去释放只能释放 100 个，那么还有 200 个就没有被释放，从此以后也不可能再释放了。这就产生了内存碎片、内存泄漏。多了以后就会造成问题，如蓝屏、死机，所以这种写法不对。

那么我们如何才能解决这个问题呢？ 可以用子类类型的指针去接收子类类型的对象（类型匹配），那为什么会有父类类型的指针去接收子类对象的写法呢？ 因为在开发阶段，你要用到一些别人已经写好了的代码。举个例子，不管游戏还是软件里面，你至少都会出现一个叫按钮的东西，这个按钮让你从无到有去做很麻烦，并且你需要不断的去使用这个只有一点点不同的按钮，此时我们可以直接提供一个按钮的类，直接从按钮的类里面去继承一个新类下来，然后再根据自己想要的去做一点点修改，那么就能得到自己的按钮了。可是你用的是别人已经写好的代码，这些属于库文件之类的东西，那么你在使用其他相关联的一些支持的时候。比如说在自己做了按钮之后，这个按钮点下去要实现某一个功能，这个功能你可能又需要去使用本来就有的代码，但是它本来就有的代码里面，可能有一个函数需要传参传一个按钮过来，它需要的参数就是本来系统就有的这个按钮类，而不是你自己新写的按钮子类，那么这个时候他参数的类型就应该是按钮父类，但是自己的按钮是按钮子类，参数传过去它不认识，怎么办？ 你就用按钮父类类型的指针指向你自己的这个按钮子类的对象，然后再把按钮父类类型的指针传过去就可以用。这种情况下迫于无奈只能这么操作, 不然参数传不过去，代码用不了。当然，后续还是可以把这个指针类型转换回来，然后自己在子类加的东西还是可以去用。

有两种不同的解决方案： 1、直接解决提出问题的人，就把叫你写不同类型的就把它的类型改过来。 2、老实本分的去解决问题，从父类的析构函数上入手，受刚才的启发，这个指针指向什么样类型的函数，指向什么样类型的对象，就会去调用它的同名函数。那么析构函数能不能也这么操作呢？

![[../../annex/0.C++总集_image_69.png]]

我们实现这一套多态，我们所根据的就是把父类当前的类写成虚函数，那么子类当中就相当于重写了内容，就可以根据指针指向的对象的类型去调用对应的函数，那么现在我们是不是可以根据这个指针它所指向的对象的类型去调这个析构函数，当然析构函数永远是跟类名相同的。反正大家都是只有一个析构函数，名字不同就无所谓了。 也就是说在这里需要解决这个问题的话，我们就需要做一件事情：把父类的析构函数也定义为虚函数，那就是说在父类的析构函数前面加上 virtual。加上 virtual 后，就会发现该例子的情况下去调函数，前面照常，子类的析构也确实可以调出来了

![[../../annex/0.C++总集_image_70.png]] 👆（↑在析构函数前面加了 virtual 后↓）👇 ![[../../annex/0.C++总集_image_71.png]]

但凡 delete，就意味着生命周期结束了。
##### Time
[2023-07-22 16：42：51]

---

### 06-03 纯虚构函数
#### 1. 纯虚函数的概念
纯虚函数就是纯粹的虚函数--没有函数体的虚函数
纯虚函数是一种特殊的虚函数，使用虚函数的东西在这里都适用，而且比虚函数的要求还要高一点。

#### 2. 纯虚函数的定义
虚函数可以没有函数体（根本（连）大括号都没有）。
纯虚函数在声明的时候= 0 ，这样就是声明了一个虚函数。其他地方不要再写这个东西了。
virtual 关键字+返回值类型+函数名+参数表+= 0
不要理解为赋值为 0，这就是一个语法格式
![[../../annex/0.C++总集_image_76.png]]

纯虚函数的函数体不在当前这个类实现，它的函数体就要留给当前这个类的子类去完成
（在子类里面去实现父类的纯虚函数的函数体）。
子类里面跟虚函数同名的函数体属于是多了一次重新定义函数体的机会。反正写了虚函数迟早要被你重写，那不如不写，直接=0. 该实现的时候让你自己去实现，我就只负责声明一下有这么一个函数，至于有意义的函数体，有意义的实现我根本就不写，让子类自己去实现就行了。

析构函数也可以写成纯虚函数
![[../../annex/0.C++总集_image_77.png]]

析构函数写成了纯虚函数，你还是要在类外去实现一下它
![[../../annex/0.C++总集_image_78.png]]

#### 3. 抽象类
抽象类就是普通函数在有了一个/一个以上的纯虚函数的时候就变成了抽象类。

抽象类的特点：
1、不能用来实例化对象，原来我们可以用 Father 去定义对象，现在不行了。抽象类是不能定义对象的。因为抽象类这个东西有个函数没有去实现，可以认为这个类不完整，不完整就不能去定义对象了
2、但是抽象类可以去定义指针，可以为子类服务。
![[../../annex/0.C++总集_image_79.png]]

Father 还是可以当成一个类型，类型还是存在的，有了类型还是可以去定义这种类型的指针的。
这个指针没有当前类类型的指针的对象被它去指，因为这个类不允许有对象，所以就只能去为子类服务。当然子类的子类也可以，只不过自己的类就属于没有对象。

![[../../annex/0.C++总集_image_80.png]]

如果存在这样的类，它拥有多个这样的纯虚函数，在子类中实现了两个纯虚函数，那只要你写了函数体，这个函数它就不再是纯虚函数了，（还有一个纯虚函数没有去实现它），那么这个时候子类里面其实也就是相当于还有一个纯虚函数，那他既然还有一个纯虚函数，那么这个子类也属于是抽象类。
也就是说纯虚函数/抽象类对于这一特质，它是可以遗传的。
相当于父类有多个纯虚函数，或者说只要你在子类当中没有把父类所有的纯虚函数都实例化，那么子类也是抽象类，也不能去实例化对象。简单来说，一个类当中只要有纯虚函数，无论从何而来（自己写的也好，继承而来的也罢），这个类就是一个抽象类，就不能去实例化对象。

菱形继承的时候，加了 virtual 关键字去继承，其父类称之为虚基类，也就是你在使用这个继承的时候，加上了 virtual 关键字，那么这个基类就可以称之为虚基类。它的存在就是解决菱形继承的弊端，防止你从同一个父类继承多份相同的书籍，这种东西主要是用在多继承上面，特别是在一个类族里面。如果不使用虚基类，就非常容易把最上层的父类的内存继承多份。

再写一个 class Grand_Son，试用：
![[../../annex/0.C++总集_image_81.png]]

搞一个父类类型的指针，当这个父类类型的指针指向这个子类的时候，把这个东西拿出来。把 test 拿出来
![[../../annex/0.C++总集_image_82.png]]

如果想要比较稳妥，想要它继续被子类重写，就继续声明为虚函数就行了。不写的话其实也会属于是重写的情况。

![[../../annex/0.C++总集_image_83.png]]

所以如果希望成员函数在子类里面继续是虚函数，希望它继续能够重写的话呢，那就加个 virtual 就好了（严格、保险起见），不加其实也是能够重写的。

![[../../annex/0.C++总集_image_84.png]]

![[../../annex/0.C++总集_image_85.png]]

##### 代码--纯虚函数的定义格式
#代码 #纯虚函数

```cpp
#include <iostream>
using namespace std;

class Father
{
public:
    Father();
    virtual ~Father() = 0;
    virtual void Fat_func() = 0;
};  

class Son : public Father //公有继承父类
{
public:
    Son();
    ~Son();          //显然，除了构造析构都会继承下来
    void Fat_func(); //在子类中写一个同名的函数
};
  
int main()
{
    // Father obj;//纯虚函数不能声明对象
    return 0;
}
  
//放到主函数后面
Father::Father() //父类构造
{
    cout << "Father::Father()" << endl;
}
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
}
Father::~Father() //父类析构
{
    cout << "Father::~Father()" << endl;
} 

Son::Son() //子类构造
{
    cout << "Son::Son()" << endl;
}
void Son::Fat_func()
{
    cout << "void Son::Fat_func()" << endl;
}
Son::~Son() //子类析构
{
    cout << "Son::~Son()" << endl;
}
```

##### 代码 2--纯虚函数--父子类和孙子类中纯虚函数能否传递

```cpp
//父类当中有虚函数，子类当中重写了，

#include <iostream>
using namespace std;

class Father
{
public:
    Father();
    ~Father();
    virtual void Fat_func() = 0; //声明虚函数：你在声明函数成员的时候，如果在函数前面加上 virtual 关键字
};

class Son : public Father //公有继承父类
{
public:
    Son();
    ~Son();          //显然，除了构造析构都会继承下来
    void Fat_func(); //在子类中写一个同名的函数
    /*
    virtual void Fat_func();
    如果想要比较稳妥，想要它继续被子类重写，就继续声明为虚函数就行了。不写的话其实也会属于是重写的情况。所以如果希望成员函数在子类里面继续是虚函数，希望它继续能够重写的话呢，那就加个 virtual 就好了（严格、保险起见），不加其实也是能够重写的。
    */
};
  
class Grand_Son : public Son
{
public:
    Grand_Son();
    ~Grand_Son();    //显然，除了构造析构都会继承下来
    void Fat_func(); //在子类中写一个同名的函数
    /*
    virtual void Fat_func();
    如果想要比较稳妥，想要它继续被子类重写，就继续声明为虚函数就行了。不写的话其实也会属于是重写的情况。所以如果希望成员函数在子类里面继续是虚函数，希望它继续能够重写的话呢，那就加个 virtual 就好了（严格、保险起见），不加其实也是能够重写的。
    */
};
  
int main()
{
    /*
         //验证父类的子类
        Father *p_fat;
  
        Son obj_Son1;
  
        p_fat=&obj_Son1;
        p_fat->Fat_func();
     */

    //验证子类和孙子类
    //相当于父类指针指向子类对象，然后通过这个指针去调的时候，它的函数是由什么决定的？
    //动态联编根据指向的对象的类型去调函数，静态联编会根据指针的类型去调函数
    Son *p_Son;
    
    Grand_Son obj_G_Son;
  
    p_Son = &obj_G_Son;
    p_Son->Fat_func();

    return 0;
}

//放到主函数后面
// Father
Father::Father() //父类构造
{
    cout << "Father::Father()" << endl;
}
/* void Father::Fat_func()//纯虚函数，不能实现函数体和声明对象。要在子类中完成
{
    cout << "void Father::Fat_func()" << endl;
} */
Father::~Father() //父类析构
{
    cout << "Father::~Father()" << endl;
}
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
}
// Son
Son::Son() //子类构造
{
    cout << "Son::Son()" << endl;
}
void Son::Fat_func()
{
    cout << "void Son::Fat_func()" << endl;
}
Son::~Son() //子类析构
{
    cout << "Son::~Son()" << endl;
}
// Grand_son
Grand_Son::Grand_Son() //孙子类构造
{
    cout << "Grand_Son::Grand_Son()" << endl;
}
void Grand_Son::Fat_func()
{
    cout << "void Grand_Son::Fat_func()" << endl;
}
Grand_Son::~Grand_Son() //孙子类析构
{
    cout << "Grand_Son::~Grand_Son()" << endl;
}
```

##### Time
[2023-07-22 18：01：56]

---

### 06-04 final
#### 1 、权限掠夺者
final 可以掠夺你的权限，终结你的操作。final 的作用就是让某些可以不断延续下去的东西结束掉。
可以用在两个方面：1. 函数方面 2. 用再类上面

#### 2 、掠夺函数权限：阻止重写
如果虚函数加上了 final，从此虚函数在子类里面就不能再被重写了。
加上 final，当前类为最后一次可重写类，其子类无法再重写
语法格式：在函数后面加上 final（写在参数表后面）

##### 代码-掠夺函数的权限
#代码 #final关键字 #掠夺函数权限

```cpp
// 12 - 4 - 1final关键字 --掠夺函数权限
//父类当中有虚函数，子类当中重写了，
  
#include <iostream>
    using namespace std;

class Father
{
public:
    Father();
    ~Father();
    virtual void Fat_func();
};

class Son : public Father //公有继承父类
{
public:
    Son();
    ~Son();          
    void Fat_func() final; //加上final，当前类为最后一次可重写类，其子类无法再重写
};
  
class Grand_Son : public Son
{
public:
    Grand_Son();
    ~Grand_Son();  
    // void Fat_func();
};
  
int main()
{
    /*
     Son *p_Son;
     
    Grand_Son obj_G_Son;
    
    p_Son = &obj_G_Son;
    p_Son->Fat_func();
  
    return 0;
    没有必要去探究指针指向什么东西了，因为不能再这么写了，没有这个函数了
    */
}
  
//放到主函数后面
// Father
Father::Father() //父类构造
{
    cout << "Father::Father()" << endl;
}
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
}
Father::~Father() //父类析构
{
    cout << "Father::~Father()" << endl;
}
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
}

// Son
Son::Son() //子类构造
{
    cout << "Son::Son()" << endl;
}
void Son::Fat_func()
{
    cout << "void Son::Fat_func()" << endl;
}
Son::~Son() //子类析构
{
    cout << "Son::~Son()" << endl;
}

// Grand_son
Grand_Son::Grand_Son() //孙子类构造
{
    cout << "Grand_Son::Grand_Son()" << endl;
}
/* void Grand_Son::Fat_func()
{
    cout << "void Grand_Son::Fat_func()" << endl;//子类中的虚函数用了final关键字，孙子类无法再重写虚函数
}
*/
Grand_Son::~Grand_Son() //孙子类析构
{
    cout << "Grand_Son::~Grand_Son()" << endl;
}
```

#### 3 、掠夺类的权限：阻止派生
只要在一个类上面写了 final，从此这个类就不能被派生了

##### 代码--掠夺类的权限
#代码 #final关键字 #掠夺类的权限

```cpp
// 12 - 4 - 2final关键字 --掠夺类的权限

#include <iostream>
using namespace std;

class ClassName final
{
    public:
        ClassName();
        ~ClassName();
  
    private:

};

class Son // : public ClassName//不管用什么权限方式，总之可以继承ClassName。但是父类中用final关键字，则无法子类无法再继承
{
    public:
        Son();
        ~Son();

    private:

}; 

int main()
{
    return 0;
}

//相关函数放在主函数后面
ClassName::ClassName()
{
}
ClassName::~ClassName()
{
}

Son::Son()
{
}
Son::~Son()
{
}
```

#### 纯虚函数 virtual+final
纯虚函数加上 final 会出现什么样的问题？

纯虚函数virtual必须要重写，否则这个类就是抽象类就不能创建对象。
而final 阻止被重写在子类中，这个函数不再是虚函数，不能再被重写了。

使用结果：既不能在子类当中重写函数，又不能在主函数中创建子类对象。

解决方法：不要这么做，从根源上解决这个问题。不要纯虚函数 virtual+final。否则的话，但凡这么写了，就是希望它所有的子类都是抽象类。

##### 代码--virtual+final
#代码 #final关键字 #virtual和final   

```cpp
// 12 - 4 - 3 virtual+final

#include <iostream>
using namespace std;

class ClassName
{
public:
    ClassName();
    ~ClassName();
    virtual void test() final = 0;

private:
};  

class Son : public ClassName//子类继承父类
{
public:
    Son();
    ~Son();
    // void test();//无法重写函数 

private:
}; 

class G_Son : public Son//孙子类继承子类
{
public:
    G_Son();
    ~G_Son();
    // void test();//无法重写函数
  
private:
}; 

int main()
{
    // G_Son obj_2;//孙子类也不能创建对象
    // Son obj_1;//创建不了对象
    return 0;
}
  
//相关函数放在主函数后面
ClassName::ClassName()
{
}
ClassName::~ClassName()
{
}
  
Son::Son()
{
}
Son::~Son()
{
}
  
G_Son::G_Son()
{
}
G_Son::~G_Son()
{
}
```

#### Time
[2023-07-23 11：52：47]

---

## 七、运算符重载
### 07-00概要
#### 学习目的
- 掌握运算符重载规则
- 能够自助实现运算符重载
- 通过重载运算符，扩展运算符的功能
![[../../annex/0.C++总集_image_86.png]]

#### 课程内容
- 基础语法
- 规则详解
- 重载>>和<<
- 注意事项

![[../../annex/0.C++总集_image_87.png]]

#### 重难点
- 基础规则
- 注意事项

![[../../annex/0.C++总集_image_88.png]]

---

### 07-01 基础语法
##### 1 、重载的概念
所谓的重载其实就是重新赋予它一个含义/给他一个新的内容
重载运算符其实就是给运算符一个新的含义。

##### 2 、在类中去重载运算符
最主要的目的就是重新定义运算符的运算规则。
运算符重载只不过就是去写一个新的函数而已，只不过这个新的函数所实现的功能就是重新赋予你运算符一个运算规则。
运算符重载本质上是用函数的重载。

[2023-07-23 12：33：02]

重载的运算符原来是单目/双目运算符，参数表中就只能有一个/两个参数。
如：+号属于双目运算符，那么参数列表中就只能有两个参数，而且必须是两个参数。
此处只看见了一个参数，是因为它作为成员函数的时候，这个 this 不见了（隐藏了），它要占一个位置
![[../../annex/0.C++总集_image_89.png]]

输出结果
![[../../annex/0.C++总集_image_90.png]]


![[../../annex/0.C++总集_image_91.png]]

##### 代码 
#代码 #运算符重载

```cpp
#include <iostream>
using namespace std;

//复数：实部，虚部 i i的平方平方应该是-1
//(3+2i) (0+6i) (5+0i)
//要实现复数的加法，肯定要写一个成员函数，才能够在类中把它进行重载
class Mycomplex
{
public:
    Mycomplex(double real = 0.0, double imag = 0.0);
    ~Mycomplex();
    void display() const; //显示当前所构建的虚数的对象里面的数据，只给显示，不给修改
    //返回值类型 函数名 (形参列表) {函数体}
    //唯一重要的区别就是它的函数名有要求，要重载哪个运算符，你的这个函数名就应该叫operator+运算符名称。operator本身是关键字，专门用来定义这个重载运算符的函数
    //函数名：operator运算符名称  

    Mycomplex operator+(Mycomplex other) //实际上+成员函数在参数表中有Mycomplex *this指针，只是我们看不见它，也就是说这里已经有一个参数了。我们需要的其实是另外一个Mycomplex other
    {
        Mycomplex obj;//创建一个对象
        obj.m_real=this->m_real + other.m_real;
        obj.m_imag=this->m_imag + other.m_imag;
        return obj;
    }
    
    // Mycomplex& operator+(const Mycomplex& other) const;//先声明后定义。这个地方要返回对象的话要调一次拷贝构造，所以可以返回一个引用& ，该函数只去做复数的加法，所以考虑只读取，不能修改，加上const。然后参数表也可以加上引用&，防止调拷贝构造。并且可以加上const防止参数被修改

private:
    double m_real; //实部
    double m_imag; //虚部
};
  
int main()
{
    /*
         //其实在平时已经用到过了运算符的重载，系统给的低保，像这样的重载我们也还是可以自己去实现的，赋予它低保以外的含义，实现更多的功能。
        6 + 1;//int+int
        3.14 + 5.12;//double+double
        6 + 3.14;//int+double
  
        int num = 0;
        char ch='A';
        cout << num << endl;//原来是左移的运算符，现在可以输出int类型的整数。
        cout << ch << endl;
     */
  
    Mycomplex obj_1(3, 2);
    obj_1.display(); 

    Mycomplex obj_2(4, 3);
    obj_2.display();

    //现在的问题是能否把两个复数加起来
    // obj_1 + obj_2;//+号没有把两个复数加起来的功能。需要重新去定义这种规则
/*
    int a, b, c;
    a = b = c = 0;
    a = b + c;//把后面看作是函数的调用的话，a=b.+(c)。.是取，+是函数名，()括号内的c是参数
*/

    Mycomplex obj_3;
    obj_3 = obj_1 + obj_2;//在此处直接写+号，究竟是哪一个对象在调用加的函数，哪一个对象是参数？加号无所谓，但是减号的话有减数和被减数之分。所以究竟是哪一种加的写法，我们在实现注意顺序的时候就不会有问题
    obj_3.display();
  
    //写成函数调用的形式
    //究竟对应的是哪一种的函数调用的形式
    //说到运算符就要说到结合性(往哪边靠)，根据结合性，加号是左结合性(双目运算符)，所以看左边,左边的东西去调的。所以说左结合性，左边就是当前对象，右边是参数。一般都是左结合性。
    obj_1.operator+(obj_2); // 属于是obj_1+obj_2的情况;//谁在前面会有区别
    obj_2.operator+(obj_1); // 属于是obj_2+obj_1的情况;
    return 0;
}

Mycomplex::Mycomplex(double real, double imag) //只需要在声明的时候给默认值，实现的时候不需要
: m_real(real), m_imag(imag)               //成员初始化列表
{
}

//用这种方法（先声明后定义）更加的安全，并且少了拷贝构造
/*
Mycomplex &Mycomplex::operator+(const Mycomplex& other) const //同样也是作为一个函数存在，用类名Mycomplex::去限定函数名
{
    return Mycomplex(this->m_real + other.m_real, this->m_imag + other.m_imag); //直接放回一个匿名对象(没有参数、没有名字的对象)//实部+实部作为实部的参数,虚部+虚部作为虚部的参数
} */

void Mycomplex::display() const
{
    cout << "(" << m_real << "+" << m_imag << "i)" << endl;
}
Mycomplex::~Mycomplex()
{
}
```


##### 3、在全局重载运算符

围绕语法，要重载运算符的话就写一个函数，函数名写成 operator+要重载的运算符名称。返回值类型随便去给，参数表有要求，几目运算符就有几个参数，如果写在类的里面的话有 this 指针，要占据普通成员函数的一个参数位置
![[../../annex/0.C++总集_image_92.png]]

##### 代码 
#代码 #全局重载运算符

```cpp
#include <iostream>
using namespace std;

//复数：实部，虚部 i i的平方平方应该是-1
//(3+2i) (0+6i) (5+0i)
//要实现复数的加法，肯定要写一个成员函数，才能够在类中把它进行重载
class Mycomplex
{
public:
    Mycomplex(double real = 0.0, double imag = 0.0);
    ~Mycomplex();
    void display() const; //显示当前所构建的虚数的对象里面的数据，只给显示，不给修改

    Mycomplex& operator+(const Mycomplex& other) const;//属于是写成成员函数

    friend Mycomplex &operator+(const Mycomplex &obj1, int num); //声明为友元函数，这个函数就能访问私有成员了

private:
    double m_real; //实部
    double m_imag; //虚部
};

Mycomplex &operator+(const Mycomplex &obj1,int num) //写成全局函数。现在没有this指针了，所以需要传两个这样的参数//我们可以不写两个复数相加的东西。可以考虑复数+整数的做法
{
    return Mycomplex(obj1.m_real + num, obj1.m_imag);//私有成员，在类的外部无法直接访问//实部直接+num，虚部不加，用原来的虚部
}
//现在我们可以做：(3+2i)+6=(9+2i)

int main()
{
    Mycomplex obj_1(3, 2);
    obj_1.display();

    Mycomplex obj_2(4, 3);
    obj_2.display();

    Mycomplex obj_3;//先定义出来，再进行赋值，而不是直接进行初始化。那么初始化的时候会调一个拷贝构造函数
    obj_3 = obj_1 + obj_2; //赋值函数。此处会有一个低保，赋值这个函数在类里面有一个低保，也就是赋值运算符会有一个重载，类当中是会有一个低保的。除了定义以外调赋值运算符实际上类中是有一个赋值运算符的重载的，有了这个重载才能直接用，否则的话凭什么能够把这两个对象加起来，然后赋值给obj_3.
    obj_3.display();  
    
    //对象之间可以赋值，凭什么？因为类里面实际上有一个默认提供给你的赋值运算符的重载，这个函数叫做赋值函数，属于任何一个类都会有的这么一个东西，其实每个类天生就会有至少四个默认的成员函数：构造函数、析构函数、拷贝构造、赋值函数。拷贝构造和赋值函数最大的区别就是发生的时间点不同，虽然都是通过赋值体现出来的。但是赋值发生在很多时候，而拷贝构造如果就通过赋值来体现的话，就应该发生在初始化的阶段。用一个对象直接构造另一个对象，或者说只要沾上赋值属于这么一个情况:
    Mycomplex obj_3 = obj_2;//所有用赋值运算符的可以认为肯定是调用了类里面的赋值函数，只有这种情况(用一个对象去初始化另一个对象)的时候，会调拷贝构造

    obj_3 = obj_1 + 6;
    obj_3.display();

    obj_3 = operator+(obj_1, 6); //翻译一下，obj_1和6都作为参数，传给operator+()函数。然后用obj_3去接收一下
    obj_3.display();
    //全局的也可以是直接调函数的写法，也可以是加的写法。
    // 缺陷：
    // obj_3 = 6 + obj_1;//不能这么写，因为没有这个重载，6在前面，6是第一个参数
    // obj_3 = operator+(6, obj_1); //相当于这种写法。如果需要换这个顺序的话，就应该调换一下参数位置，重新写一个重载
    obj_3.display();
    
    return 0;
}

Mycomplex::Mycomplex(double real, double imag) //只需要在声明的时候给默认值，实现的时候不需要
: m_real(real), m_imag(imag)               //成员初始化列表
{
}
//用这种方法（先声明后定义）更加的安全，并且少了拷贝构造
/*
Mycomplex &Mycomplex::operator+(const Mycomplex& other) const //同样也是作为一个函数存在，用类名Mycomplex::去限定函数名
{
    return Mycomplex(this->m_real + other.m_real, this->m_imag + other.m_imag); //直接放回一个匿名对象(没有参数、没有名字的对象)//实部+实部作为实部的参数,虚部+虚部作为虚部的参数
} */
void Mycomplex::display() const
{
    cout << "(" << m_real << "+" << m_imag << "i)" << endl;
}
Mycomplex::~Mycomplex()
{
} 

Mycomplex &Mycomplex::operator+(const Mycomplex& other) const //同样也是作为一个函数存在，用类名Mycomplex::去限定函数名
{
    return Mycomplex(this->m_real + other.m_real, this->m_imag + other.m_imag); //直接放回一个匿名对象(没有参数、没有名字的对象)//实部+实部作为实部的参数,虚部+虚部作为虚部的参数
}
```

### 07-02 规则详解
#### 1 、并不是所有的运算符都可以重载
##### 可以重载的 ：
加减乘除、
求余数的算术运算符、
6 个位运算符、
赋值运算符、
复合赋值运算符的加减等、
关系运算符 （< 、> 、≥ 、≤ 、= =、≠）、
逻辑运算符（与或非）、
自增自减、
逗号、
箭头、
new、delete（虽然是关键字，但是也可以重载），
###### 其中比较特殊一点的 ：
中括号（应该叫下标运算符）、
圆括号（圆括号作为函数调用运算符的时候可以重载），
自增自减（有前置和后置的区别，重载的时候需要注意一下，可以使用一个叫占位参数）、

注：
自增自减由于它本身所重载的运算符就是相同的，所以不管是前置还是后置，都是自增或者自减，它的参数、操作数什么的都一样，所以就搞一个占位参数才可以去区分一下他们。

占位重载，比如图中：多了一个 int 占了一个位置，但是并没有什么实际意义，就告诉我们两个函数是不一样的，仅此而已，这个就叫做占位参数
![[../../annex/0.C++总集_image_93.png]]
![[../../annex/0.C++总集_image_94.png]]


##### 不能重载 ：
sizeof 不能重载、
三目运算符不能重载、
成员运算符点、
作用域运算符

#### 2.重载不能改变运算符的优先级和结合性

相当于国家法规>地方法规
重载只能改变具体的规则，但是大层次上的优先级和结合性是不能改变的。比如说你去修改班级座位/班规，但是校规永远>班规

假设重载过了+号和* 号
重载完之后还是先算乘法，然后再去算加法，再按照赋值运算符优先级在此处最低的情况再把值赋给obj
![[../../annex/0.C++总集_image_95.png]]
相当于:obj = obj1 +( obj2 * obj3 ) ;
![[../../annex/0.C++总集_image_96.png]]

#### 3. 重载不会改变运算符的用法
就是说我们原来去用这个运算符的时候，它有几个操作数，就是说它原本是单目运算符，重载完后还是单目运算符。用法除了目数以外还有一条，操作数是在左边还是右边也是不会改变的（相当于是结合性不会被改变）。

#### 4. 运算符重载不能有默认的参数
我们是通过函数重载的这么一种形式去实现运算符的重载，那么运算符重载肯定是会有参数的。但是不能去增加默认的参数
举个例子：
加法写成全局函数是需要两个参数，而且两个参数它必须要传才能够做加法，不传的话少一个都加不了。但是如果给他一个默认的参数的话，传参数没问题，少传一个好像在函数层面上也可以正常调用。但是在运算符层面，本来需要两个东西才能加起来，现在有了一种默认的参数，一个东西也能加起来了。这就相当于改变了运算符的操作数, 也就改变了它的目数。

#### 5. 运算符重载函数可以作为类的成员函数，可以作为全局函数
作为类的成员函数时，是普通成员函数，有 this 指针，就是你自己，谁去调这个成员函数的时候就会去指向它，所以说只需要一个参数。（由于 this 指针占用了一个位置，所以作为成员函数去写的话，重载任何运算符都要在它原本目数的数量下减少一个参数）
但是作为全局函数就没有 this 指针，该是多少个参数就是多少个参数。

#### 6. 箭头运算符、下标运算符、赋值运算符、函数调用运算符只能以成员函数的形式重载

箭头运算符<font color="#ff0000">-></font>、
下标运算符 <font color="#ff0000">[]</font>、
赋值运算符 <font color="#ff0000">=</font>、
函数调用运算符<font color="#ff0000"> ( )</font>、
只能以<font color="#ff0000">成员函数</font>的形式重载 

也有最好用全局函数去写的运算符重载，输入输出的左移右移的那两个重载

#### 代码
#代码 #运算符重载规则详解

```cpp
#include <iostream>
using namespace std;

int main()
{
    // 重载只能改变具体的规则，但是大层次上的优先级和结合性是不能改变的。比如说你去修改班级座位/班规，但是校规永远>班规
    /*假设重载过了+号和*号
    obj = obj1 + obj2 * obj3;//重载完之后还是先算乘法，然后再去算加法，然后再按照赋值运算符优先级在此处最低的情况再把值赋给obj
    相当于:obj = obj1 +( obj2 * obj3 ) ;
    */
    return 0;
}

/*
 07 - 02 规则详解
1 、并不是所有的运算符都可以重载
    可以重载的 ：
    加减乘除、 求余数的算术运算符、 6 个位运算符、 赋值运算符、 复合赋值运算符的加减等、 关系运算符 （< 、> 、≥ 、≤ 、= =、≠）、 逻辑运算符（与或非）、 自增自减、 逗号、 箭头、 new、delete（虽然是关键字，但是也可以重载）
    
    其中比较特殊一点的 ：
    中括号（应该叫下标运算符）、 圆括号（圆括号作为函数调用运算符的时候可以重载），
    自增自减（有前置和后置的区别，重载的时候需要注意一下，可以使用一个叫占位参数）、

    注：
    自增自减由于它本身所重载的运算符就是相同的，所以不管是前置还是后置，都是自增或者自减，它的参数、操作数什么的都一样，所以就搞一个占位参数才可以去区分一下他们。

    占位重载，比如图中：多了一个 int 占了一个位置，但是并没有什么实际意义，就告诉我们两个函数是不一样的，仅此而已，这个就叫做占位参数
  
    不能重载 ：
    sizeof 不能重载、
    三目运算符不能重载、
    成员运算符点、
    作用域运算符
 */

/*
2.重载不能改变运算符的优先级和结合性
    相当于国家法规 > 地方法规
    重载只能改变具体的规则，但是大层次上的优先级和结合性是不能改变的。比如说你去修改班级座位 /班规，但是校规永远 >班规

假设重载过了 +号和 *号
    重载完之后还是先算乘法，然后再去算加法，再按照赋值运算符优先级在此处最低的情况再把值赋给obj
 */

/*

3. 重载不会改变运算符的用法
    就是说我们原来去用这个运算符的时候，它有几个操作数，就是说它原本是单目运算符，重载完后还是单目运算符。用法除了目数以外还有一条，操作数是在左边还是右边也是不会改变的（相当于是结合性不会被改变）。

4. 运算符重载不能有默认的参数
    我们是通过函数重载的这么一种形式去实现运算符的重载，那么运算符重载肯定是会有参数的。但是不能去增加默认的参数
        举个例子：
        加法写成全局函数是需要两个参数，而且两个参数它必须要传才能够做加法，不传的话少一个都加不了。但是如果给他一个默认的参数的话，传参数没问题，少传一个好像在函数层面上也可以正常调用。但是在运算符层面，本来需要两个东西才能加起来，现在有了一种默认的参数，一个东西也能加起来了。这就相当于改变了运算符的操作数,也就改变了它的目数。

5. 运算符重载函数可以作为类的成员函数，可以作为全局函数

    作为类的成员函数时，是普通成员函数，有 this 指针，就是你自己，谁去调这个成员函数的时候就会去指向它，所以说只需要一个参数。（由于 this 指针占用了一个位置，所以作为成员函数去写的话，重载任何运算符都要在它原本目数的数量下减少一个参数）
        但是作为全局函数就没有 this 指针，该是多少个参数就是多少个参数。

6. 箭头运算符、下标运算符、赋值运算符、函数调用运算符只能以成员函数的形式重载

    箭头运算符->
    下标运算符[]
    赋值运算符 =
    函数调用运算符 ()
    只能以成员函数的形式重载

    也有最好用全局函数去写的运算符重载，输入输出的左移右移的那两个重载
*/
```


### 07-03 重载 >> 与 <<
##### 1 、作为友元函数去重载
建议作为友元函数去重载，也可以作为成员函数去重载
重载的时候是需要两个参数的，那么他需要的这些参数如果把它作为成员函数去写的话，需要改动的地方有很多才能够实现。所以作为友元函数，不要 this 指针。
会涉及两个类：istream：输入、Ostream：输出

##### 2 、istream：输入

##### 3 、ostream：输出


![[../../annex/0.C++总集_image_97.png]]

运行结果
![[../../annex/0.C++总集_image_98.png]]

实际情况：
![[../../annex/0.C++总集_image_99.png]]

![[../../annex/0.C++总集_image_100.png]]

![[../../annex/0.C++总集_image_101.png]]

![[../../annex/0.C++总集_image_102.png]]

#### 代码
#代码 #重载输入和输出

```cpp
/*
通过重载的过程会发现，如果运算符重载是通过友元函数重载，有两个参数，则一般写成第一个参数是cin/cout，当前类的对象写在后面(第二个参数)。

如果运算符重载写成成员函数，则会有this指针，this指针位置是第一个参数，在最前面。所以写成成员函数的话，那么就需要去改系统里面的文件，很麻烦。(可以写，但是麻烦，由于当前类的对象是在运算符的后面的，不适合写成成员函数。)

所以一般写成友元函数更好。
 */
#include <iostream>
using namespace std;

class MyComplex
{
public:
    MyComplex(double real = 0.0, double imag = 0.0)
    : m_real(real), m_imag(imag)
    {}

    friend istream &operator>>(istream &in, MyComplex &com);  //声明友元关系，调用私有成员
    friend ostream &operator<<(ostream &out, MyComplex &com); //声明友元关系，调用私有成员

// private://不知道为什么，把运算符重载的函数声明成了友元friend关系还是会报错，提示不可访问。所以干脆改成了公有成员好了。
    double m_real;
    double m_imag;
};

istream& operator>>(istream &in, MyComplex &com) //考虑到返回引用的话要用到拷贝构造。参数表里面的两个参数是什么看>>两边内容的类型。这个istream写void是可以的。只不过你写这个函数一般是为了可以连续输入多个对象，则用istream(因为要有返回值类型)
{
    in >> com.m_real >> com.m_imag; //发现访问不到，因为访问的成员m_real是私有的，所以考虑去用友元。in当成cin去用就行了
    return in;//为什么需要返回值：如果只单独一次输入就可以，有时候连续的去输入，则需要return in
}

ostream& operator<<(ostream &out, MyComplex &com)
{
    out << "(" << com.m_real << "+" << com.m_imag << "i)"; // out当成cout去用就行了
    return out;
}

int main()
{
/*
    MyComplex obj(2, 3);
    int n;    //看看int类型的n是怎么样存在的。
    
    cin >> n; // istream输入类型
    // cin >> obj >> obj1 >> obj2;//有时候连续的去输入，则需要return in

    // cin >> obj;//那么同样的，假设obj一开始没有给他们参数，先cin输入一下这个obj里面相关的东西，然后再输出，这个也是不允许的

    cout << "suibian" << endl;

    // cout << obj << endl;//希望直接输出obj，现在做不到这样的事情。因为<<输出运算符需要认识obj的类型，但是没有针对这种类型的重载。那么同样的，假设obj一开始没有给他们参数，先cin输入一下这个obj里面相关的东西，然后再输出，这个也是不允许的
 */

    MyComplex obj;
    cin >> obj;//声明和实现时的参数表不统一，声明时比实现时参数表中的Mycomplex &com少了引用&，导致报错：有多个运算符">>"与这些操作数匹配
    //实际上通过">>"输入的重载，执行运算符重载函数的函数体中的"in >> com.m_real >> com.m_imag;"把实部和虚部依次输入进去，然后再一次输出返回。
    cout << obj << endl;//调用的时候实际上是把cin传给istream运算符重载函数中参数表的第一个参数istream& in中的in，把cout传给ostream运算符重载函数中参数表的第一个参数ostream& out中的out
  
    //作为函数调用的形式去写:(与上面的写法其实的一样的)
    // cin.operator>> // cin只是一个对象而已，通过一个对象去调用一个函数，没有问题。
    operator>>(cin, obj); //全局函数，所以直接用operator。//相当于cin>>obj;
    operator<<(cout, obj); //相当于是cout<<obj;

    MyComplex obj_1;//假设还有一个对象
    cin >> obj >> obj_1;//连续去输入。
    operator>>(operator>>(cin, obj), obj_1); //首先，肯定是从左到右去输。相当于是先输入obj,然后返回一个值，返回的一个值就是cin，然后再去输入obj_1。是一个函数的嵌套调用。
    //cin>>obj相当于最里面一层括号内的operator>>(cin,obj)，然后再返回一个值与第二层括号的obj_1就行输入。
    // 为什么可以这样去嵌套调用呢？因为前面写返回值类型是istream。有返回值的函数调用可以作为其他函数的实参。

    cout << obj << endl << obj_1 << endl;//连续去输出，会是什么样的形式呢？
    operator<<(operator<<(cout, obj), obj_1); //相当于是这个。

    return 0;
}
```

#### Time
[2023-07-26 17：49：49]

---

### 07 -04 运算符重载的注意事项
##### 1 、运算符重载的语法规则非常简单，关键是规则。
写成成员函数就会少一个参数，少的就是调用当前函数的这个 (左边那个)。

##### 2 、可以显示调用，也可以隐式调用。
直接调函数就是显示调用，看得到这个函数。
如：
operator>>(cin, obj);
operator<<(cout, obj);
operator>>(operator>>(cin, obj), obj_1);
operator<<(operator<<(cout, obj), obj_1);

也可以隐式调用，也就是直接写运算符，看不见这个函数。
如：
cin >> obj;
cout << obj << endl;
cin >> obj >> obj_1;
cout << obj << endl << obj_1 << endl;

##### 3 、注意与友元的联合使用。
友元虽然会破坏封装，但是在这样的地方就很适合使用。
需要注意的是，虽然破坏封装可以访问到私有成员，不过要注意不要再这些友元函数中对这些私有成员进行修改。所以就可以考虑加个 const (只读)，使其只能查看，不能修改，就不会去影响到他的封装。

##### 还需要注意的一个点 ：赋值函数
赋值运算符是有一个默认的赋值函数的，不需要你自己去把它进行一个重载。但是参考拷贝构造里面的深拷贝和浅拷贝，在这里赋值其实也就是一样的，因为默认的赋值函数里面的函数体给你执行的逻辑其实和默认的拷贝构造函数是一样的。就是把两个对象之间同名的 (对应的成员)一一对应的去给个值，这是默认的赋值函数会去做的事情。但是像之前拷贝构造一样，指针指向不能直接给过去，要重新去申请一段内存。赋值函数同理，不能直接简单的就把指向赋值过去，需要重新申请内存，然后再给过去。把内存里面的内容拷贝过来，指向就指当前的这一段内存。也就是说，涉及到指针，不但自己的拷贝构造要自己去写深拷贝，像赋值函数，就需要自己去实现一下。

---

## 八、模板
### 【模板】08-00 概要
让代码能够最大限度的进行重用 (重复使用)。降低代码重复书写率
#### 学习目的
了解并理解模板的概念
熟悉函数模板的使用
熟悉类模板的使用

![[../../annex/0.C++总集_image_103.png]]

#### 课程内容
模板的概念
函数模板
类模板
模板与友元

![[../../annex/0.C++总集_image_104.png]]

#### 重点难点
函数模板
类模板

![[../../annex/0.C++总集_image_105.png]]

---

### 【模板】08-01 模板的概念
##### 1 、模板与泛型编程
泛型编程：实际上就是说我们可以编写一些和类型无关的逻辑代码。
写的代码不用去看数据类型，只看逻辑关系就可以了。只需要知道要做的逻辑操作是什么，类型可以后续作为参数的形式给它传过来。

模板：模板是实现代码重用的一种工具，它的作用就是可以实现一种叫做类型参数化的一个操作（把类型也变成一个参数）。为了实现代码和逻辑没关系，可以达到某一种效果，模板就可以把类型也作为参数去进行传递。

类型参数化：数据类型通过模板，就可以把类型也作为参数传到（函数）里面去。

模板是泛型编程的前置条件（基础条件/必要不充分条件）。

##### 2 、模板分类（函数模板、类模板）
分为函数模板和类模板。
函数模板可以定义出模板函数，模板函数就是用模板做出来的函数

### 【模板】08-02 函数模板
##### 1 、函数模板是什么？
函数模板就是一种写代码的方式（方法/语法格式）

用函数模板写出来的模板函数有一个特点：
这个函数里面所涉及到的数据类型，它需要通过参数传进来。所以在你没有传数据类型的参数之前，该函数应该是不完整的。（一个完整的函数应该是要知道数据类型的）。但是通过函数模板写出来的模板函数是不知道当前应该有什么样的类型的数据。

因为不完整，所以编译器不会对模板函数去生成可执行的代码。
也就是说，定义了模板函数之后，只是对这个函数的功能框架有了一个描述。直到去调用这个函数的时候，因为调用函数的时候必然要传参数，一传参数，数据类型就传过来了。传过来后当前函数就完整了。函数完整后就可以被编译，生成可执行的代码。

##### 2 、函数模板的定义语法
 通过函数模板定义模板函数

 template(定义模板的关键字)
 typename(用来声明类型参数的关键字)
 <>(尖括号属于是类型的参数列表)
 关键字+类型名
 写类型的时候(typename)也可以写成是class

 语法:
```cpp
// template(定义模板的关键字)
// typename(用来声明类型参数的关键字)
// <>(尖括号属于是类型的参数列表)
// 关键字+类型名
// 写类型的时候(typename)也可以写成是class。在这里class不再是声明类的意思了，属于是用来声明类型的参数的东西，一般习惯用typename

 template <typename Type_1,...,typename Type_n>
 返回值类型 函数名(形参列表)
 {
    函数体;
 }
```


##### 3 、函数模板示例代码

先传类型，再传数据
![[../../annex/0.C++总集_image_106.png]]

![[../../annex/0.C++总集_image_107.png]]

![[../../annex/0.C++总集_image_108.png]]


两种类型的数据传过去，Type 无法确定，报错
![[../../annex/0.C++总集_image_109.png]]

<>指明类型则可以执行
![[../../annex/0.C++总集_image_110.png]]

##### 代码 1-模板函数的基本语法和使用
#代码 #函数模板

```cpp
/*
 通过 函数模板 定义 模板函数
 template(定义模板的关键字)、typename(用来声明类型参数的关键字)。<>(尖括号属于是类型的参数列表)、关键字+类型名。
 写类型的时候(typename)也可以写成是class。在这里class不再是声明类的意思了，属于是用来声明类型的参数的东西，一般习惯用typename
 
 语法:
 template <typename Type_1,...,typename Type_n>
 返回值类型 函数名(形参列表)
 {
    函数体;
 }

调用的语法:
 函数名<类型列表>(实参列表);

 */

#include <iostream>
using namespace std;
  
/*
template <typename T1,typename T2>//类型的参数表
T1 add(T1 a,T2 b)//数据的参数表，函数代码的时候不要再去考虑类型，因为函数体内的类型要根据后面(template一行处)传参数传过来是什么类型就是什么类型
{
    return a + b;
}
*/
/*
 int add(int a,int b)//可以void,int等,也可以用上面的这些类型T1,T2
{
    return a + b;
}
*/

template <typename Type>
Type add(Type a, Type b)
{
    return a + b;
}

template <typename TT1,typename TT2>
void test(TT1 tt1,TT2 tt2)
{
    cout << "tt1=" << tt1 << endl
         << "tt2=" << tt2 << endl;
}
  
int main()
{//属于是隐式的推导类型，让编译器自动的给你把类型推断出来。需要一个前提条件:要传的参数不会导致你的类型推导错误
//显示指定类型，直接通过<>告诉编译器需要的是哪种类型，那么不管你后面参数怎么传，参数已经定好了。

    test(1, 2);//先传的是类型，此处的1，2本身具有类型。1的类型传给templa中的TT1，1传给函数test中的tt1。同理可知2。
    test(1.213, 3.153);//double类型，输出时使用cout的话C++自动会舍弃掉后面的零。
    test("name", 'S');//string类型和字符型。
    //如果传的参数是自定义的类的类型，那么就需要事先重载一下输出(<<)，否则无法输出

    cout << add(3, 4) << endl;
    cout << add(1.23, 2.46) << endl;

    // cout << add(6, 3.14) << endl;//没有与参数列表匹配的函数模板add(参数类型有两种，无法确定是哪一种)
    //数据的参数是看得见的，在(调用)传参的时候传过去。数据的参数也可以用参数缺省，可以少传两个。
    // 那么类型的参数应该怎么样去传呢？
    // 类型的参数实际上也应该在调用的时候传过去。传到哪个地方呢？
    // 首先，传参需要知道函数名(add)，
    // 另外，类型是在数据前面确定的(Type a, Type b)，所以说在中间搞一个尖括号<>，把类型传过去就可以了
    cout << add<int>(6, 3.14) << endl;//指明了参数的类型是int(int作为参数传到了Type中)。而3.14实际上是作为double类型传给了int类型的b
    cout << add<double>(6, 3.14) << endl;//同理，6传给double类型的a去接收

    test<const char *, char>("name2", 'S2'); // name2是字符串，字符串没必要每次都使用C++的string类，因为这个东西实际上就是char类型的指针，字符串的首地址。可以加const，加不加const都可以。一般情况下，字符串是默认不能被修改的，可以考虑加上const
  
    return 0;
}
```


##### 4、函数模板和普通函数对比（重载情况下到底调用哪种函数）
模板函数和普通函数一样，也是可以去重载的，只需要满足重载的条件即可。

模板函数和普通函数也能构成重载。什么意思呢？
假设同一个函数名写了四个函数，其中两个是模板函数，两个是普通全局函数。这四个函数可以互相构成重载。如果出现模板函数和普通函数之间的重载，我们首先会调用的应该是普通的函数，因为假设写的代码是一个隐式推导类型的调用，那么编译器就会认为你所需要调用的是没有写成模板的这两个重载，优先会去考虑这些普通的函数。
但是如果重载的函数是 3 个、4 个参数的，而普通的函数是 1 个参数/2 个参数的，可是普通的隐式推导类型，但是你传的是 3 个参数，那么这个情况下就会优先去调用模板函数。因为模板可以更好的调用的匹配。（根据参数的个数匹配最适合的）
如果想强制的去调用模板，比如说有两个这样的同名函数构成重载，第一个是普通全局函数 (两个 char 类型参数)，第二个是模板函数 (两个 int 类型参数)，那么这个时候想去强制调用模板的话，模板不用指定类型，就可以显示的指定一下要调用的是什么样的类型
（强制调用模板通过显示的去调用即可 (参数类型不一样时才可））

##### 5 、模板的局限性

##### 代码 2-重载模板函数
#代码 #函数模板 

```cpp
#include <iostream>
using namespace std;

class MyData
{
public:
    MyData(int n = 0) : num(n) {} //构造函数，并且带成员初始化列表和默认参数//在需要带参构造的情况下，不想重新去写一个无参构造，可以考虑给初始的缺省值(给了缺省值不传参数也能调用)

    int num;
};

template <typename T>
bool func(T &a, T &b)
{
    if (a == b)
    {
        return true;
    }
    return false;
}

template <>//重载模板函数，类型传都不传。
bool func(MyData &a, MyData &b)//在这里T类型不认识，直接用MyData类型的参数做两个引用出来//写一个专门处理MyData类型情况下的比较
{
    if (a.num == b.num)
    {
        return true;
    }
    return false;
}

int main()
{
    int num, val;
    num = val = 9;

    cout << (func(num, val) ? "true" : "false") << endl;      //三目运算符表达式。是就输出true，否则输出false
    cout << (func<int>(num, val) ? "true" : "false") << endl; //指定一下是int类型
    //需要使用到一个==的运算符，等号对于基本数据类型来说，我们可以直接使用这个等号，判断他们是否相等。但是MyData是刚刚自己写的一种数据类型，MyData这样的类型传过去，不能直接用等号对他们进行一个比较。(报错:没有找到接收MyData类型的左操作数的运算符等号)，也就是说不能通过等号去比较MyData类型的对象obj_1和obj_2，它不认识这种类型。  

    MyData obj_1, obj_2(5); //修改一下，给obj_2传个参数5.此时不相等，输出结果为false
    cout << (func(obj_1, obj_2) ? "true" : "false") << endl;
    cout << (func<MyData>(obj_1, obj_2) ? "true" : "false") << endl; //指定一下是MyData类型
    //自定义的类型运算符不认识，无法执行代码，可以进行运算符的重载
    //如果不通过重载运算符等号==,就通过模板函数(函数模板),能不能比较呢？(写一个模板函数本就希望什么类型都可以比较一下)。
    //怎样才能实现呢？
    //我们需要把模板函数针对这种MyData类型可以去写一个重载,实际上重载等号==会更好。

    return 0;
}
```


##### Time
[2023-07-27 18：28：58]

---

### 【模板】08-03 类模板
##### 1 、类模板是什么？
可以理解为是类的框架，同样是不完整的类。
类模板需要指定了数据类型之后才能定义对象

##### 2、类模板的定义语法

```
 template <类型参数列表>
 Class 模板类名
 {
    成员;//用类型参数列表传过来的类型
 };//定义域，需要加分号

 类型参数列表: <class T1,...,class Tn>//用 Typename 也可以，一般用 class
 成员: T 1 name;... Tn name;
```

##### 3 、类模板示例代码
##### 代码-类模板的语法
#代码 #类模板

```cpp
/*
 template <类型参数列表>
 class 模板类名
 {
    成员;//用类型参数列表传过来的类型
 };//定义域，需要加分号

 类型参数列表: <class T1,...,class Tn>//用Typename也可以，一般用class
 成员:T1 name;...Tn name;
*/

#include <iostream>
using namespace std;

template <class T1 = int, class T2 = double> //类型参数列表也可以初始化(给默认的类型)
// template <class T1, class T2>
class MyData
{
public:
    MyData(T1 n = 0, T2 v = 0.0) : num(n), val(v){};
    // ~MyData();
    
    // get/set去访问
    T1 getNum() { return num; } //内联
    T2 getVal() { return val; }
    void setNum(T1 n) { num = n; }
    void setVal(T2 v) { val = v; }
    
    void showData();

private:
    T1 num;
    T2 val;
};

template <typename Type1, typename Type2> //这两个类型会在调用这个函数的时候.当需要使用showData函数的时候必然有对象去调用这个函数，有对象就说明已经有类型了，于是就把类型T1,T2按顺序给Type1,Type2。参考函数的传参
void MyData<Type1, Type2>::showData()     //直接访问访问不了，MyData的类型不确定，类是不完整的，不能访问
{
    cout << "num=" << num << ",val=" << val << endl;
}
  
int main()
{
    //如何指定模板类的类型？就在创建的时候去指定类型。
    // 为什么是在创建对象的时候呢？因为只有在创建对象的时候才知道当前创建对象需要什么类型
    //创建对象时每个类都不一样，这就是模板类的强大之处。都是同一个类的对象，但是数据类型不一样
    MyData<int, double> data_1(3, 3.14); //定义对象，首先先把类型补充完整。不过此处，由于有两个类型，而此处设置的参数也只有两个参数，上面template时已经初始化了类型，它也能够自动推导出来，所以可以不写类型补充<int,double>。
    data_1.showData();

    MyData<char> data_2(67, 3.14); // char传递给T1,T1是char类型的话num也是char,于是showData中num得到的是C，而val还是3.14，相当于<>中写的是<char,double>，不过由于有默认类型，所以说它也可以自动推导double出来
    data_2.showData();

    MyData<char, float> data_3(68, 3.14f);
    data_3.showData();

    return 0;
}
```


##### 4、类模板做函数的参数
类模板作为函数的话，类模板该怎么写？参数该怎么传？（有多种不同的方式）
主要有 3 种类型的情况
1、指定一下作为参数的对象是什么样的情况
2、

![[../../annex/0.C++总集_image_111.png]]

##### 代码--类模板做函数的参数
#代码 #类模板

```cpp
/*
类模板作为函数的话，类模板该怎么写？参数该怎么传？（有多种不同的方式）

主要有 3 种类型的情况

1、指定一下作为参数的对象是什么样的情况
2、

*/

#include <iostream>
using namespace std;

template <class T1 = int, class T2 = double> //类型参数列表也可以初始化(给默认的类型)
// template <class T1, class T2>
class MyData
{
public:
    MyData(T1 n = 0, T2 v = 0.0) : num(n), val(v){};
    // ~MyData();

    // get/set去访问
    T1 getNum() { return num; } //内联
    T2 getVal() { return val; }
    void setNum(T1 n) { num = n; }
    void setVal(T2 v) { val = v; }
   
    void showData();

private:
    T1 num;
    T2 val;
};

template <typename Type1, typename Type2> //这两个类型会在调用这个函数的时候.当需要使用showData函数的时候必然有对象去调用这个函数，有对象就说明已经有类型了，于是就把类型T1,T2按顺序给Type1,Type2。参考函数的传参
void MyData<Type1, Type2>::showData()     //直接访问访问不了，MyData的类型不确定，类是不完整的，不能访问
{
    cout << "num=" << num << ",val=" << val << endl;
}

//这个函数有什么用？
//这个函数就可以接收像data_1这样的东西。
// test_Func_1()就只能去接收data_1这样的参数。
void test_Func_1(MyData<int, double> &obj) //普通全局函数，直接指定需要一个MyData类型的对象。这个对象指明了需要int和double这两种类型组合出来的对象，并且还考虑少掉一次拷贝构造，传引用&。
{
    obj.showData();
}
  
//第二种，把函数的参数模板化(把它也写成一个模板)
template <typename TT1,typename TT2>
void test_Func_2(MyData<TT1,TT2>& obj)
{
    obj.showData();
}

//把整体的参数都写成一个模板
template <class T>
void test_Func_3(T &obj)
{
    obj.showData();
}

int main()
{
  
    MyData<int, double> data_1(3, 3.14);
    test_Func_1(data_1); // test_Func_1()就只能去接收data_1这样的参数。
  
    MyData<char> data_2(67, 3.14);
    // test_Func_1(data_2);//假设让这个函数去接收data_2这样的类型就会有问题。因为data_2是char和double,而函数的类型却是int和double。类型不匹配。所以接收不了。

    MyData<char, float> data_3(68, 3.14f);
    data_3.showData();

    test_Func_2(data_1);//隐式
    test_Func_2<int, double>(data_1);//显式

    test_Func_2(data_2);//不写类型也能自动推导出来。
    test_Func_2<char,double>(data_2);

    //相当于把整体的( MyData<char, float>)类型就直接赋给了T，然后T就做一个这样的对象的引用
    test_Func_3(data_1);
    test_Func_3<MyData<>>(data_1);
    test_Func_3(data_2);
    test_Func_3<MyData<char>>(data_2);
    test_Func_3(data_3);
    test_Func_3<MyData<char, float>>(data_3);

    return 0;
}
```


##### 5. 类模板和继承
类模板定义出来后要能够继承出去。
模板类可以派生子类，只不过子类在继承的时候，要先确定一下从父类继承的东西希望是什么样的类型。
父类也不知道，于是通过子类去告诉它希望从你这里继承一个什么样的类型的。
也就是说在做继承与派生的过程当中，父类是模板的话，子类在去继承的时候，告诉父类需要的数据类型就可以了。

![[../../annex/0.C++总集_image_112.png]]

![[../../annex/0.C++总集_image_113.png]]

##### 代码--类模板和继承
#代码 #类模板
```cpp
#include <iostream>
using namespace std;

template <class F_Type>//father type
class Father
{
    public:
        F_Type m_F_val;
};

/*
 //不写模板的情况
class Son : public Father<int>//相当于把int给F_Type,就继承了int类型
{
    public:
        int m_S_Val;
}; */

//写模板的情况(把子类也写成是模板)
template <class S_Type_1,class S_Type_2>
class Son : public Father<S_Type_1> //不一定重复类继承一个int,先把type1传给父类那里继承过来的东西
{
public:
    S_Type_2 m_S_Val;//然后用type2自己去定义一些类型
};

//孙子类和子类参照子类和父类

int main()
{
    //定义对象的时候需要去指定一下类型
    Son<int, double> obj_son; // int传给父类,double自己用
    obj_son.m_F_val;          //然后就可以点到父类的val;
    obj_son.m_S_Val;          //以及子类自己的val

    return 0;
}
```

##### 6. 注意事项
类模板当中的成员函数，一开始因为没有创建对象，所以不知道这些函数里面要使用的类型是什么。
所以就会在一开始编译的时候是链接不到的，一直要到有了这个对象，给了类型之后才会生成可执行代码。

如果要写模板，就需要把这个类的声明，以及这个类的成员函数的实现都写在同一个文件里面。
一般情况下，写模板的文件的后缀不用 .cpp/ .h ，用 .hpp

---

### 【模板】08-04 模板与友元
希望有友元，打破一下模板里面的一些数据的封装。相当于在类模板中去使用友元函数
所以先写一个模板类。通过类模板使用引擎模板类。

在模板类里面使用友元的话，如果可以就别用。如果非要用，能够写到类里面实现就写在类里面实现。不能写在类里面实现--如果要在类里面声明，类的外面实现的话，首先要在声明的时候在函数名的后面加上尖括号<>。实现函数体的时候要注意一下类型 (可能需要 template<>)。
最后要在前面声明一下，让他们互相认识。否则还是做不了。

##### 代码--模板和友元
#代码 #模板和友元

```cpp
#include <iostream>
using namespace std;

//先声明一下，不然会出错
template <class T>//所以有这么四行的东西都要声明一下。
class A;//这个类要声明又要把类型带上
//先声明一下，不然会出错
template <typename T>//而要声明一下类型，发现又要声明一下类
void show_2(A<T> &obj);//其实只要声明一下这个函数，但是发现声明一下这个函数需要就需要把类型声明一下。
  
template <class T>
class A
{
    public:
        A(T t = 0) : m_a(t){};

    private:
        T m_a;
  
        friend void show_1(A<T> &obj) //直接在类的内部写友元函数体
        {
            cout << obj.m_a << endl;
        }

        friend void show_2<>(A<T> &obj);//还需要说明一下它的这个模板类的友元: 在函数体的后面加上尖括号
};

template <typename T>//这里的T和前面的T没有必然联系的
void show_2(A<T>& obj)
{
    cout << obj.m_a << endl;
}

int main()
{
    A<int> obj_a(666);

    show_1(obj_a);
    show_2(obj_a);

    return 0;
}
```

---

## 九、知识点补充
### 【知识点补充】09-00 概要
##### 学习目的
知道 C++异常时的处理，及其过程
知道流的概念，会使用对文件进行操作
知道 C++11新标准

![[../../annex/9.知识点补充_image_1.png]]

##### 课程内容
异常处理
文件流
11 标准

![[../../annex/9.知识点补充_image_2.png]]


##### 重难点
文件流
11 标准

![[../../annex/9.知识点补充_image_3.png]]

---

### 【知识点补充】09-01 异常处理机制
一、什么是异常
程序的异常就是在执行期间发生了问题

二、C++中的异常
但是呢没有把这个问题呢给它体现出来，所以说这样的做法呢，虽然可以解决问题，但是呢还是有一定的局限性是吧。那还是有一定的局限性。那么这个时候有同学说了啊。我在这里给他来一提示不就好了嘛对吧，那我说这里这个大有问题是吧，搞个感叹号吧好那么这样是不是就可以了呢。我们执行一下。
那你发现啊有感叹号是吧，那么这个时候呢你可能就会觉得这地方好像有问题。但是又出现一个事情。

那就是你这样得到的这个零实际上属于什么情况，实际上这个零它属于是一个啊参数传错了。结果就肯定会出错，结果出错了，那你后面的一些代码呢，他可能就失去了这个执行的意义了，没有必要再去执行呢，你东西都算错了，那么呢可能会引起一些连锁反应，所以后续的工作根本就不需要去做了。那这个时候怎么办呢？
这个时候呢我们就需要提出来一些 c++他的这个异常当中呢。我们用来专门处理异常的这么三个东西啊，实际上呢他们是一整套这一整套的东西呢，可以帮助你来进行一些异常的处理。

首先在可能出现问题的函数里面放一个监控，
然后在调用的地方（主函数）去检查
如果有问题就找个地方去处理。

3个关键词：
throw：专门用来抛出异常（做一个提示）
try：尝试可能会出错的代码
catch：接收前面抛出的异常，并且进行解决


```cpp
/*
3个关键词：
throw：专门用来抛出异常（做一个提示）
try：尝试可能会出错的代码
catch：接收前面抛出的异常，并且进行解决

//可以进行嵌套，但是需要注意，但凡通过throw抛出了一个异常，那么必然要有一个地方能够去把这个东西接收起来，如果说没有平级的东西(catch)去接收的话，那么在有嵌套的情况下，会继续往外层把问题(异常)进行抛出，在外层的catch去抛出它。当然，只要接收到了就会进行处理。<-(一定要有一个catch去接收它)
try()
{
    //......
    直接或间接有throw
    //......
}
catch(接收异常)//参数表
{
    处理
}
*/
```

![[../../annex/9.知识点补充_image_4.png]]

如果没有触发，直接往下进行，catch 不参与进去
![[../../annex/9.知识点补充_image_5.png]]

如果触发了
![[../../annex/9.知识点补充_image_6.png]]



![[../../annex/9.知识点补充_image_7.png]]

##### 代码--throw/try/catch
#代码 #throw/try/catch

```cpp
#include <iostream>
using namespace std;

double test(double a,double b)
{
/*     if(b==0)
    {
        cout << "!!!" << endl;
        return 0.0;
    } */
     if(b==0)
    {
        //异常情况==>打报告
        // throw 抛出的异常信息;
        //抛出的异常信息:支持多种类型
        throw "这里有问题！";//不管是什么，只要是双引号里面括起来的，都是字符串//只要这里触发了，后面都没有用了，根本就不会执行后面的代码。(只要此处触发了,此处已经中断程序了)

/*      throw 666;//虽然还没有写catch，但是只要发现了throw关键字，那么马上就会结束程序，抛出异常。
        throw 'S';
        throw 3.14; */
    }
    return a / b;
}

int main()
{
    try
    {
        cout << test(9, 0) << endl;//try里面就是需要尝试的代码
    }

    catch (const char* str)//throw抛出的信息是const char类型的东西，所以用const char类型的一个指针，比如叫str
    {
        cout << str << endl;
    }
    catch (int num) //假设是int类型的情况下(throw 666;的情况下)
    {
        cout << num << endl;//用int类型的参数去接收它。
    }
    catch(...)//不知道抛出的是什么类型，则可以用...代替，除上面两种类型就会在这个catch中处理。有点像switch中的default
    {
        cout << "不对劲" << endl;
    }
  
    return 0;
}

/*
3个关键词：
throw：专门用来抛出异常（做一个提示）
try：尝试可能会出错的代码
catch：接收前面抛出的异常，并且进行解决

//可以进行嵌套，但是需要注意，但凡通过throw抛出了一个异常，那么必然要有一个地方能够去把这个东西接收起来，如果说没有平级的东西(catch)去接收的话，那么在有嵌套的情况下，会继续往外层把问题(异常)进行抛出，在外层的catch去抛出它。当然，只要接收到了就会进行处理。<-(一定要有一个catch去接收它)

try()
{
    //......
    直接或间接有throw
    //......
}
catch(接收异常)//参数表
{
    处理
}

*/

```

三、自定义异常
箭头方向表示继承方向，箭头所指的就是父类 (绿色的)
![[../../annex/9.知识点补充_image_8.png]]

![[../../annex/9.知识点补充_image_9.png]]

exception 中实际上只有一个这样的公有的虚函数 what (其余为私有)。
what 函数的功能实际上很简单，就是可以返回一个这样的 const char 类型的字符串
也就是说可以在这个 what 函数里面写上自己对于这个异常的抛出的信息。
。
![[../../annex/9.知识点补充_image_8.png]]

![[../../annex/9.知识点补充_image_9.png]]


##### 代码--Myexception
#代码 #throw/try/catch #Myexception

```cpp
//会报错，不知道为什么
#include <iostream>
using namespace std;
#include <exception>//直接加上头文件就可以用了

//exception中实际上只有一个公有的虚函数

class Myexception : public exception
{
    public:
        const char* what() const //what函数中加了const，防止修改里面的内容。现在重写一下//来自父类的虚函数，可以重写
        {
            return "English";//有些情况下不能识别中文，会出现一些奇怪的字符。所以建议用英文
        }
};

int main()
{
/*     Myexception obj;
    cout << obj.what(); */

    try
    {
        throw Myexception();//不用烦恼自己究竟要throw什么样的东西了。因为可以直接throw这样类型的对象。这个对象没有名字(匿名对象)。直接throw直接抛出一个这样自定义的异常类类型的匿名对象
    }
    catch(Myexception& obj)//把上面这个对象的内容拷贝给下面这个对象要调拷贝构造。把类的对象作为参数的时候，要调拷贝构造怎么办？减少一次拷贝构造就节约点时间，考虑用引用。
    {
        cout << obj.what() << endl;
    }

    return 0;
}
```

---

### 09 -02 文件流
#### 一、流的概念
数据传递的一个情况--无结构化传递

#### 二、fstream 的使用
属于是 C++中最常用的一个文件操作类。这个东西本身应该是一个类名，用来操作文件。
io 标准类库里面的类，所以说要包含一些头文件，然后打开一些命名空间什么的才能去用它。
在具体的对文件进行操作的时候，我们使用的实际上是使用 fstream 这个类去实例化的对象。
fstream 中 f 就是 file。合起来翻译就是 file stream。翻译为文件流。简称为 fstream。

#### 三、常用的成员函数

![[../../annex/9.知识点补充_image_10.png]]

不断派生（iostream 派生出 fsteam，fstream 又派生出 ifstream 和 ofstream）
![[../../annex/9.知识点补充_image_11.png]]

ifstream 和 ofstream 写反了。
![[../../annex/9.知识点补充_image_12.png]]

![[../../annex/9.知识点补充_image_13.png]]

可以混合起来使用 ![[../../annex/9.知识点补充_image_14.png]]
##### 代码
#代码 #文件流 

```cpp
#include <iostream>//i--in,o--out,stream--流。输入输出流的标准头文件
using namespace std;
#include <fstream>//C++中的头文件是不需要加.h的
// using namespace std::fstream;//有这么一个东西，但是不这么写，只要有std就可以用了。
  
int main()
{
    fstream obj; //按F12转定义//只要是类，就必定可以定义对象
/*
    obj.open("test_1.txt", ios::out|ios::trunc); //打开文件，需要两个参数--文件路径和文件的打开方式//路径可以是相对路径,也可以是绝对路径。//可以混合使用。如此处是输出的同时截断一下--以输出文件，并且还希望截断它。防止已经有了同名的文件。
    //in需要从外面读进来，没有的情况下，不能无中生有。而out，把数据给出去，没有这个文件呢，可以自己创建一个文件，然后把你给出去的数据存下来。
  
    obj.put('S');//向文件当中写入一个字符
    char ch='A';//写完一个之后会接着往后写
    obj.put(ch);
  
    obj.close();//关闭文件，不需要参数
    obj.is_open();//判断一下是否成功打开了文件，不需要参数
    obj.eof();//eof--end of file是否到达了文件尾，不需要参数 */

    return 0;
}
```

[2023-08-11 23：15：16]--看到23：37
![[../../annex/9.知识点补充_image_15.png]]

这个文件实际上有一个叫文件指针的东西，这个文件指针用来定位你当前应该把数据是从哪里开始写， ![[../../annex/9.知识点补充_image_16.png]]
其实就相当于光标。下次进来再写的时候默认会从最前面开始重新写。
![[../../annex/9.知识点补充_image_17.png]]
准确的来说应该会先把 S 和 A 先删掉，然后再写下一次要写的东西。

写完要关掉（写 close ），然后下一次重新打开的时候，特别是要换一种打开形式/打开方式的时候一定要关（写 close）。因为这次打开是按照 out 形式打开的，所以说必须关掉之后，再按照别的方式打开它。

读取一个字符可以用 get 这么一个函数。同样也可以用 obj 去访问。

##### 代码
#代码 #文件流 

```cpp
#include <iostream> //i--in,o--out,stream--流。输入输出流的标准头文件
using namespace std;
#include <fstream> //C++中的头文件是不需要加.h的
// using namespace std::fstream;//有这么一个东西，但是不这么写，只要有std就可以用了。

int main()
{
    fstream obj; //按F12转定义//只要是类，就必定可以定义对象

    /*
        obj.open("test_1.txt", ios::out|ios::trunc); //打开文件，需要两个参数--文件路径和文件的打开方式//路径可以是相对路径,也可以是绝对路径。//可以混合使用。如此处是输出的同时截断一下--以输出文件，并且还希望截断它。防止已经有了同名的文件。
        //in需要从外面读进来，没有的情况下，不能无中生有。而out，把数据给出去，没有这个文件呢，可以自己创建一个文件，然后把你给出去的数据存下来。
  
        obj.put('S');//向文件当中写入一个字符
        char ch='A';//写完一个之后会接着往后写
        obj.put(ch);
        
        obj.close();//关闭文件，不需要参数
        obj.is_open();//判断一下是否成功打开了文件，不需要参数
        obj.eof();//eof--end of file是否到达了文件尾，不需要参数
        
        obj.open("test_1.txt",ios::in);
        obj.get(ch);

        ch=obj.get();//get函数是有重载的(有5个重载)。//也可以用这种方式去调用(有多种方式可以去调用)

        cout<<ch<<endl;
        obj.close();//不管怎么样，打开了要关闭。
        */

    return 0;
}
```

##### 代码--write/read
用二进制写，好处是快一点，但是可能看不懂
#代码 #文件流 

```cpp
#include <iostream> //i--in,o--out,stream--流。输入输出流的标准头文件
using namespace std;
#include <fstream> //C++中的头文件是不需要加.h的
// using namespace std::fstream;//有这么一个东西，但是不这么写，只要有std就可以用了。

int main()
{
    fstream obj; //按F12转定义//只要是类，就必定可以定义对象
  
    obj.open("test_2.txt", ios::out);
    int num = 99;
    obj.write((const char *)&num, sizeof(int)); // num这里类型不匹配，write是需要一个const char类型的指针，也就是需要寻到它的地址，然后把里面的东西直接拿到文件里面去,所以考虑取num的首地址。
    obj.close();   //关闭文件，不需要参数

    obj.open("test_2.txt", ios::in);
    int val = 0;
    obj.read((char*)&val, sizeof(int));
    obj.close(); //不管怎么样，打开了要关闭。
    cout << "val=" << val << endl;

    return 0;
}
```

#### 四、使用重载的<<  >>
##### 代码
#代码 #文件流 

```cpp
#include <iostream> //i--in,o--out,stream--流。输入输出流的标准头文件
using namespace std;
#include <fstream> //C++中的头文件是不需要加.h的
// using namespace std::fstream;//有这么一个东西，但是不这么写，只要有std就可以用了。

int main()
{
    fstream obj; //按F12转定义//只要是类，就必定可以定义对象

    obj.open("test_3.txt", ios::out);
    // obj << "勇敢牛牛 不怕困难" << endl;//光标在最后面，加上endl的话光标跑到最前面去了
    //如果此处有空格，会判定为0，空格会判定为中断，中断在out还是可以正常给出去，但是in中就会有问题。
    obj << "勇敢牛牛,不怕困难" << endl;
    //勇敢牛牛给str,不怕困难给到int类型的num,如果逗号是空格，那么勇敢牛牛还是正常给到str,但是不怕困难就给不到num
    obj << "123" << endl;
    obj.close();                //关闭文件，不需要参数

    char str[64];
    int num = 0;
    obj.open("test_3.txt", ios::in);
    obj >> str;
    obj >> num;
    obj.close(); //不管怎么样，打开了要关闭。
    cout << str << endl;
    cout << "num=" << num << endl;
    //想要少量的精准的去读取的话,读一个字符就行了。一个字符不够的话就多读几次然后存到一个字符数组里面。但是读一个字符由于中文是要占两个字符的空间，那么一个中文如果分两次去阅读就会出现问题，所以尽量不要用中文

    return 0;
}
```

### 09-03 C++11标准

###### 1 、初始化的方式
#代码 #11标准

```cpp
/*
int a = 0;

int b(2, 1);//这个看起来像是调构造函数

int m[4];//这个看起来像是初始化结构体

int n = {(int)3.14};
新的写法不允许有精度的缺失 */
  
#include <iostream>
using namespace std;

int main()
{
    int num = 0;

    int val(5);
    cout << "val=" << val << endl;

    return 0;
}
```

###### 2 、指针置空
#代码 #指针置空

```cpp
/*

int *p = NULL;

int *p = nullptr;//这个东西跟NULL是一样的，只不过写法不一样，都是给指针置空，没有区别
但是本质上有区别，上面是宏定义，nullptr可以认为是一个关键字，
*/

#include <iostream>
using namespace std;

int main()
{
    int *p = NULL;
    
    int *p = nullptr;

    return 0;
}
```

###### 3 、自动类型
#代码 #auto

```cpp
#include <iostream>
using namespace std;

int main()
{
    //3
    int num(0);
    int *p(&num);
    auto p(&num); //自动类型，不需要自己去搞这个//auto放在前面表示是类型，根据值匹配类型
    auto val(3.14);//auto自动推断给val一个double类型
    auto val(3.14f);//加上f就自动推断为float
    auto val(3);//自动推断为int

    //一般情况看不出有什么优势，举个例子比较容易懂:
    //auto使用也有缺点，主要适用于明确知道它的类型，并且懒得去写那么复杂的时候可以用auto
    // double***** p[3][4][5];
    // auto pp = **p;

    return 0;
}
```

###### 4 、decltype ()
简单来讲就是复制类型
#代码 #decltype

```cpp
#include <iostream>
using namespace std;

int main()
{

    //4、
    int a = 0;
    decltype(a) b;//这个地方相当于是根据a的类型定义了一个和他相同类型的b
    decltype((a)) m = a;//再加上一个圆括号意思就变了，这个的意思就相当于把a的类型先拿出来，然后给m定义一下，并且拿初始(a)给他。//这个方式就相当于取别名，给a取别名m。
    //如果没有这个圆括号，就相当于是根据a的类型定义一个m，然后把a的值给他，
    //但是如果是加了圆括号，(相当于取别名)

    return 0;
}
```

###### 5 、新的 for 循环的规则

![[../../annex/9.知识点补充_image_18.png]]

![[../../annex/9.知识点补充_image_19.png]]

![[../../annex/9.知识点补充_image_20.png]]

#代码 #for循环

```cpp
#include <iostream>
using namespace std;
#include <string>
  
int main()
{
    // 5、新的 for 循环的规则
    string str("abcdefg");

    for (int i = 0; i < str.size(); i++)
    {
        cout << str[i] << " ";
    }
    cout << endl;
    for(auto ch : str)//新的方式，两种方式都可以//意思是使用for循环遍历str,每次就用自动类型定义的这个ch每次循环去接收一下str里面的当前这个元素,然后再输出出来。//很显然，每一次它的每个元素在这里应该是一个char。里面是一个字符串嘛，每个字符串是char类型的。
    {
        cout << ch << " ";
    }
    //有局限性，不是所有的for循环都可以这么改，只能够改一些数组，或者string容器类型的东西。至于具体是什么容器需要等数据结构的时候才会学
    //指针什么的不能这么去搞。这个新的for循环有时候被称为序列for循环，也有人称为范围for,就先限定范围，然后再在里面进行遍历。

    return 0;
}
```

###### 6 、给类型取别名

![[../../annex/9.知识点补充_image_21.png]]

#代码 #取别名

```cpp
#include <iostream>
using namespace std;
#include <string>

int main()
{

    //6、给类型取别名
    typedef int INT;
    typedef void (*pFUN)();//typedef可以去给简单类型直接取别名，也可以给稍微复制一点的类型取别名  

    using Int = int;//现在我们就可以用Int代替int,可以直接用新名字代替后面的东西
    using PFUN = void (*)();//复杂一点一样的，直接使用PFUN取代替后面的一整坨
    //好处是不管简单类型还是复杂类型都统一了写法，就使用这个东西代替赋值等号后面的这个类型

    return 0;
}
```

###### 7 、default 在类中的用法
#代码 #default

```cpp
#include <iostream>
using namespace std;
#include <string>

int main()
{
    //7、default在类中的用法

    class CA//写了一个CA的类，其中有一个构造函数
    {
        public :
            CA();//这个构造函数声明了，但是突然发现好像没什么要些的。这时可以把这个声明直接删掉，直接吃低保。
    };
    // CA::CA() = default;
    //也可以在这里写default，意思就是说我要调这个低保。
    //直接删掉就是默默吃低保，写上default就是光明正大肆无忌惮的吃低保

    return 0;
}
```

###### 8 、final
#代码 #final关键字 

```cpp
#include <iostream>
using namespace std;
#include <string>

int main()
{
    //8、final
    
    class CA//加到类后面，类不能继承
    {
        public :
            virtual void fun() final{}//这个东西要加到函数上面，那么虚函数不能重写。
            //final加上纯虚函数的搞法尽量不要去有，如果有那就必定是说你想搞一个这样的特殊的类出来。而且编译条件如果严格一点的话纯虚函数+final可能还会出现问题。
    };
  
    return 0;
}
```








































































































































































