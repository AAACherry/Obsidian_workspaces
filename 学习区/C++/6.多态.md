## 六、多态
#### 06 -00 概要
##### 学习目的
* 了解多态的作用
* 熟悉纯虚函数的使用
* 能够在实际开发中使用多态
![[../../annex/C++_image_58.png]]

##### 课程内容
* 联编
* 多态
* 纯虚函数
* final
![[../../annex/0.C++总集_image_57.png]]

##### 重点难点
* 多态
* 纯虚函数
![[../../annex/0.C++总集_image_58.png]]

### 06-01 联编
#### 1 、什么是联编
其实就是计算机彼此关联的一个过程，就可以称之为是联编的过程，反映出映射的关系。
比如说在写代码时，在一个函数中调用了另一个函数，这两个函数就联合起来去实现某些功能，这个就可以理解为是一种联合关系。
举例：在函数重载时，我们可以通过实参的不同去决定调用哪一个具体的对于的函数，这个就是通过你函数的调用和你具体的函数体之间有一种对应的关系，可以称之为一种映射关系，通过你的实参就可以决定具体调用哪一个函数，这个也属于是一种联编。

#### 2、动/静态联编
动态联编（动态约束晚期联编）、静态联编（静态约束、早期联编）
1、都属于联编，只不过这两者有一些区别，动态联编的难度更大。
2、静态联编指的是你联编工作是出现在你写代码的这个阶段，也就是说出现的时间比较早。在写代码阶段局已经确定下来（在写代码时就确定调用哪个函数、在哪个地方执行哪一段代码），在代码编译就已经确定了 (函数的实现/函数的调用之间的关系)
3、动态联编出现的时间段是在你程序运行阶段。指的就是有一些时候在编译的阶段，我们不确定你接下来（要调用的函数/在某一个操作下需要执行的代码），不知道它是什么，必须等到程序运行时你才能去确定究竟要调用哪个函数。这就是所谓的动态联编
4、简单来说，联编是属于代码执行的问题。
5、动态联编和静态联编最大的一个区别就是所发生的时间段不一样

#### 3、实现动态联编的条件
静态联编我们经常在用，那么动态联编我们怎么才能去实现它呢？
动态联编是通过多态去体现出来的。

<center>（第 1、2 点属于先决条件，第 3 点是表现形式）</center>
1、先决条件
必须要把动态联编的行为定义为叫做类的虚函数（要有类、要有虚函数，在一个类中必须要有虚函数才行）（要有一个拥有虚函数成员的类）

2、先决条件
要有继承关系，并且拥有虚函数的类要是个父类。

3、表现形式
如何去使用这些东西？
举例：父类类型的指针能够指向派生类的子类的对象。
那么，在这里我们要体现多态，就需要先用基类指针或引用去指向或引用这个派生类对象，然后通过这个指针或引用去调用写成了虚函数的函数成员就可以了（体现多态）

#### Time
[2023-07-19 23：36：35] 学习 C++多态的概要和联编的基础知识

---
### 06-02 多态
#### 1 、多态的概念
它实际上就是说当你的类之间存在层次结构，并且类之间是通过继承去关联的时候，就可以用到这个多态。
也就是说，你现在有一些类，类之间有父子关系之类的时候，就可以用多态了。
在 C++中，多态其实就意味着你在调用类的成员函数的时候，会根据调用当前这个函数的对象，它的类型不同，可以去执行不同的函数。

![[../../annex/0.C++总集_image_59.png]]

![[../../annex/0.C++总集_image_60.png]]
结果：
![[../../annex/0.C++总集_image_61.png]]

不知为何，vscode 2022 会报错
![[../../annex/0.C++总集_image_62.png]]

虽然两个子类（Son_1, Son_2）都是公有继承自 Father 类，不过他们自己写了一个同名函数的情况下，直接调用是由于父类的同名成员会被自动隐藏，所以会调用自己的成员（前面讲过）

1、虚函数成员的父类

2、同名函数成员的子类

3、指针

##### 代码
#代码 #多态

```cpp
/* 要有这3个条件才能有多态
1、虚函数成员的父类
2、同名函数成员的子类
3、指针
*/
  
#include <iostream>
using namespace std;
  
class Father
{
public:
    void Fat_func();
};  

class Son_1 : public Father//公有继承父类
{//显然，除了构造析构都会继承下来
    void Fat_func();//在子类中写一个同名的函数
};

class Son_2 : public Father //公有继承父类
{                           //显然，除了构造析构都会继承下来
    void Fat_func();        //在子类中写一个同名的函数
};  

int main()
{
/*只是有一些普通的同名函数，属于不该出现的情况。
     Father obj_fat;
    obj_fat.Fat_func();

    Son_1 obj_son1;
    obj_son1.Fat_func(); 

    Son_2 obj_son2;
    obj_son2.Fat_func();
    */ 

    return 0;
} 

//放到主函数后面
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
}
  
void Son_1::Fat_func()
{
    cout << "void Son_1::Fat_func()" << endl;
}
  
void Son_2::Fat_func()
{
    cout << "void Son_2::Fat_func()" << endl;
}
```


##### Time
[2023-07-20 12：34：16]编写代码


#### 2、虚函数以及虚函数的特点
虚函数在动态里面应该出现在父类里面，被子类继承下去
声明虚函数：你在声明函数成员的时候，如果在函数前面加上 virtual 关键字。Virtual +函数名+参数表
虚函数的最大作用：开枝散叶。在派生出类后（在类族中）帮助你去实现多态。（只是其中一个条件）
实现多态的前提条件：
1、要有虚函数成员
2、要有子类
至于怎么样去体现多态，就是第 3 点，要用指针去指
![[../../annex/C++_image_65.png]]

虚函数的特点：
1、给类中的函数添加 virtual 关键字后，系统会给你当前这个类维护一个叫做虚函数表的东西

2、虚函数表的作用：所有虚函数都会储存在虚函数表里。

3、如果有虚函数，就不存在隐藏父类的同名函数了。相当于在子类中把父类的同名函数的函数体重新去实现了一遍。甚至可以认为，在加了 virtual 的情况下，这两个同名函数（父子类同名函数）就是同一个函数，只不过在这个子类中拥有一次把这个函数的函数体重新定义的机会。（这就是我们说的在子类中重写父类的虚函数，为什么叫重写：因为不是重新写了一个函数，而是把原来的函数重新定义了一遍，重写了函数体）

4、虚函数表是不会被继承下去的。在继承的过程里面，子类是不会继承父类的虚函数表的。Why？
系统给了就没必要去继承，当父类写了虚函数后，系统给父类自动维护了虚函数表，相当于系统给了一个低保，用虚函数表把类中所有的虚函数给存起来。子类把父类的虚函数重写一下的话，虚函数就不会被继承了，因为如果子类需要虚函数表，系统也会自动给他一个虚函数表
（子类也能吃到低保，父类不用去继承给子类）
虚函数表可以理解为数组类型的结构/链表类型的结构之类的

5、虚函数表究竟存的是什么？（有虚函数时）
虚函数表会把所有虚函数给记录下来，所以如何去记录这些函数？
用函数指针是最合适的。
所以虚函数表中记录的就是你当前类里面的这些虚函数的函数指针。
也就是说在虚函数表里面保存了你这些虚函数的首地址。
并且你的虚函数表又会有另外的一个低保可以帮你访问虚函数表。（有一个指针去指向虚函数表）系统默认给你这个指针专门指虚函数表的，这个也可以叫虚指针。
有一个 4 个字节的指针，这个指针有一个特殊的名字叫虚指针。系统给的。它的作用是指向这个虚函数表。Why？因为不知道你这个类中到底有多少个虚函数，也就是说这个虚函数表你也不知道有多大。要访问这个虚函数表就选择用一个 4 个字节的指针指向这个虚函数表。
虚指针里面存储的是虚函数表的首地址，而在虚函数表中的每一个这样的节点/元素，它里面存储的就是你当前的这个类里面每一个虚函数的首地址。（按从上到下、从前到后，顺序排列放置）
如果你有 10 个，那么这个虚函数表的长度就为 10。
虚函数表不会被继承，但是虚函数表里面的项（也就是虚函数）会被继承。
普通函数平时直接访问即可，但是在这里我们需要先通过虚指针：找到虚函数表，然后在虚函数表里面找到这一个当前虚函数的指针，然后通过虚函数指针去调用当前函数。但是实际上函数指针我们直接用指针名就可以去调用这个函数了。

#### 3、通过类的继承和虚函数实现多态

![[../../annex/C++_image_66.png]]

##### 代码-通过类的继承和虚函数实现多态
#代码 #多态 

```cpp
/* 要有这3个条件才能有多态
1、虚函数成员的父类
2、同名函数成员的子类
3、指针：父类类型的指针，指向不同对象（父类或者子类）对象  

类族
指针-->虚函数表
*/ 

#include <iostream>
using namespace std; 

class Father
{
public:
    virtual void Fat_func(); //声明虚函数：你在声明函数成员的时候，如果在函数前面加上 virtual 关键字
};
  
class Son_1 : public Father //公有继承父类
{                           //显然，除了构造析构都会继承下来
    void Fat_func();        //在子类中写一个同名的函数
};
  
class Son_2 : public Father //公有继承父类
{                           //显然，除了构造析构都会继承下来
    void Fat_func();        //在子类中写一个同名的函数
};

int main()
{
    /*只是有一些普通的同名函数，属于不该出现的情况。不写虚函数的情况下（普通情况下），就会根据对象当前的这个类型去调用当前类型的函数，是一个正常的操作。属于是静态联编的一种情况。
        Father obj_fat;
        obj_fat.Fat_func();

        Son_1 obj_son1;
        obj_son1.Fat_func();

        Son_2 obj_son2;
        obj_son2.Fat_func();
        */
  
    Father *p_fat;//创建父类类型的指针
    //创建三个不同类型的对象
    Father obj_fat;
    Son_1 obj_son1;
    Son_2 obj_son2;

    p_fat = &obj_fat;//父类类型的指针去取父类对象的首地址
    p_fat->Fat_func();//通过这个指针我们可以去调用这个函数

    p_fat = &obj_son1; //父类类型的指针还可以去接受一下子类对象的首地址
    p_fat->Fat_func(); //通过这个指针我们可以去调用这个函数
  
    p_fat = &obj_son2;  //父类类型的指针还可以去接受一下子类对象的首地址，父类指针小一点，读内容的时候不会影响到其他地方
    p_fat->Fat_func();  //通过这个指针我们可以去调用这个函数

    //如果去掉父类中的virtual，执行后全都是父类的：Father::Fat_func()
    //如果根据指针指向的内容，它的这个类型去调对应类型的这个函数。如果不加virtual，那就根据指针本身的类型，指针本身它是father类的类型，所以全都是father。动态根据参数，静态根据不同的子类。

    return 0;
}

//放到主函数后面
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
} 

void Son_1::Fat_func()
{
    cout << "void Son_1::Fat_func()" << endl;
}
  
void Son_2::Fat_func()
{
    cout << "void Son_2::Fat_func()" << endl;
}
```


#### 4、多态情况下去释放内存的注意事项
##### Delete 的释放内存的问题--只调用父类析构函数
你的父类（基类）当中有虚函数，并且是通过父类指针去分配的子类对象的时候，释放内存的时候只能通过父类的指针去释放。再使用 delete 父类类型的指针。调用的其实会是父类的虚构函数，它不会去调用这个子类的析构函数，所以说在这种情况下，就要把父类的析构函数也定义为虚析构。也就是说把父类的虚构函数也定义为虚函数。虚函数的析构函数也就是虚析构函数，简称虚析构，这样就能正常的去调用子类的析构函数了。

创建子类对象之前要先调用父类构造，所以说红框里面没有问题，
P_father 是父类类型的指针，它所指向的是你申请出来的匿名子类对象，所以输出出来 test_func ()(fat_func ())，因为确实是子类的对象

![[../../annex/0.C++总集_image_65.png]]

这是堆区申请的内存，没有写对应 new delete，那么这个内存就没有释放。所以我们没有出现调用析构函数的情况。

![[../../annex/0.C++总集_image_66.png]]


那就释放一下指针。并且我们可以把它制空。

![[../../annex/C++_image_69.png]]

问题出现在你释放的时候，只调用了父类的析构函数，说明在这里 delete 的时候还是按照这个指针本身的类型去调的这个析构函数。

![[../../annex/0.C++总集_image_68.png]]

这样做就会有一个缺点，我们知道子类是在父类的基础上增加了一些东西，如果子类在父类的基础上新增的这些内容里面写了一些代码需要在子类的析构函数里面完成，才能够正确的进行对子类对象内存的释放，这种写法下不会去调用你子类的析构函数，就会导致释放失败。

Delete 释放的时候是根据你这个指针的类型去释放、去调析构，释放多长的内存？

我们知道，假设父类是 100 个字节，子类有 300 个字节，多出来了 200 个字节，delete 按照父类的析构去操作的话，实际上申请了 300 个字节，但是根据 delete 去释放只能释放 100 个，那么还有 200 个就没有被释放，从此以后也不可能再释放了。这就产生了内存碎片、内存泄漏。多了以后就会造成问题，如蓝屏、死机，所以这种写法不对。

##### 解决方案

①那么我们如何才能解决这个问题呢？
可以用子类类型的指针去接收子类类型的对象（类型匹配），那为什么会有父类类型的指针去接收子类对象的写法呢？
因为在开发阶段，你要用到一些别人已经写好了的代码。
举个例子，不管游戏还是软件里面，你至少都会出现一个叫按钮的东西，这个按钮让你从无到有去做很麻烦，并且你需要不断的去使用这个只有一点点不同的按钮，此时我们可以直接提供一个按钮的类，直接从按钮的类里面去继承一个新类下来，然后再根据自己想要的去做一点点修改，那么就能得到自己的按钮了。
可是你用的是别人已经写好的代码，这些属于库文件之类的东西，那么你在使用其他相关联的一些支持的时候。
比如说在自己做了按钮之后，这个按钮点下去要实现某一个功能，这个功能你可能又需要去使用本来就有的代码，但是它本来就有的代码里面，可能有一个函数需要传参传一个按钮过来，它需要的参数就是本来系统就有的这个按钮类，而不是你自己新写的按钮子类，那么这个时候他参数的类型就应该是按钮父类，但是自己的按钮是按钮子类，参数传过去它不认识，怎么办？
你就用按钮父类类型的指针指向你自己的这个按钮子类的对象，然后再把按钮父类类型的指针传过去就可以用。
这种情况下迫于无奈只能这么操作, 不然参数传不过去，代码用不了。当然，后续还是可以把这个指针类型转换回来，然后自己在子类加的东西还是可以去用。

②有两种不同的解决方案 ：
1、直接解决提出问题的人，就把叫你写不同类型的就把它的类型改过来。
2、老实本分的去解决问题，从父类的析构函数上入手，受刚才的启发，这个指针指向什么样类型的函数，指向什么样类型的对象，就会去调用它的同名函数。那么析构函数能不能也这么操作呢？

![[../../annex/0.C++总集_image_69.png]]

我们实现这一套多态，我们所根据的就是把父类当前的类写成虚函数，那么子类当中就相当于重写了内容，就可以根据指针指向的对象的类型去调用对应的函数，那么现在我们是不是可以根据这个指针它所指向的对象的类型去调这个析构函数，当然析构函数永远是跟类名相同的。反正大家都是只有一个析构函数，名字不同就无所谓了。
也就是说在这里需要解决这个问题的话，我们就需要做一件事情：把父类的析构函数也定义为虚函数，那就是说在父类的析构函数前面加上 virtual。加上 virtual 后，就会发现该例子的情况下去调函数，前面照常，子类的析构也确实可以调出来了

![[../../annex/C++_image_72.png]]
👆（↑在析构函数前面加了 virtual 后↓）👇
![[../../annex/C++_image_73.png]]

但凡 delete，就意味着生命周期结束了，结束了就需要由系统自动去调析构函数。调析构的时候：
原来如果没有虚析构的情况下，那直接调这个指针类型的这么一个析构，就调父类析构去了。
现在有了虚析构，先看当前指针所指向的对象是什么类型的，然后去调这种类型的析构

![[../../annex/0.C++总集_image_72.png]]

然后在这个里面又继续调父类的析构。

![[../../annex/0.C++总集_image_73.png]]

虽然在这里出现了子类析构和父类析构，但是根据这个指针去调的，只有子类的析构。因为在子类析构当中会自动调用父类析构。Delete p_father 的时候，由于这个 p_father 这个父类里面是虚析构了，所以说就不会直接就看什么类型的指针就调什么类型的析构了，而是根据这个指针所指向的这个对象的类型，去调这个对象类型的析构函数。

![[../../annex/0.C++总集_image_74.png]]

也就是说现在这一行 father 类的析构，不是通过这个 p_father 去调的 father 的析构, 而是通过 p_father 去调 Son 的析构的时候，释放子类对象会调父类的析构。

![[../../annex/0.C++总集_image_75.png]]

写成所谓的虚析构-->保证能够调到子类的析构函数，只要调到子类的析构函数，那它就会自动的调父类析构，就搞定了。

##### 代码
#代码 #多态的注意事项

```cpp
/* 要有这3个条件才能有多态
1、虚函数成员的父类
2、同名函数成员的子类
3、指针：父类类型的指针，指向不同对象（父类或者子类）对象  

类族
指针-->虚函数表
*/

#include <iostream>
using namespace std; 

class Father
{
public:
    Father();
    ~Father();
    virtual void Fat_func(); //声明虚函数：你在声明函数成员的时候，如果在函数前面加上 virtual 关键字
};  

class Son : public Father //公有继承父类
{
public:
    Son();
    ~Son();          //显然，除了构造析构都会继承下来
    void Fat_func(); //在子类中写一个同名的函数
};

int main()
{
    Father *p_father = new Son; //后半段(new Son)从堆区申请了一个这样的内存，使用new会自动给你返回一个当前这种类型的指针，也就是说在这里给你返回一个Son类型的指针，而Son类型的指针就是你所申请的Son对象的内存的首地址。
    //我们知道父类类型的指针可以指向子类对象，所以我们确确实实的在语法上面可以通过父类指针去接收你new出来的Son的这一段内存。
    //父类指针指向子类对象，只不过这个对象属于是匿名对象(确确实实有个对象，有一段内存，但是它没有名字，只能搞个指针才能访问到)
    // new Son给出去的就是首地址，我们可以用父类指针去接收这个地址
    p_father->Fat_func(); //用起来正常使用。
    delete p_father;      //释放指针
    p_father = NULL;      //制空
    return 0;
} 

//放到主函数后面
Father::Father() //父类构造
{
    cout << "Father::Father()" << endl;
}
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
}
Father::~Father() //父类析构
{
    cout << "Father::~Father()" << endl;
}
  
Son::Son() //子类构造
{
    cout << "Son::Son()" << endl;
}
void Son::Fat_func()
{
    cout << "void Son::Fat_func()" << endl;
}
Son::~Son() //子类析构
{
    cout << "Son::~Son()" << endl;
}
```

















































多态情况下去释放内存的注意事项你的父类（基类）当中有虚函数，并且是通过父类指针去分配的子类对象的时候，释放内存的时候只能通过父类的指针去释放。再使用 delete 父类类型的指针。调用的其实会是父类的虚构函数，它不会去调用这个子类的析构函数，所以说在这种情况下，就要把父类的析构函数也定义为虚析构。也就是说把父类的虚构函数也定义为虚函数。虚函数的析构函数也就是虚析构函数，简称虚析构，这样就能正常的去调用子类的析构函数了。

创建子类对象之前要先调用父类构造，所以说红框里面没有问题， p_father 是父类类型的指针，它所指向的是你申请出来的匿名子类对象，所以输出出来 test_func ()(fat_func ())，因为确实是子类的对象

![[../../annex/0.C++总集_image_65.png]]

这是堆区申请的内存，没有写对应 new delete，那么这个内存就没有释放。所以我们没有出现调用析构函数的情况。

![[../../annex/0.C++总集_image_66.png]]

那就释放一下指针。并且我们可以把它制空。

![[../../annex/C++_image_69.png]]

问题出现在你释放的时候，只调用了父类的析构函数，说明在这里 delete 的时候还是按照这个指针本身的类型去调的这个析构函数。

![[../../annex/0.C++总集_image_68.png]]

这样做就会有一个缺点，我们知道子类是在父类的基础上增加了一些东西，如果子类在父类的基础上新增的这些内容里面写了一些代码需要在子类的析构函数里面完成，才能够正确的进行对子类对象内存的释放，这种写法下不会去调用你子类的析构函数，就会导致释放失败。

Delete 释放的时候是根据你这个指针的类型去释放、去调析构，释放多长的内存？

我们知道，假设父类是 100 个字节，子类有 300 个字节，多出来了 200 个字节，delete 按照父类的析构去操作的话，实际上申请了 300 个字节，但是根据 delete 去释放只能释放 100 个，那么还有 200 个就没有被释放，从此以后也不可能再释放了。这就产生了内存碎片、内存泄漏。多了以后就会造成问题，如蓝屏、死机，所以这种写法不对。

那么我们如何才能解决这个问题呢？ 可以用子类类型的指针去接收子类类型的对象（类型匹配），那为什么会有父类类型的指针去接收子类对象的写法呢？ 因为在开发阶段，你要用到一些别人已经写好了的代码。举个例子，不管游戏还是软件里面，你至少都会出现一个叫按钮的东西，这个按钮让你从无到有去做很麻烦，并且你需要不断的去使用这个只有一点点不同的按钮，此时我们可以直接提供一个按钮的类，直接从按钮的类里面去继承一个新类下来，然后再根据自己想要的去做一点点修改，那么就能得到自己的按钮了。可是你用的是别人已经写好的代码，这些属于库文件之类的东西，那么你在使用其他相关联的一些支持的时候。比如说在自己做了按钮之后，这个按钮点下去要实现某一个功能，这个功能你可能又需要去使用本来就有的代码，但是它本来就有的代码里面，可能有一个函数需要传参传一个按钮过来，它需要的参数就是本来系统就有的这个按钮类，而不是你自己新写的按钮子类，那么这个时候他参数的类型就应该是按钮父类，但是自己的按钮是按钮子类，参数传过去它不认识，怎么办？ 你就用按钮父类类型的指针指向你自己的这个按钮子类的对象，然后再把按钮父类类型的指针传过去就可以用。这种情况下迫于无奈只能这么操作, 不然参数传不过去，代码用不了。当然，后续还是可以把这个指针类型转换回来，然后自己在子类加的东西还是可以去用。

有两种不同的解决方案： 1、直接解决提出问题的人，就把叫你写不同类型的就把它的类型改过来。 2、老实本分的去解决问题，从父类的析构函数上入手，受刚才的启发，这个指针指向什么样类型的函数，指向什么样类型的对象，就会去调用它的同名函数。那么析构函数能不能也这么操作呢？

![[../../annex/0.C++总集_image_69.png]]

我们实现这一套多态，我们所根据的就是把父类当前的类写成虚函数，那么子类当中就相当于重写了内容，就可以根据指针指向的对象的类型去调用对应的函数，那么现在我们是不是可以根据这个指针它所指向的对象的类型去调这个析构函数，当然析构函数永远是跟类名相同的。反正大家都是只有一个析构函数，名字不同就无所谓了。也就是说在这里需要解决这个问题的话，我们就需要做一件事情：把父类的析构函数也定义为虚函数，那就是说在父类的析构函数前面加上 virtual。加上 virtual 后，就会发现该例子的情况下去调函数，前面照常，子类的析构也确实可以调出来了

![[../../annex/C++_image_72.png]] 👆（↑在析构函数前面加了 virtual 后↓）👇 ![[../../annex/C++_image_73.png]]

但凡 delete，就意味着生命周期结束了。多态情况下去释放内存的注意事项你的父类（基类）当中有虚函数，并且是通过父类指针去分配的子类对象的时候，释放内存的时候只能通过父类的指针去释放。再使用 delete 父类类型的指针。调用的其实会是父类的虚构函数，它不会去调用这个子类的析构函数，所以说在这种情况下，就要把父类的析构函数也定义为虚析构。也就是说把父类的虚构函数也定义为虚函数。虚函数的析构函数也就是虚析构函数，简称虚析构，这样就能正常的去调用子类的析构函数了。

创建子类对象之前要先调用父类构造，所以说红框里面没有问题， p_father 是父类类型的指针，它所指向的是你申请出来的匿名子类对象，所以输出出来 test_func ()(fat_func ())，因为确实是子类的对象

![[../../annex/0.C++总集_image_65.png]]

这是堆区申请的内存，没有写对应 new delete，那么这个内存就没有释放。所以我们没有出现调用析构函数的情况。

![[../../annex/0.C++总集_image_66.png]]

那就释放一下指针。并且我们可以把它制空。

![[../../annex/C++_image_69.png]]

问题出现在你释放的时候，只调用了父类的析构函数，说明在这里 delete 的时候还是按照这个指针本身的类型去调的这个析构函数。

![[../../annex/0.C++总集_image_68.png]]

这样做就会有一个缺点，我们知道子类是在父类的基础上增加了一些东西，如果子类在父类的基础上新增的这些内容里面写了一些代码需要在子类的析构函数里面完成，才能够正确的进行对子类对象内存的释放，这种写法下不会去调用你子类的析构函数，就会导致释放失败。

Delete 释放的时候是根据你这个指针的类型去释放、去调析构，释放多长的内存？

我们知道，假设父类是 100 个字节，子类有 300 个字节，多出来了 200 个字节，delete 按照父类的析构去操作的话，实际上申请了 300 个字节，但是根据 delete 去释放只能释放 100 个，那么还有 200 个就没有被释放，从此以后也不可能再释放了。这就产生了内存碎片、内存泄漏。多了以后就会造成问题，如蓝屏、死机，所以这种写法不对。

那么我们如何才能解决这个问题呢？ 可以用子类类型的指针去接收子类类型的对象（类型匹配），那为什么会有父类类型的指针去接收子类对象的写法呢？ 因为在开发阶段，你要用到一些别人已经写好了的代码。举个例子，不管游戏还是软件里面，你至少都会出现一个叫按钮的东西，这个按钮让你从无到有去做很麻烦，并且你需要不断的去使用这个只有一点点不同的按钮，此时我们可以直接提供一个按钮的类，直接从按钮的类里面去继承一个新类下来，然后再根据自己想要的去做一点点修改，那么就能得到自己的按钮了。可是你用的是别人已经写好的代码，这些属于库文件之类的东西，那么你在使用其他相关联的一些支持的时候。比如说在自己做了按钮之后，这个按钮点下去要实现某一个功能，这个功能你可能又需要去使用本来就有的代码，但是它本来就有的代码里面，可能有一个函数需要传参传一个按钮过来，它需要的参数就是本来系统就有的这个按钮类，而不是你自己新写的按钮子类，那么这个时候他参数的类型就应该是按钮父类，但是自己的按钮是按钮子类，参数传过去它不认识，怎么办？ 你就用按钮父类类型的指针指向你自己的这个按钮子类的对象，然后再把按钮父类类型的指针传过去就可以用。这种情况下迫于无奈只能这么操作, 不然参数传不过去，代码用不了。当然，后续还是可以把这个指针类型转换回来，然后自己在子类加的东西还是可以去用。

有两种不同的解决方案： 1、直接解决提出问题的人，就把叫你写不同类型的就把它的类型改过来。 2、老实本分的去解决问题，从父类的析构函数上入手，受刚才的启发，这个指针指向什么样类型的函数，指向什么样类型的对象，就会去调用它的同名函数。那么析构函数能不能也这么操作呢？

![[../../annex/0.C++总集_image_69.png]]

我们实现这一套多态，我们所根据的就是把父类当前的类写成虚函数，那么子类当中就相当于重写了内容，就可以根据指针指向的对象的类型去调用对应的函数，那么现在我们是不是可以根据这个指针它所指向的对象的类型去调这个析构函数，当然析构函数永远是跟类名相同的。反正大家都是只有一个析构函数，名字不同就无所谓了。也就是说在这里需要解决这个问题的话，我们就需要做一件事情：把父类的析构函数也定义为虚函数，那就是说在父类的析构函数前面加上 virtual。加上 virtual 后，就会发现该例子的情况下去调函数，前面照常，子类的析构也确实可以调出来了

![[../../annex/C++_image_72.png]] 👆（↑在析构函数前面加了 virtual 后↓）👇 ![[../../annex/C++_image_73.png]]

但凡 delete，就意味着生命周期结束了。
##### Time
[2023-07-22 16：42：51]

---

### 06-03 纯虚构函数
#### 1. 纯虚函数的概念
纯虚函数就是纯粹的虚函数--没有函数体的虚函数
纯虚函数是一种特殊的虚函数，使用虚函数的东西在这里都适用，而且比虚函数的要求还要高一点。

#### 2. 纯虚函数的定义
虚函数可以没有函数体（根本（连）大括号都没有）。
纯虚函数在声明的时候= 0 ，这样就是声明了一个虚函数。其他地方不要再写这个东西了。
Virtual 关键字+返回值类型+函数名+参数表+= 0
不要理解为赋值为 0，这就是一个语法格式
![[../../annex/0.C++总集_image_76.png]]

纯虚函数的函数体不在当前这个类实现，它的函数体就要留给当前这个类的子类去完成
（在子类里面去实现父类的纯虚函数的函数体）。
子类里面跟虚函数同名的函数体属于是多了一次重新定义函数体的机会。反正写了虚函数迟早要被你重写，那不如不写，直接=0. 该实现的时候让你自己去实现，我就只负责声明一下有这么一个函数，至于有意义的函数体，有意义的实现我根本就不写，让子类自己去实现就行了。

析构函数也可以写成纯虚函数
![[../../annex/0.C++总集_image_77.png]]

析构函数写成了纯虚函数，你还是要在类外去实现一下它
![[../../annex/0.C++总集_image_78.png]]

#### 3. 抽象类
抽象类就是普通函数在有了一个/一个以上的纯虚函数的时候就变成了抽象类。

抽象类的特点：
1、不能用来实例化对象，原来我们可以用 Father 去定义对象，现在不行了。抽象类是不能定义对象的。因为抽象类这个东西有个函数没有去实现，可以认为这个类不完整，不完整就不能去定义对象了
2、但是抽象类可以去定义指针，可以为子类服务。
![[../../annex/0.C++总集_image_79.png]]

Father 还是可以当成一个类型，类型还是存在的，有了类型还是可以去定义这种类型的指针的。
这个指针没有当前类类型的指针的对象被它去指，因为这个类不允许有对象，所以就只能去为子类服务。当然子类的子类也可以，只不过自己的类就属于没有对象。

![[../../annex/0.C++总集_image_80.png]]

如果存在这样的类，它拥有多个这样的纯虚函数，在子类中实现了两个纯虚函数，那只要你写了函数体，这个函数它就不再是纯虚函数了，（还有一个纯虚函数没有去实现它），那么这个时候子类里面其实也就是相当于还有一个纯虚函数，那他既然还有一个纯虚函数，那么这个子类也属于是抽象类。
也就是说纯虚函数/抽象类对于这一特质，它是可以遗传的。
相当于父类有多个纯虚函数，或者说只要你在子类当中没有把父类所有的纯虚函数都实例化，那么子类也是抽象类，也不能去实例化对象。简单来说，一个类当中只要有纯虚函数，无论从何而来（自己写的也好，继承而来的也罢），这个类就是一个抽象类，就不能去实例化对象。

菱形继承的时候，加了 virtual 关键字去继承，其父类称之为虚基类，也就是你在使用这个继承的时候，加上了 virtual 关键字，那么这个基类就可以称之为虚基类。它的存在就是解决菱形继承的弊端，防止你从同一个父类继承多份相同的书籍，这种东西主要是用在多继承上面，特别是在一个类族里面。如果不使用虚基类，就非常容易把最上层的父类的内存继承多份。

再写一个 class Grand_Son，试用：
![[../../annex/0.C++总集_image_81.png]]

搞一个父类类型的指针，当这个父类类型的指针指向这个子类的时候，把这个东西拿出来。把 test 拿出来
![[../../annex/0.C++总集_image_82.png]]

如果想要比较稳妥，想要它继续被子类重写，就继续声明为虚函数就行了。不写的话其实也会属于是重写的情况。

![[../../annex/C++_image_85.png]]

所以如果希望成员函数在子类里面继续是虚函数，希望它继续能够重写的话呢，那就加个 virtual 就好了（严格、保险起见），不加其实也是能够重写的。

![[../../annex/0.C++总集_image_84.png]]

![[../../annex/0.C++总集_image_85.png]]

##### 代码--纯虚函数的定义格式
#代码 #纯虚函数

```cpp
#include <iostream>
using namespace std;

class Father
{
public:
    Father();
    virtual ~Father() = 0;
    virtual void Fat_func() = 0;
};  

class Son : public Father //公有继承父类
{
public:
    Son();
    ~Son();          //显然，除了构造析构都会继承下来
    void Fat_func(); //在子类中写一个同名的函数
};
  
int main()
{
    // Father obj;//纯虚函数不能声明对象
    return 0;
}
  
//放到主函数后面
Father::Father() //父类构造
{
    cout << "Father::Father()" << endl;
}
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
}
Father::~Father() //父类析构
{
    cout << "Father::~Father()" << endl;
} 

Son::Son() //子类构造
{
    cout << "Son::Son()" << endl;
}
void Son::Fat_func()
{
    cout << "void Son::Fat_func()" << endl;
}
Son::~Son() //子类析构
{
    cout << "Son::~Son()" << endl;
}
```

##### 代码 2--纯虚函数--父子类和孙子类中纯虚函数能否传递

```cpp
//父类当中有虚函数，子类当中重写了，

#include <iostream>
using namespace std;

class Father
{
public:
    Father();
    ~Father();
    virtual void Fat_func() = 0; //声明虚函数：你在声明函数成员的时候，如果在函数前面加上 virtual 关键字
};

class Son : public Father //公有继承父类
{
public:
    Son();
    ~Son();          //显然，除了构造析构都会继承下来
    void Fat_func(); //在子类中写一个同名的函数
    /*
    virtual void Fat_func();
    如果想要比较稳妥，想要它继续被子类重写，就继续声明为虚函数就行了。不写的话其实也会属于是重写的情况。所以如果希望成员函数在子类里面继续是虚函数，希望它继续能够重写的话呢，那就加个 virtual 就好了（严格、保险起见），不加其实也是能够重写的。
    */
};
  
class Grand_Son : public Son
{
public:
    Grand_Son();
    ~Grand_Son();    //显然，除了构造析构都会继承下来
    void Fat_func(); //在子类中写一个同名的函数
    /*
    virtual void Fat_func();
    如果想要比较稳妥，想要它继续被子类重写，就继续声明为虚函数就行了。不写的话其实也会属于是重写的情况。所以如果希望成员函数在子类里面继续是虚函数，希望它继续能够重写的话呢，那就加个 virtual 就好了（严格、保险起见），不加其实也是能够重写的。
    */
};
  
int main()
{
    /*
         //验证父类的子类
        Father *p_fat;
  
        Son obj_Son1;
  
        p_fat=&obj_Son1;
        p_fat->Fat_func();
     */

    //验证子类和孙子类
    //相当于父类指针指向子类对象，然后通过这个指针去调的时候，它的函数是由什么决定的？
    //动态联编根据指向的对象的类型去调函数，静态联编会根据指针的类型去调函数
    Son *p_Son;
    
    Grand_Son obj_G_Son;
  
    p_Son = &obj_G_Son;
    p_Son->Fat_func();

    return 0;
}

//放到主函数后面
// Father
Father::Father() //父类构造
{
    cout << "Father::Father()" << endl;
}
/* void Father::Fat_func()//纯虚函数，不能实现函数体和声明对象。要在子类中完成
{
    cout << "void Father::Fat_func()" << endl;
} */
Father::~Father() //父类析构
{
    cout << "Father::~Father()" << endl;
}
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
}
// Son
Son::Son() //子类构造
{
    cout << "Son::Son()" << endl;
}
void Son::Fat_func()
{
    cout << "void Son::Fat_func()" << endl;
}
Son::~Son() //子类析构
{
    cout << "Son::~Son()" << endl;
}
// Grand_son
Grand_Son::Grand_Son() //孙子类构造
{
    cout << "Grand_Son::Grand_Son()" << endl;
}
void Grand_Son::Fat_func()
{
    cout << "void Grand_Son::Fat_func()" << endl;
}
Grand_Son::~Grand_Son() //孙子类析构
{
    cout << "Grand_Son::~Grand_Son()" << endl;
}
```

##### Time
[2023-07-22 18：01：56]

---

### 06-04 final
#### 1 、权限掠夺者
Final 可以掠夺你的权限，终结你的操作。Final 的作用就是让某些可以不断延续下去的东西结束掉。
可以用在两个方面：1. 函数方面 2. 用再类上面

#### 2 、掠夺函数权限：阻止重写
如果虚函数加上了 final，从此虚函数在子类里面就不能再被重写了。
加上 final，当前类为最后一次可重写类，其子类无法再重写
语法格式：在函数后面加上 final（写在参数表后面）

##### 代码-掠夺函数的权限
#代码 #final关键字 #掠夺函数权限

```cpp
// 12 - 4 - 1final关键字 --掠夺函数权限
//父类当中有虚函数，子类当中重写了，
  
#include <iostream>
    using namespace std;

class Father
{
public:
    Father();
    ~Father();
    virtual void Fat_func();
};

class Son : public Father //公有继承父类
{
public:
    Son();
    ~Son();          
    void Fat_func() final; //加上final，当前类为最后一次可重写类，其子类无法再重写
};
  
class Grand_Son : public Son
{
public:
    Grand_Son();
    ~Grand_Son();  
    // void Fat_func();
};
  
int main()
{
    /*
     Son *p_Son;
     
    Grand_Son obj_G_Son;
    
    p_Son = &obj_G_Son;
    p_Son->Fat_func();
  
    return 0;
    没有必要去探究指针指向什么东西了，因为不能再这么写了，没有这个函数了
    */
}
  
//放到主函数后面
// Father
Father::Father() //父类构造
{
    cout << "Father::Father()" << endl;
}
Void Father:: Fat_func ()
{
    cout << "void Father::Fat_func()" << endl;
}
Father::~Father() //父类析构
{
    cout << "Father::~Father()" << endl;
}
void Father::Fat_func()
{
    cout << "void Father::Fat_func()" << endl;
}

// Son
Son::Son() //子类构造
{
    cout << "Son::Son()" << endl;
}
void Son::Fat_func()
{
    cout << "void Son::Fat_func()" << endl;
}
Son::~Son() //子类析构
{
    cout << "Son::~Son()" << endl;
}

// Grand_son
Grand_Son::Grand_Son() //孙子类构造
{
    cout << "Grand_Son::Grand_Son()" << endl;
}
/* void Grand_Son::Fat_func()
{
    cout << "void Grand_Son::Fat_func()" << endl;//子类中的虚函数用了final关键字，孙子类无法再重写虚函数
}
*/
Grand_Son::~Grand_Son() //孙子类析构
{
    cout << "Grand_Son::~Grand_Son()" << endl;
}
```

#### 3 、掠夺类的权限：阻止派生
只要在一个类上面写了 final，从此这个类就不能被派生了

##### 代码--掠夺类的权限
#代码 #final关键字 #掠夺类的权限

```cpp
// 12 - 4 - 2final关键字 --掠夺类的权限

#include <iostream>
using namespace std;

class ClassName final
{
    public:
        ClassName();
        ~ClassName();
  
    private:

};

class Son // : public ClassName//不管用什么权限方式，总之可以继承ClassName。但是父类中用final关键字，则无法子类无法再继承
{
    public:
        Son();
        ~Son();

    private:

}; 

int main()
{
    return 0;
}

//相关函数放在主函数后面
ClassName::ClassName()
{
}
ClassName::~ClassName()
{
}

Son::Son()
{
}
Son::~Son()
{
}
```

#### 纯虚函数 virtual+final
纯虚函数加上 final 会出现什么样的问题？

纯虚函数 virtual 必须要重写，否则这个类就是抽象类就不能创建对象。
而 final 阻止被重写在子类中，这个函数不再是虚函数，不能再被重写了。

使用结果：既不能在子类当中重写函数，又不能在主函数中创建子类对象。

解决方法：不要这么做，从根源上解决这个问题。不要纯虚函数 virtual+final。否则的话，但凡这么写了，就是希望它所有的子类都是抽象类。

##### 代码--virtual+final
#代码 #final关键字 #virtual和final   

```cpp
// 12 - 4 - 3 virtual+final

#include <iostream>
using namespace std;

class ClassName
{
public:
    ClassName();
    ~ClassName();
    virtual void test() final = 0;

private:
};  

class Son : public ClassName//子类继承父类
{
public:
    Son();
    ~Son();
    // void test();//无法重写函数 

private:
}; 

class G_Son : public Son//孙子类继承子类
{
public:
    G_Son();
    ~G_Son();
    // void test();//无法重写函数
  
private:
}; 

int main()
{
    // G_Son obj_2;//孙子类也不能创建对象
    // Son obj_1;//创建不了对象
    return 0;
}
  
//相关函数放在主函数后面
ClassName::ClassName()
{
}
ClassName::~ClassName()
{
}
  
Son::Son()
{
}
Son::~Son()
{
}
  
G_Son::G_Son()
{
}
G_Son::~G_Son()
{
}
```

#### Time
[2023-07-23 11：52：47]

---



