## 七、运算符重载
### 07-00 概要
#### 学习目的
- 掌握运算符重载规则
- 能够自助实现运算符重载
- 通过重载运算符，扩展运算符的功能
![[../../附件/0.C++总集_image_86.png]]

#### 课程内容
- 基础语法
- 规则详解
- 重载>>和<<
- 注意事项

![[../../附件/0.C++总集_image_87.png]]

#### 重难点
- 基础规则
- 注意事项

![[../../附件/0.C++总集_image_88.png]]

---

### 07-01 基础语法
##### 1 、重载的概念
所谓的重载其实就是重新赋予它一个含义/给他一个新的内容
重载运算符其实就是给运算符一个新的含义。

##### 2 、在类中去重载运算符
最主要的目的就是重新定义运算符的运算规则。
运算符重载只不过就是去写一个新的函数而已，只不过这个新的函数所实现的功能就是重新赋予你运算符一个运算规则。
运算符重载本质上是用函数的重载。

[2023-07-23 12：33：02]

重载的运算符原来是单目/双目运算符，参数表中就只能有一个/两个参数。
如：+号属于双目运算符，那么参数列表中就只能有两个参数，而且必须是两个参数。
此处只看见了一个参数，是因为它作为成员函数的时候，这个 this 不见了（隐藏了），它要占一个位置
![[../../附件/0.C++总集_image_89.png]]

输出结果
![[../../附件/0.C++总集_image_90.png]]


![[../../附件/0.C++总集_image_91.png]]

##### 代码 
#代码 #运算符重载

```cpp
#include <iostream>
using namespace std;

//复数：实部，虚部 i i的平方平方应该是-1
//(3+2i) (0+6i) (5+0i)
//要实现复数的加法，肯定要写一个成员函数，才能够在类中把它进行重载
class Mycomplex
{
public:
    Mycomplex(double real = 0.0, double imag = 0.0);
    ~Mycomplex();
    void display() const; //显示当前所构建的虚数的对象里面的数据，只给显示，不给修改
    //返回值类型 函数名 (形参列表) {函数体}
    //唯一重要的区别就是它的函数名有要求，要重载哪个运算符，你的这个函数名就应该叫operator+运算符名称。operator本身是关键字，专门用来定义这个重载运算符的函数
    //函数名：operator运算符名称  

    Mycomplex operator+(Mycomplex other) //实际上+成员函数在参数表中有Mycomplex *this指针，只是我们看不见它，也就是说这里已经有一个参数了。我们需要的其实是另外一个Mycomplex other
    {
        Mycomplex obj;//创建一个对象
        obj.m_real=this->m_real + other.m_real;
        obj.m_imag=this->m_imag + other.m_imag;
        return obj;
    }
    
    // Mycomplex& operator+(const Mycomplex& other) const;//先声明后定义。这个地方要返回对象的话要调一次拷贝构造，所以可以返回一个引用& ，该函数只去做复数的加法，所以考虑只读取，不能修改，加上const。然后参数表也可以加上引用&，防止调拷贝构造。并且可以加上const防止参数被修改

private:
    double m_real; //实部
    double m_imag; //虚部
};
  
int main()
{
    /*
         //其实在平时已经用到过了运算符的重载，系统给的低保，像这样的重载我们也还是可以自己去实现的，赋予它低保以外的含义，实现更多的功能。
        6 + 1;//int+int
        3.14 + 5.12;//double+double
        6 + 3.14;//int+double
  
        int num = 0;
        char ch='A';
        cout << num << endl;//原来是左移的运算符，现在可以输出int类型的整数。
        cout << ch << endl;
     */
  
    Mycomplex obj_1(3, 2);
    obj_1.display(); 

    Mycomplex obj_2(4, 3);
    obj_2.display();

    //现在的问题是能否把两个复数加起来
    // obj_1 + obj_2;//+号没有把两个复数加起来的功能。需要重新去定义这种规则
/*
    int a, b, c;
    a = b = c = 0;
    a = b + c;//把后面看作是函数的调用的话，a=b.+(c)。.是取，+是函数名，()括号内的c是参数
*/

    Mycomplex obj_3;
    obj_3 = obj_1 + obj_2;//在此处直接写+号，究竟是哪一个对象在调用加的函数，哪一个对象是参数？加号无所谓，但是减号的话有减数和被减数之分。所以究竟是哪一种加的写法，我们在实现注意顺序的时候就不会有问题
    obj_3.display();
  
    //写成函数调用的形式
    //究竟对应的是哪一种的函数调用的形式
    //说到运算符就要说到结合性(往哪边靠)，根据结合性，加号是左结合性(双目运算符)，所以看左边,左边的东西去调的。所以说左结合性，左边就是当前对象，右边是参数。一般都是左结合性。
    obj_1.operator+(obj_2); // 属于是obj_1+obj_2的情况;//谁在前面会有区别
    obj_2.operator+(obj_1); // 属于是obj_2+obj_1的情况;
    return 0;
}

Mycomplex::Mycomplex(double real, double imag) //只需要在声明的时候给默认值，实现的时候不需要
: m_real(real), m_imag(imag)               //成员初始化列表
{
}

//用这种方法（先声明后定义）更加的安全，并且少了拷贝构造
/*
Mycomplex &Mycomplex::operator+(const Mycomplex& other) const //同样也是作为一个函数存在，用类名Mycomplex::去限定函数名
{
    return Mycomplex(this->m_real + other.m_real, this->m_imag + other.m_imag); //直接放回一个匿名对象(没有参数、没有名字的对象)//实部+实部作为实部的参数,虚部+虚部作为虚部的参数
} */

void Mycomplex::display() const
{
    cout << "(" << m_real << "+" << m_imag << "i)" << endl;
}
Mycomplex::~Mycomplex()
{
}
```


##### 3、在全局重载运算符

围绕语法，要重载运算符的话就写一个函数，函数名写成 operator+要重载的运算符名称。返回值类型随便去给，参数表有要求，几目运算符就有几个参数，如果写在类的里面的话有 this 指针，要占据普通成员函数的一个参数位置
![[../../附件/0.C++总集_image_92.png]]

##### 代码 
#代码 #全局重载运算符

```cpp
#include <iostream>
using namespace std;

//复数：实部，虚部 i i的平方平方应该是-1
//(3+2i) (0+6i) (5+0i)
//要实现复数的加法，肯定要写一个成员函数，才能够在类中把它进行重载
class Mycomplex
{
public:
    Mycomplex(double real = 0.0, double imag = 0.0);
    ~Mycomplex();
    void display() const; //显示当前所构建的虚数的对象里面的数据，只给显示，不给修改

    Mycomplex& operator+(const Mycomplex& other) const;//属于是写成成员函数

    friend Mycomplex &operator+(const Mycomplex &obj1, int num); //声明为友元函数，这个函数就能访问私有成员了

private:
    double m_real; //实部
    double m_imag; //虚部
};

Mycomplex &operator+(const Mycomplex &obj1,int num) //写成全局函数。现在没有this指针了，所以需要传两个这样的参数//我们可以不写两个复数相加的东西。可以考虑复数+整数的做法
{
    return Mycomplex(obj1.m_real + num, obj1.m_imag);//私有成员，在类的外部无法直接访问//实部直接+num，虚部不加，用原来的虚部
}
//现在我们可以做：(3+2i)+6=(9+2i)

int main()
{
    Mycomplex obj_1(3, 2);
    obj_1.display();

    Mycomplex obj_2(4, 3);
    obj_2.display();

    Mycomplex obj_3;//先定义出来，再进行赋值，而不是直接进行初始化。那么初始化的时候会调一个拷贝构造函数
    obj_3 = obj_1 + obj_2; //赋值函数。此处会有一个低保，赋值这个函数在类里面有一个低保，也就是赋值运算符会有一个重载，类当中是会有一个低保的。除了定义以外调赋值运算符实际上类中是有一个赋值运算符的重载的，有了这个重载才能直接用，否则的话凭什么能够把这两个对象加起来，然后赋值给obj_3.
    obj_3.display();  
    
    //对象之间可以赋值，凭什么？因为类里面实际上有一个默认提供给你的赋值运算符的重载，这个函数叫做赋值函数，属于任何一个类都会有的这么一个东西，其实每个类天生就会有至少四个默认的成员函数：构造函数、析构函数、拷贝构造、赋值函数。拷贝构造和赋值函数最大的区别就是发生的时间点不同，虽然都是通过赋值体现出来的。但是赋值发生在很多时候，而拷贝构造如果就通过赋值来体现的话，就应该发生在初始化的阶段。用一个对象直接构造另一个对象，或者说只要沾上赋值属于这么一个情况:
    Mycomplex obj_3 = obj_2;//所有用赋值运算符的可以认为肯定是调用了类里面的赋值函数，只有这种情况(用一个对象去初始化另一个对象)的时候，会调拷贝构造

    obj_3 = obj_1 + 6;
    obj_3.display();

    obj_3 = operator+(obj_1, 6); //翻译一下，obj_1和6都作为参数，传给operator+()函数。然后用obj_3去接收一下
    obj_3.display();
    //全局的也可以是直接调函数的写法，也可以是加的写法。
    // 缺陷：
    // obj_3 = 6 + obj_1;//不能这么写，因为没有这个重载，6在前面，6是第一个参数
    // obj_3 = operator+(6, obj_1); //相当于这种写法。如果需要换这个顺序的话，就应该调换一下参数位置，重新写一个重载
    obj_3.display();
    
    return 0;
}

Mycomplex::Mycomplex(double real, double imag) //只需要在声明的时候给默认值，实现的时候不需要
: m_real(real), m_imag(imag)               //成员初始化列表
{
}
//用这种方法（先声明后定义）更加的安全，并且少了拷贝构造
/*
Mycomplex &Mycomplex::operator+(const Mycomplex& other) const //同样也是作为一个函数存在，用类名Mycomplex::去限定函数名
{
    return Mycomplex(this->m_real + other.m_real, this->m_imag + other.m_imag); //直接放回一个匿名对象(没有参数、没有名字的对象)//实部+实部作为实部的参数,虚部+虚部作为虚部的参数
} */
void Mycomplex::display() const
{
    cout << "(" << m_real << "+" << m_imag << "i)" << endl;
}
Mycomplex::~Mycomplex()
{
} 

Mycomplex &Mycomplex::operator+(const Mycomplex& other) const //同样也是作为一个函数存在，用类名Mycomplex::去限定函数名
{
    return Mycomplex(this->m_real + other.m_real, this->m_imag + other.m_imag); //直接放回一个匿名对象(没有参数、没有名字的对象)//实部+实部作为实部的参数,虚部+虚部作为虚部的参数
}
```

### 07-02 规则详解
#### 1 、并不是所有的运算符都可以重载
##### 可以重载的 ：
加减乘除、
求余数的算术运算符、
6 个位运算符、
赋值运算符、
复合赋值运算符的加减等、
关系运算符 （< 、> 、≥ 、≤ 、= =、≠）、
逻辑运算符（与或非）、
自增自减、
逗号、
箭头、
New、delete（虽然是关键字，但是也可以重载），
###### 其中比较特殊一点的 ：
中括号（应该叫下标运算符）、
圆括号（圆括号作为函数调用运算符的时候可以重载），
自增自减（有前置和后置的区别，重载的时候需要注意一下，可以使用一个叫占位参数）、

注：
自增自减由于它本身所重载的运算符就是相同的，所以不管是前置还是后置，都是自增或者自减，它的参数、操作数什么的都一样，所以就搞一个占位参数才可以去区分一下他们。

占位重载，比如图中：多了一个 int 占了一个位置，但是并没有什么实际意义，就告诉我们两个函数是不一样的，仅此而已，这个就叫做占位参数
![[../../附件/0.C++总集_image_93.png]]
![[../../附件/0.C++总集_image_94.png]]


##### 不能重载 ：
Sizeof 不能重载、
三目运算符不能重载、
成员运算符点、
作用域运算符

#### 2. 重载不能改变运算符的优先级和结合性

相当于国家法规>地方法规
重载只能改变具体的规则，但是大层次上的优先级和结合性是不能改变的。比如说你去修改班级座位/班规，但是校规永远>班规

假设重载过了+号和* 号
重载完之后还是先算乘法，然后再去算加法，再按照赋值运算符优先级在此处最低的情况再把值赋给 obj
![[../../附件/0.C++总集_image_95.png]]
相当于: obj = obj 1 +( obj 2 * obj 3 ) ;
![[../../附件/0.C++总集_image_96.png]]

#### 3. 重载不会改变运算符的用法
就是说我们原来去用这个运算符的时候，它有几个操作数，就是说它原本是单目运算符，重载完后还是单目运算符。用法除了目数以外还有一条，操作数是在左边还是右边也是不会改变的（相当于是结合性不会被改变）。

#### 4. 运算符重载不能有默认的参数
我们是通过函数重载的这么一种形式去实现运算符的重载，那么运算符重载肯定是会有参数的。但是不能去增加默认的参数
举个例子：
加法写成全局函数是需要两个参数，而且两个参数它必须要传才能够做加法，不传的话少一个都加不了。但是如果给他一个默认的参数的话，传参数没问题，少传一个好像在函数层面上也可以正常调用。但是在运算符层面，本来需要两个东西才能加起来，现在有了一种默认的参数，一个东西也能加起来了。这就相当于改变了运算符的操作数, 也就改变了它的目数。

#### 5. 运算符重载函数可以作为类的成员函数，可以作为全局函数
作为类的成员函数时，是普通成员函数，有 this 指针，就是你自己，谁去调这个成员函数的时候就会去指向它，所以说只需要一个参数。（由于 this 指针占用了一个位置，所以作为成员函数去写的话，重载任何运算符都要在它原本目数的数量下减少一个参数）
但是作为全局函数就没有 this 指针，该是多少个参数就是多少个参数。

#### 6. 箭头运算符、下标运算符、赋值运算符、函数调用运算符只能以成员函数的形式重载

箭头运算符<font color="#ff0000">-></font>、
下标运算符 <font color="#ff0000">[]</font>、
赋值运算符 <font color="#ff0000">=</font>、
函数调用运算符<font color="#ff0000"> ( )</font>、
只能以<font color="#ff0000">成员函数</font>的形式重载 

也有最好用全局函数去写的运算符重载，输入输出的左移右移的那两个重载

#### 代码
#代码 #运算符重载规则详解

```cpp
#include <iostream>
using namespace std;

int main()
{
    // 重载只能改变具体的规则，但是大层次上的优先级和结合性是不能改变的。比如说你去修改班级座位/班规，但是校规永远>班规
    /*假设重载过了+号和*号
    obj = obj1 + obj2 * obj3;//重载完之后还是先算乘法，然后再去算加法，然后再按照赋值运算符优先级在此处最低的情况再把值赋给obj
    相当于:obj = obj1 +( obj2 * obj3 ) ;
    */
    return 0;
}

/*
 07 - 02 规则详解
1 、并不是所有的运算符都可以重载
    可以重载的 ：
    加减乘除、 求余数的算术运算符、 6 个位运算符、 赋值运算符、 复合赋值运算符的加减等、 关系运算符 （< 、> 、≥ 、≤ 、= =、≠）、 逻辑运算符（与或非）、 自增自减、 逗号、 箭头、 new、delete（虽然是关键字，但是也可以重载）
    
    其中比较特殊一点的 ：
    中括号（应该叫下标运算符）、 圆括号（圆括号作为函数调用运算符的时候可以重载），
    自增自减（有前置和后置的区别，重载的时候需要注意一下，可以使用一个叫占位参数）、

    注：
    自增自减由于它本身所重载的运算符就是相同的，所以不管是前置还是后置，都是自增或者自减，它的参数、操作数什么的都一样，所以就搞一个占位参数才可以去区分一下他们。

    占位重载，比如图中：多了一个 int 占了一个位置，但是并没有什么实际意义，就告诉我们两个函数是不一样的，仅此而已，这个就叫做占位参数
  
    不能重载 ：
    sizeof 不能重载、
    三目运算符不能重载、
    成员运算符点、
    作用域运算符
 */

/*
2.重载不能改变运算符的优先级和结合性
    相当于国家法规 > 地方法规
    重载只能改变具体的规则，但是大层次上的优先级和结合性是不能改变的。比如说你去修改班级座位 /班规，但是校规永远 >班规

假设重载过了 +号和 *号
    重载完之后还是先算乘法，然后再去算加法，再按照赋值运算符优先级在此处最低的情况再把值赋给obj
 */

/*

3. 重载不会改变运算符的用法
    就是说我们原来去用这个运算符的时候，它有几个操作数，就是说它原本是单目运算符，重载完后还是单目运算符。用法除了目数以外还有一条，操作数是在左边还是右边也是不会改变的（相当于是结合性不会被改变）。

4. 运算符重载不能有默认的参数
    我们是通过函数重载的这么一种形式去实现运算符的重载，那么运算符重载肯定是会有参数的。但是不能去增加默认的参数
        举个例子：
        加法写成全局函数是需要两个参数，而且两个参数它必须要传才能够做加法，不传的话少一个都加不了。但是如果给他一个默认的参数的话，传参数没问题，少传一个好像在函数层面上也可以正常调用。但是在运算符层面，本来需要两个东西才能加起来，现在有了一种默认的参数，一个东西也能加起来了。这就相当于改变了运算符的操作数,也就改变了它的目数。

5. 运算符重载函数可以作为类的成员函数，可以作为全局函数

    作为类的成员函数时，是普通成员函数，有 this 指针，就是你自己，谁去调这个成员函数的时候就会去指向它，所以说只需要一个参数。（由于 this 指针占用了一个位置，所以作为成员函数去写的话，重载任何运算符都要在它原本目数的数量下减少一个参数）
        但是作为全局函数就没有 this 指针，该是多少个参数就是多少个参数。

6. 箭头运算符、下标运算符、赋值运算符、函数调用运算符只能以成员函数的形式重载

    箭头运算符->
    下标运算符[]
    赋值运算符 =
    函数调用运算符 ()
    只能以成员函数的形式重载

    也有最好用全局函数去写的运算符重载，输入输出的左移右移的那两个重载
*/
```


### 07-03 重载 >> 与 <<
##### 1 、作为友元函数去重载
建议作为友元函数去重载，也可以作为成员函数去重载
重载的时候是需要两个参数的，那么他需要的这些参数如果把它作为成员函数去写的话，需要改动的地方有很多才能够实现。所以作为友元函数，不要 this 指针。
会涉及两个类：istream：输入、Ostream：输出

##### 2 、istream：输入

##### 3 、ostream：输出


![[../../附件/0.C++总集_image_97.png]]

运行结果
![[../../附件/0.C++总集_image_98.png]]

实际情况：
![[../../附件/0.C++总集_image_99.png]]

![[../../附件/0.C++总集_image_100.png]]

![[../../附件/0.C++总集_image_101.png]]

![[../../附件/0.C++总集_image_102.png]]

#### 代码
#代码 #重载输入和输出

```cpp
/*
通过重载的过程会发现，如果运算符重载是通过友元函数重载，有两个参数，则一般写成第一个参数是cin/cout，当前类的对象写在后面(第二个参数)。

如果运算符重载写成成员函数，则会有this指针，this指针位置是第一个参数，在最前面。所以写成成员函数的话，那么就需要去改系统里面的文件，很麻烦。(可以写，但是麻烦，由于当前类的对象是在运算符的后面的，不适合写成成员函数。)

所以一般写成友元函数更好。
 */
#include <iostream>
using namespace std;

class MyComplex
{
public:
    MyComplex(double real = 0.0, double imag = 0.0)
    : m_real(real), m_imag(imag)
    {}

    friend istream &operator>>(istream &in, MyComplex &com);  //声明友元关系，调用私有成员
    friend ostream &operator<<(ostream &out, MyComplex &com); //声明友元关系，调用私有成员

// private://不知道为什么，把运算符重载的函数声明成了友元friend关系还是会报错，提示不可访问。所以干脆改成了公有成员好了。
    double m_real;
    double m_imag;
};

istream& operator>>(istream &in, MyComplex &com) //考虑到返回引用的话要用到拷贝构造。参数表里面的两个参数是什么看>>两边内容的类型。这个istream写void是可以的。只不过你写这个函数一般是为了可以连续输入多个对象，则用istream(因为要有返回值类型)
{
    in >> com.m_real >> com.m_imag; //发现访问不到，因为访问的成员m_real是私有的，所以考虑去用友元。in当成cin去用就行了
    return in;//为什么需要返回值：如果只单独一次输入就可以，有时候连续的去输入，则需要return in
}

ostream& operator<<(ostream &out, MyComplex &com)
{
    out << "(" << com.m_real << "+" << com.m_imag << "i)"; // out当成cout去用就行了
    return out;
}

int main()
{
/*
    MyComplex obj(2, 3);
    int n;    //看看int类型的n是怎么样存在的。
    
    cin >> n; // istream输入类型
    // cin >> obj >> obj1 >> obj2;//有时候连续的去输入，则需要return in

    // cin >> obj;//那么同样的，假设obj一开始没有给他们参数，先cin输入一下这个obj里面相关的东西，然后再输出，这个也是不允许的

    cout << "suibian" << endl;

    // cout << obj << endl;//希望直接输出obj，现在做不到这样的事情。因为<<输出运算符需要认识obj的类型，但是没有针对这种类型的重载。那么同样的，假设obj一开始没有给他们参数，先cin输入一下这个obj里面相关的东西，然后再输出，这个也是不允许的
 */

    MyComplex obj;
    cin >> obj;//声明和实现时的参数表不统一，声明时比实现时参数表中的Mycomplex &com少了引用&，导致报错：有多个运算符">>"与这些操作数匹配
    //实际上通过">>"输入的重载，执行运算符重载函数的函数体中的"in >> com.m_real >> com.m_imag;"把实部和虚部依次输入进去，然后再一次输出返回。
    cout << obj << endl;//调用的时候实际上是把cin传给istream运算符重载函数中参数表的第一个参数istream& in中的in，把cout传给ostream运算符重载函数中参数表的第一个参数ostream& out中的out
  
    //作为函数调用的形式去写:(与上面的写法其实的一样的)
    // cin.operator>> // cin只是一个对象而已，通过一个对象去调用一个函数，没有问题。
    operator>>(cin, obj); //全局函数，所以直接用operator。//相当于cin>>obj;
    operator<<(cout, obj); //相当于是cout<<obj;

    MyComplex obj_1;//假设还有一个对象
    cin >> obj >> obj_1;//连续去输入。
    operator>>(operator>>(cin, obj), obj_1); //首先，肯定是从左到右去输。相当于是先输入obj,然后返回一个值，返回的一个值就是cin，然后再去输入obj_1。是一个函数的嵌套调用。
    //cin>>obj相当于最里面一层括号内的operator>>(cin,obj)，然后再返回一个值与第二层括号的obj_1就行输入。
    // 为什么可以这样去嵌套调用呢？因为前面写返回值类型是istream。有返回值的函数调用可以作为其他函数的实参。

    cout << obj << endl << obj_1 << endl;//连续去输出，会是什么样的形式呢？
    operator<<(operator<<(cout, obj), obj_1); //相当于是这个。

    Return 0;
}
```

#### Time
[2023-07-26 17：49：49]

---

### 07 -04 运算符重载的注意事项
##### 1 、运算符重载的语法规则非常简单，关键是规则。
写成成员函数就会少一个参数，少的就是调用当前函数的这个 (左边那个)。

##### 2 、可以显示调用，也可以隐式调用。
直接调函数就是显示调用，看得到这个函数。
如：
Operator>>(cin, obj);
Operator<<(cout, obj);
Operator>>(operator>>(cin, obj), obj_1);
Operator<<(operator<<(cout, obj), obj_1);

也可以隐式调用，也就是直接写运算符，看不见这个函数。
如：
Cin >> obj;
Cout << obj << endl;
Cin >> obj >> obj_1;
Cout << obj << endl << obj_1 << endl;

##### 3 、注意与友元的联合使用。
友元虽然会破坏封装，但是在这样的地方就很适合使用。
需要注意的是，虽然破坏封装可以访问到私有成员，不过要注意不要再这些友元函数中对这些私有成员进行修改。所以就可以考虑加个 const (只读)，使其只能查看，不能修改，就不会去影响到他的封装。

##### 还需要注意的一个点 ：赋值函数
赋值运算符是有一个默认的赋值函数的，不需要你自己去把它进行一个重载。但是参考拷贝构造里面的深拷贝和浅拷贝，在这里赋值其实也就是一样的，因为默认的赋值函数里面的函数体给你执行的逻辑其实和默认的拷贝构造函数是一样的。就是把两个对象之间同名的 (对应的成员)一一对应的去给个值，这是默认的赋值函数会去做的事情。但是像之前拷贝构造一样，指针指向不能直接给过去，要重新去申请一段内存。赋值函数同理，不能直接简单的就把指向赋值过去，需要重新申请内存，然后再给过去。把内存里面的内容拷贝过来，指向就指当前的这一段内存。也就是说，涉及到指针，不但自己的拷贝构造要自己去写深拷贝，像赋值函数，就需要自己去实现一下。

---



