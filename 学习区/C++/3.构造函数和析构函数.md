## 三、构造函数与析构函数

学习构造析构函数

完成对象数据成员的初始化和清理工作

掌握对象的构造和析构方法

普通构造函数、拷贝构造函数、析构函数

### 01 .普通构造函数

构造函数是一种特殊的成员函数
主要用来在创建对象时初始化对象——为对象的成员变量赋初始值

构造函数名和类名相同
构造函数没有返回值类型，也没有返回值
构造函数可以重载，需要满足函数重载的条件

在创建一个新的对象的时候会自动调用

如果一个类中没有给出构造函数，系统会自动地给出一个构造函数（公有属性）。（有函数名，但参数表为空，函数体也为空（低保））该函数直接在类的里面实现，默认为内联函数，它会通过内存膨胀，牺牲空间去换取时间。
但是如果写了任何一个构造函数，即便没有实现，只是声明了该构造函数，也将无法获得系统自动给出的构造函数。
所以平时写函数尽量先声明（可在类中声明）在类中，而定义（实现）写在类的外面。

有多个构造函数时，系统自动分配的构造函数就没有了

在创建一个新的对象的时候，系统会主动的、自动的帮我们去调用构造函数
如果一个类中没有显式的给出构造函数
系统就会自动地给出一个（无参）构造函数（公有属性）
注：因为创建对象后自动去调用构造函数，此时相当于是在类的外部去访问成员函数，如果是私有属性，无法访问，所以系统给的构造函数是公有属性的。

与函数重载一样，也有二义性。所以我们要尽可能的避免在写函数的时候冲突（不声明/定义同类名、同参数表的函数）。

构造函数也可以缺省（也可以声明函数某个参数（形参）的时候指定一个**默认值**。）。

Const 在 C 语言中的作用是将一个变量修饰的只有“只读”的属性（只能读取，不能直接修改），变量还是变量，只是具有了“只读”的属性；在 C++中，const 直接改变性质，成为一个常量。
Const 修饰时就必须初始化它。

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps16.jpg) 

Const：这么初始化语法上没有错误，但后续无法进行修改它

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps17.jpg) 

有时数据成员必须初始化，而不能再构造函数中赋值——用成员初始化列表的方式给数据成员赋值。

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps18.jpg) 

成员初始化列表：帮助我们把需要要初始化的内容初始化（如 const 和引用，都可以用这种方法去初始化）

方法：在构造函数的参数列表后面加上冒号：，冒号后接上需要初始化的成员，成员后加上括号（），括号中加入需要赋值的传参（其前后要一致），也可不传参，直接赋常量值。
多个成员初始化列表时，成员之间用逗号隔开。
在成员初始化列表结尾不加分号。

Myclass (类型变量 1): 成员 1 (变量 1)，成员 2 常量

先声明后定义的构造函数，其照常声明构造函数，声明构造函数的时候不用初始化列表，初始化列表是加在实现该函数的时候
（成员初始化列表写在定义函数的时候，参数表的后面。如果先声明后定义，声明的时候不用写初始化列表，也写在定义后面。）

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps19.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps20.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps21.jpg) 

  
#### 代码
#代码 #普通构造函数
```cpp
#include <stdio.h>
#include <iostream>
#include <string>
using namespace std;
  
class Myclass
{
public:
    int num;
private:
    int val; 
public:
    Myclass() //无参构造函数
    {
        cout << "Myclass()" << endl;
    }
    //构造函数，只要是成员函数都可以声明在类里面，定义在外面
    //系统默认的构造函数：
    /*Myclass()
    {
    }
    */
    /*如果把成员函数的函数体直接实现在类中，
    这个构造函数就默认是一个内联函数，
    通过内存膨胀，牺牲空间去换取时间。
    一般情况下，尽量在类中声明，外面去实现*/
    Myclass(int n, int v) //带参构造函数
    {
        cout << "Myclass(int n,int v)" << endl;
        num = n;
        val = v;
    }
    void setVal(int v);
    int getVal();
};

void Myclass::setVal(int v)
{
    val = v;
}
 
int Myclass::getVal()
{
    return val;
}
  
/*
Myclass::Myclass()//构造函数写在外面
{
}
*/
  
int main()
{
    Myclass obj; //构造函数在创建一个对象的时候会自动帮你去调用
    // obj.Myclass();
    //不能通过对象去调用这个构造函数(我们不能主动的去调用这个构造函数)
    //由系统自动调用这个构造函数，并且是在创建一个新的对象的时候
    obj.num = 0;
    cout << obj.num << endl;
  
    obj.setVal(10);
    cout << obj.getVal() << endl;
}
```
![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps14.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps15.jpg) 
#### Time
[2023-07-04 11:32:14]编写代码
[2023-07-04 23:44:44]重温

---
### 02 析构函数

析构函数是一种特殊的函数，其主要作用是在对象生命周期结束时进行清理，系统是可以自动调用析构函数的

C 语言和 C++中唯一一个函数名不仅仅是合法标识符组成的，函数名包括~这一部分。函数名与类名相同，在前面加上一个 ~

析构函数没有返回值类型和返回值，也没有参数（参数表必须是空的，但是括号还是要写，只是为空）

析构函数有低保，没写系统会给默认的析构函数

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps22.jpg) 

上图未报错，该图中红圈内未报错，说明这种语法没错，有析构函数~Myclass，系统自动分配了一个低保。具体如下图

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps23.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps24.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps25.jpg) 

析构函数可以主动通过对象调用

析构函数必须是公有属性下
//对象是定义及使用在类外面，其在生命周期结束时调用析构函数，属于类外去调用一个成员函数，所以析构函数是公有属性

在对象生命周期结束时，会自动调用一次析构函数
//如上图，创建对象后运行结果出现了构造函数和析构函数中 cout 出来的内容，说明创建对象时系统自动调用构造函数，并在对象结束时自动调用析构函数

析构函数不是因为调用了析构函数导致生命周期结束，而是生命周期结束时会自动调用析构函数（注意因果关系）（调析构函数的时候不会释放对象，但是释放对象时系统一定会调析构函数）

任何希望在对象生命周期结束时要做的，都可以写到析构函数中

任何一个类都只有一个析构函数（函数名确定了，参数表无参数，不可能产生重载了）并且肯定会有一个析构函数 

#### 代码
#代码 #析构函数

```cpp
#include <iostream>
using namespace std;
/*实际上Myclass中是这样的//有一个构造、一个析构
class Myclass
{
    public:
        Myclass();
        ~Myclass();

        private:
};
  
Myclass::Myclass()//系统默认的构造函数
{
    cout<<"构造"<<endl;
}

Myclass::~Myclass()//系统默认的析构函数
{
    cout<<"析构"<<endl;
}
*/

class Myclass
{
    public:
        int id;
};
  
int main()
{
    Myclass obj_0;
    obj_0.~Myclass();//没写析构函数的话，系统会自动给默认的析构函数
  
    return 0;

}
```
#### Time
[2023-07-05 00:03:06]编写、重温

---
### ❗03 拷贝构造函数

拷贝构造函数是一种特殊的构造函数，通过拷贝构造函数可以完成一个复制过程，从一个对象复制出另一个对象，数据内容一致，注意，对象是两个不同的。

全称：拷贝构造-（构造）函数，不是拷贝（构造）-构造函数

特殊：第一个参数必须是本类的对象的引用：拷贝构造函数的第一个参数是当前这个函数的引用，其他的参数可以不一样

拷贝构造函数先是构造函数，然后才可能是拷贝构造函数

拷贝构造函数有低保：没写系统会自动给，将成员一一对应赋值，也可以自定义

空类中有三个默认的函数——默认的构造函数、默认的析构函数、默认的拷贝构造函数, 如图：(注：实际上有很多的“低保”可以吃，但是目前了解的是这三个)

什么情况下会触发拷贝构造函数的调用（拷贝构造函数的调用时机）
调用时机：**注意：网课的编译器不一样，学习调用时机处的代码运行结果显示与自身不一样**
1. 使用一个对象给另一个对象进行初始化
同类对象给一个对象初始化的时候会调用（m 2）
2. 使用一个对象构造另一个对象
一个对象去构造另一个对象的时候会调用（m 3）
3. 函数的参数是类的对象
4. 函数的返回值是类的对象
注意：return 的前后属于函数体内外。函数体内的要拷贝构造一份复制体使用然后释放自己，函数体外部的则无需拷贝，直接使用。拷贝后传过去的复制体如果在后续没有使用，则也会释放自己。

先进来创建一个对象调用无参构造，然后返回的时候它本身（obj）必定被释放。此时通过复制体返回出去，所以说返回值返回的是复制体而不是它本身。所以 return obj; 处会调用一次拷贝构造。
掉完拷贝构造之后，马上就会结束这个函数体就过来了（来到 main 主函数），于是 obj 此时就要被释放，释放就要调用一次析构。
完毕后，此时 main 主函数这边返回复制体出来了，复制体既然返回出来了，那么这里就有了一个复制体，马上主函数结束。主函数结束之后，这个复制体返回出来的复制体也会被释放掉，所以也会调用析构一次。
更精确的描述：复制体返回出来后，在第（76 行），没有任何一个当前类的对象去接收你的这个复制体。于是就会在这一行直接释放掉。如果后面还有其他的语句在执行，在执行后面的其他语句之前，这个复制体在这种写法的情况下，它已经释放掉了。
但是如果是 Monster monster=test_func_2 (); 这种写法下，有东西去接收它（obj 的复制体）

深拷贝与浅拷贝
浅拷贝：默认的都是浅拷贝（它属于是一一对应赋值）——好比考试时无脑抄袭
深拷贝：需要自己根据实际情况实现（有点脑子）——好比考试时该抄的地方抄，不该抄的谨慎（就像别人的学号、名字别抄过来了（指针问题））

怎么防止默认拷贝发生？（防不胜防）
我们可以主动让程序报错（主动报错更好去发现和修改）
在一个类中如果声明了指针，但是没有定义，在没调用这个函数的情况下，它不会有问题。
但凡调用了，有声明，没定义的话，就会报错。
所以我们可以声明一个私有的拷贝构造函数，但是不对它进行定义（<font color="#ff0000">私有的、不定义</font>），没有函数体。那么只要出现了拷贝构造，首先你写了一个自己的声明的拷贝构造，那么就不会有低保了。如果需要调用这个拷贝构造，首先它是私有的，访问不到。其次没有函数体，会告诉我们未定义。（双重保险）让我们只要调用了拷贝构造，我们就会发现，再进行调整。

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps26.jpg) 

![](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4368\wps27.jpg) 

![](../../附件/0.C++总集_image_5.png)

![[../../附件/0.C++总集_image_6.png]]

![[../../附件/0.C++总集_image_7.png]]

![[../../附件/0.C++总集_image_8.png]]

在 return 后面的叫匿名对象。
![[../../附件/0.C++总集_image_9.png]]

指针再拷贝构造函数中的问题
![[../../附件/0.C++总集_image_10.png]]
![[../../附件/0.C++总集_image_11.png]]
![[../../附件/0.C++总集_image_12.png]]
![[../../附件/0.C++总集_image_13.png]]

#### 代码 1--基础拷贝构造函数认知
#代码 #拷贝构造函数

```cpp
#include <iostream>
using namespace std;
#include <string>

class Monster
{
public:
    string m_name;
    int m_hp;
    float m_speed;

public:
    Monster();
    Monster(char *name, int hp, float speed);
    Monster(Monster &obj);
    Monster(Monster &obj, int val); //重载一个拷贝构造
    ~Monster();
    
    void showData(); //声明一个对象去显示数据 
    
private:

};
  
Monster::Monster()
{
    cout << "无参构造" << endl; //
    m_name = "名字";
    m_hp = 100;
    m_speed = 10.0f;

}
  
Monster::Monster(char *name, int hp, float speed)
{
    cout << "带参构造" << endl; //
    m_name = name;
    m_hp = hp;
    m_speed = speed;
}

  

Monster::Monster(Monster &obj) //默认的拷贝构造，有什么就抄一份
{
    cout << "默认的拷贝构造(1号)" << endl; //
    m_name = obj.m_name;
    m_hp = obj.m_hp;
    m_speed = obj.m_speed;
}

//拷贝构造函数重载，一般不这么用，只用上面那种默认的
Monster::Monster(Monster &obj, int val)
{
    cout << "拷贝构造2号" << endl; //
    m_name = obj.m_name;
    m_hp = val; //用val来取代血量
    m_speed = obj.m_speed;
}
 
/*
析构函数中什么都不做，因为成员都可以被系统自动释放
什么时候用做：比如说有一个成员申请了堆区的内存，申请了要释放，就写到析构函数中
这样就不存在忘记释放内容，因为写到析构函数中去后，任何一个对象在生命周期结束的时候系统都会自动的调用这个析构函数，肯定就不会忘记释放堆区的内存
*/

Monster::~Monster()
{
    cout << "析构函数" << endl; //
}

void Monster::showData()
{
    cout << "角色名称:" << m_name << endl;
    cout << "当前血量:" << m_hp << endl;
    cout << "移动速度:" << m_speed << endl;
    cout << "***********" << endl<< endl;
}

int main()
{
    Monster m0;                       //没带参数，调用无参构造
    Monster m1("皮卡丘", 120, 10.0f); //调用带参构造函数
    Monster m2 = m0;                  //调用默认的拷贝构造函数（1号）
    //调用时机：同类对象给一个对象初始化的时候会调用（m 2）
    Monster m3(m0);                   //与m2一样，都是调用拷贝构造1号，写法不同
    //调用时机：一个对象去构造另一个对象的时候会调用
    Monster m4(m1, 180);              // m4掉拷贝构造函数2号
  
    Monster *p = new Monster; //无参数，调用无参构造
    //不会自动释放，因为是堆区的。不还就不会收
    //以上掉用了六次构造，却只有五次析构
    //    delete p;
    //    p = NULL;//哪里释放内存就在哪里析构，所以会在下面几条代码之前执行
  
    m0.showData();
    m1.showData();
    m2.showData();
    m3.showData();
    m4.showData();
    p->showData(); //默认的无参构造
    //上面delete后此处p->showData();就不能用了
    
    //哪一个先调用构造函数，哪一个就最后再析构(先构造的后析构)
    //如这里先析构的是m4，因为m4最后构造出来的
    //堆区不在考虑范围之内，堆区的(析构)释放由自己决定
    return 0;

}
```
#### 代码 2--调用时机
#代码 #拷贝构造函数 

```cpp
#include <iostream>
using namespace std;
#include <string>

class Monster
{
public:
    string m_name;
    int m_hp;
    float m_speed;
  
public:
    Monster();
    Monster(char *name, int hp, float speed);
    Monster(Monster &obj);
    Monster(Monster &obj, int val); //重载一个拷贝构造
    ~Monster();
 
    void showData(); //声明一个对象去显示数据  
private:

};

//---前面与上一节代码同样。下面为调用时机



//在全局区来添加一个普通的全局函数
// 3.函数的参数是类的对象
void test_func_1(Monster obj)
{
    //只要它参数是类的对象，函数体不写也没事
}

// 4.函数的返回值是类的对象
Monster test_func_2() //返回值类型是类的类型（此处为Monster）
{
    Monster obj; //先在里面创建一个这样的对象
//  Monster obj();//带参构造的话也可以传参数
    return obj;  //然后把这个对象返回出去
}  

Monster test_func_3() //返回值类型是类的类型（此处为Monster）
{
    return Monster();//这个叫匿名对象(就是没有名字的一个对象)。此处创建匿名对象。
} 

int main()
{
//    Monster m0;                       //没带参数，调用无参构造
//    Monster m1("皮卡丘", 120, 10.0f); //调用带参构造函数  
//   test_func_1(m1); //调用函数，参数传类的对象。实参的值拷贝给形参
    //把m1传给obj的时候去调用的(结果显示：默认的拷贝构造(1号))
    //三个析构。第一个析构是test的，第二个是m1的，第三个是m0的
    /*构造和析构函数的调用顺序的问题
    因为test_func_1这个函数调用完毕之后才会回到主调函数，
    回到主调函数来的时候test_func_1结束了，
    test函数的参数表中的obj也就结束了生命周期了，
    所以它要先释放，所以要先析构
    回来后才会结束这个主函数main，结束这个主函数的时候就结束m0，m1的生命周期
    那么就形成了先构造的后析构
    */
//    test_func_2();//调用该函数时就无需传参数了。//像这种没有东西去接收这个复制体的话，那么系统就会给你创建一个看不见摸不着的
//    对象。(在test_func_2外面创建一个对象)，然后把obj拷贝给外面这个不知名对象。
//    Monster monster=test_func_2(); //返回出去，在此处接收的其实不是obj，因为obj在这个test_func_2中已经被释放掉了
//    而如果有一个对象去接收这个复制体的话，系统会直接把obj复制给对象(monster)，所以这种有对象接收的就不会再额外调用拷贝构造了
    test_func_2();//拷贝出去的这一份就在函数的调用的地方返回出去了
    //所以return obj;实际上返回出去的是obj的复制体。既然要返回出去，则要拷贝一份出去
    /*首先从主调函数进入被调函数，该过程无参数，所以不存在调用别的函数
    接下来执行函数体，
    执行函数体时需要定义一个object，在此处object属于无参构造(函数体内第一段代码Monster obj;)
    返回的时候object作为一个栈区的对象，是不会被直接返回出去的
    类似这样的栈区对象，它会在这个函数体结束的时候就会被系统自动回收内存，它就没了。
    既然它在这个函数里面没了，就必不可能被返回出去*/  
    
    /*
    先进来创建一个对象调用无参构造，然后返回的时候它本身（obj）必定被释放。此时通过复制体返回出去，所以说返回值返回的是复制体而不是它本身。所以 return obj; 处会调用一次拷贝构造。
    掉完拷贝构造之后，马上就会结束这个函数体就过来了（来到 main 主函数），于是 obj 此时就要被释放，释放就要调用一次析构。
    完毕后，此时 main 主函数这边返回复制体出来了，复制体既然返回出来了，那么这里就有了一个复制体，马上主函数结束。主函数结束之后，这个复制体返回出来的复制体也会被释放掉，所以也会调用析构一次。
    更精确的描述：复制体返回出来后，在第（76 行），没有任何一个当前类的对象去接收你的这个复制体。于是就会在这一行直接释放掉。如果后面还有其他的语句在执行，在执行后面的其他语句之前，这个复制体在这种写法的情况下，它已经释放掉了。
    */

    Monster monster = test_func_2(); 
    
    test_func_3(); // return 匿名对象; 此时结果显示无参构造且析构。
    /*为什么可以直接无参构造且析构，没有拷贝构造了？
    因为以return语句为界线，以它为一个分界点。
    Return 后面的可以认为是函数外面的。
    所以此处在return后面去创建各种东西不用再去拷贝了。
    即，如果是返回函数里面的东西，则要拷贝出来。
    而如果是函数外部的 (return 后面的)则无需拷贝构造了。
    */
    Monster monster = test_func_3();/*如果是用一个对象去接收它也是同理，
    不会去额外的调用拷贝构造，而是直接把创建的东西直接给到对象(monster)*/

    return 0;

}
```


#### 代码 3--深浅拷贝
#代码 #拷贝构造函数 


```cpp
// 1.在默认构造里面给指针p制空
// 2.在带参构造里面给指针p = new int[10];
// 3.默认的拷贝构造中的问题--指针指向同一个地方
// 4.给你的这个新对象重新开辟一段内存，并且让它重新指向这里
// 5.怎么防止默认拷贝构造的发生

#include <iostream>
using namespace std;
#include <string>
class Monster
{
public:
    string m_name;
    int m_hp;
    float m_speed;
    int *p;
  
public:
    Monster();
    Monster(char *name, int hp, float speed);
    Monster(Monster &obj);
    Monster(Monster &obj, int val); //重载一个拷贝构造
    ~Monster();

    void showData(); //声明一个对象去显示数据
 
private:

}; 
  
//在默认构造里面给指针p制空
Monster::Monster()
{
    cout << "无参构造" << endl; //
    m_name = "名字";
    m_hp = 100;
    m_speed = 10.0f;
    p = NULL;
}

//在带参构造里面给指针p = new int[10];
Monster::Monster(char *name, int hp, float speed)
{
    cout << "带参构造" << endl; //
    m_name = name;
    m_hp = hp;
    m_speed = speed;
    p = new int[10];
}
  
//默认的拷贝构造中的问题--指针指向同一个地方
Monster::Monster(Monster &obj) //默认的拷贝构造，有什么就抄一份
{
    cout << "默认的拷贝构造(1号)" << endl; //低保构造
    m_name = obj.m_name;
    m_hp = obj.m_hp;
    m_speed = obj.m_speed;
//    p = obj.p;这种情况不对，指针不能这么用。两个指针指向同一个地方
    /*低保构造还是这样去给。即一一对应赋值。但是这样并没有什么含义，这样给它是会有问题的。
    这样两个指针是给过去指向(把指向给过去了)。这样有问题。
    两个对象的指针都是指向同一块内存。
    所以像这样有指针的情况就不能这样去指向。
    那就应该给你的这个新对象重新开辟一段内存，并且让它重新指向这里。*/
}

//拷贝构造函数重载，一般不这么用，只用上面那种默认的
//给你的这个新对象重新开辟一段内存，并且让它重新指向这里
Monster::Monster(Monster &obj, int val)
{
    cout << "拷贝构造2号" << endl;
    m_name = obj.m_name;
    m_hp = val; //用val来取代血量
    m_speed = obj.m_speed;
    p = new int[10];//先自行申请一段新的内存
    for (size_t i = 0;i<10;i++)//因为内存为10，所以用一个for循环
    {
        p[i] = obj.p[i];//如果只有一个直接拿过去即可，就无需for循环
        //*(p + i) = *(obj.p + i);//两种写法均可
    }
    //申请完后，你可以把这张内存里面的数据拷贝过来，不能指针指过去
}
  
/*
析构函数中什么都不做，因为成员都可以被系统自动释放
什么时候用做：比如说有一个成员申请了堆区的内存，申请了要释放，就写到析构函数中
这样就不存在忘记释放内容，因为写到析构函数中去后，任何一个对象在生命周期结束的时候系统都会自动的调用这个析构函数，肯定就不会忘记释放堆区的内存
*/

//在析构函数中delete指针，且把指针制空。要用if语句先确认后释放。
Monster::~Monster()
{
    cout << "析构函数" << endl; //
    if(p!=NULL)//要先确定指针是否为空，如果已经为空是不能够重复delete的。先确认，再释放
    {
        delete p;
        p = NULL;
    }  
}
  
void Monster::showData()
{
    cout << "角色名称:" << m_name << endl;
    cout << "当前血量:" << m_hp << endl;
    cout << "移动速度:" << m_speed << endl;
    cout << "***********" << endl << endl;
}
  
int main()
{
    Monster m0;                       //没带参数，调用无参构造
    Monster m1("皮卡丘", 120, 10.0f); //调用带参构造函数
    Monster m2 = m0;                  //调用默认的拷贝构造函数（1号）
    //调用时机：同类对象给一个对象初始化的时候会调用（m2）
    Monster m3(m0); //与m2一样，都是调用拷贝构造1号，写法不同
    //调用时机：一个对象去构造另一个对象的时候会调用
    Monster m4(m1, 180); // m4掉拷贝构造函数2号  
    Monster *p = new Monster; //无参数，调用无参构造
    //不会自动释放，因为是堆区的。不还就不会收
    //以上掉用了六次构造，却只有五次析构
    //    delete p;
    //    p = NULL;//哪里释放内存就在哪里析构，所以会在下面几条代码之前执行

    m0.showData();
    m1.showData();
    m2.showData();
    m3.showData();
    m4.showData();
    p->showData(); //默认的无参构造
    //上面delete后此处p->showData();就不能用了 
    //哪一个先调用构造函数，哪一个就最后再析构(先构造的后析构)
    //如这里先析构的是m4，因为m4最后构造出来的
    //堆区不在考虑范围之内，堆区的(析构)释放由自己决定
    return 0;
}

/*怎么防止默认拷贝发生？（防不胜防）
我们可以主动让程序报错（主动报错更好去发现和修改）
在一个类中如果声明了指针，但是没有定义，在没调用这个函数的情况下，它不会有问题。
但凡调用了，有声明，没定义的话，就会报错。
所以我们可以声明一个私有的拷贝构造函数，但是不对它进行定义（<font color="#ff0000">私有的、不定义</font>），没有函数体。那么只要出现了拷贝构造，首先你写了一个自己的声明的拷贝构造，那么就不会有低保了。如果需要调用这个拷贝构造，首先它是私有的，访问不到。其次没有函数体，会告诉我们未定义。（双重保险）让我们只要调用了拷贝构造，我们就会发现，再进行调整。*/
```

#### Time
[2023-07-02 18:31:41]~[2023-07-02 18:55:50] 重温+检索 GitHub:luc_github:
[2023-07-05 23:17:49]重温拷贝构造函数的基本认知，并学习调用时机和深浅拷贝

---





