
###### 创建任务 2、记录 handle
![[../../../annex/06-4.空闲任务及其钩子函数_image_1.png]]

把任务 2 放到任务 1 中去创建，并且要记录它的 handle ，便于去删除它。
![[../../../annex/06-4.空闲任务及其钩子函数_image_2.png]]

![[../../../annex/06-4.空闲任务及其钩子函数_image_3.png]]
返回值

###### 设置任务 2
![[../../../annex/06-4.空闲任务及其钩子函数_image_4.png]]
提高任务 2 的优先级，让任务 2 马上去执行
任务 2 的优先级更高（放在了任务 1 中去创建），一旦创建成功，马上来执行任务 2。
![[../../../annex/06-4.空闲任务及其钩子函数_image_5.png]]

###### 删除任务 2
![[../../../annex/06-4.空闲任务及其钩子函数_image_6.png]]
![[../../../annex/06-4.空闲任务及其钩子函数_image_7.png]]


![[../../../annex/06-4.空闲任务及其钩子函数_image_8.png]]


任务 2 需要定义在任务 1 前面。（任务 1 中用到了任务 2）
![[../../../annex/06-4.空闲任务及其钩子函数_image_9.png]]



Main 函数中创建任务 1 (优先级 1) -> 任务 1 -> 创建任务 2 (优先级 2) -> 执行创建成功的优先级更高的任务 2 -> 打印字符“2” -> delay 进入阻塞状态 -> 回到任务 1 运行 -> 删除任务 2

在任务 1 while (1)中，不断的创建任务 2 和删除任务 2。

对于任务的清理工作（内存的回收工作）是放在空闲任务里的

系统中有 3 个任务，idel task（0）、task 1（1）、task 2（2）
![[../../../annex/06-4.空闲任务及其钩子函数_image_10.png]]
Idle 任务的优先级低，无法执行，没法去执行清理工作。意味着任务 1 中不断的去创建，但是清理工作无法执行，于是内存（堆）逐渐就会耗光，最终导致创建任务失败。

![[../../../annex/06-4.空闲任务及其钩子函数_image_11.png]]
没有打印 “xTaskCreate err”。

![[../../../annex/06-4.空闲任务及其钩子函数_image_12.png]]
改为自杀，打印 “xTaskCreate err”。
![[../../../annex/06-4.空闲任务及其钩子函数_image_13.png]]
打印了几次后就出错了，出错的唯一原因是内存不够了（堆不够了）。
在 xTaskDelete 自杀中出错了，没有释放内存。
使用“自杀”方式应该由空闲任务来帮你释放内存，（自杀需要由别人来清理尸体）
![[../../../annex/06-4.空闲任务及其钩子函数_image_14.png]]

![[../../../annex/06-4.空闲任务及其钩子函数_image_15.png]]
启动调度器时会帮忙创建空闲任务。
![[../../../annex/06-4.空闲任务及其钩子函数_image_16.png]]
Idle 空闲任务可以使用静态内存分配的方法来创建，也可以使用 xTaskCreate 函数来创建动态分配内存
![[../../../annex/06-4.空闲任务及其钩子函数_image_17.png]]

![[../../../annex/06-4.空闲任务及其钩子函数_image_18.png]]
空闲任务的作用之一：清理自杀的任务

![[../../../annex/06-4.空闲任务及其钩子函数_image_19.png]]
可以在这个函数中添加自己的代码，但是为了避免修改/破坏 FreeRTOS 的核心文件。
提供了一个函数（钩子函数）

###### 钩子 HOOK 函数
![[../../../annex/06-4.空闲任务及其钩子函数_image_20.png]]
定义了宏：configUSE_IDLE_HOOK，在空闲任务中就会帮助调用这个函数：vApplicationIdleHook ();
所以要定义这个宏 configUSE_IDLE_HOOK 并实现函数 vApplicationIdleHook();

钩子函数的限制：
![[../../../annex/06-4.空闲任务及其钩子函数_image_21.png]]
限制：因为空闲任务会执行一些清理工作，如果空闲任务阻塞了，那么就无法执行清理工作。并且也没有其他任务去唤醒你（一旦阻塞，可能永久阻塞）-- 空闲任务要么处于运行状态，要么处于就绪状态（不能进入阻塞和暂停状态）。
建议：并且空闲任务会执行清理工作，尽可能的执行越快越好（清理的越快越好）


![[../../../annex/06-4.空闲任务及其钩子函数_image_22.png]]
创建宏 configUSE_IDLE_HOOK
![[../../../annex/06-4.空闲任务及其钩子函数_image_23.png]]
创建任务 1、任务 2、idle 任务
![[../../../annex/06-4.空闲任务及其钩子函数_image_24.png]]
在任务中设置对应的变量。
![[../../../annex/06-4.空闲任务及其钩子函数_image_25.png]]
打印字符，观察高电平。

要想钩子函数能够执行，必须要把任务 1 设置为 0，任务 1 和空闲任务就可以交替执行了。

![[../../../annex/06-4.空闲任务及其钩子函数_image_26.png]]
程序没有崩溃，因为空闲任务有机会执行。一旦有机会执行就会去执行清理工作，内存就不会被耗尽。

空闲任务执行的时候会调用到所提供的钩子函数，钩子函数不能来个死循环。否则空闲任务就不能做其他事情了，不能做其他的清理工作。

任务 1 先执行->任务 1 中创建了任务 2 且优先级最高，执行任务 2->执行完任务 2，自杀->剩下的任务 1 和空闲任务优先级都是 0，交替执行



弹幕：如果不用钩子函数，直接将任务1的优先级改为0也可以
弹幕：是的钩子函数是啥也没干，但是给 idle 分配时间片的意义更大于 idle 钩子函数
弹幕：这个钩子函数只是 RTOS 空闲任务预留的可以自定义内容的一部分，其余工作核心代码完成了。
弹幕：把任务1的优先级设置为0了，此时 idle 可以执行了
弹幕：清理是空闲任务函数，freertos 帮我们实现了，钩子函数只是可以顺便实现一些其他功能
弹幕：这里 flag 是不是不用到啊，没看到其他地方用到，就是作为一个标识？
弹幕：flag 就是好在逻辑分析仪里看波形






















































































































































