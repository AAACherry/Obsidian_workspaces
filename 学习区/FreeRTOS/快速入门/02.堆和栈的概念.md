
##### 栈
函数 my_malloc 返回一个指针类型（void*）
这里返回的是指向内存某个位置的指针，void 表示没有指定数据类型是什么
```
他这个空格写的不好，应该是 void* my_malloc ,void *是一个类型，他可以指向所有的指针
```
空指针类型返回一个空指针 void 指针可以指向任意类型的数据

```
char heap_buf[1024]; //一个空闲的内存，在它上面实现内存的分配和释放就是一个堆
int pos = 0;//用一个整数来表示空闲内存的位置

void *my_malloc(int size)
{
	int old_pos = pos;
	pos += size;
	return &heap_buf[old_pos];//返回这个位置的地址
}

void my_free(void *buf)//假装实现了free
{
	/*err*/ 
}

int main(void)
{
	char ch = 65;//char ch = 'A'
	int i;
	char *buf = my_malloc(100);
	
	unsigned  char uch = 200;
	
	for(i=0;i<26;i++)
	{
		buf[i]='A'+i;
	}
}
```
当我们在这个空闲内存上实现 my_malloc 函数的时候，这块空闲的内存就被称为堆。
![[../../../annex/Pasted image 20240202171413.png]]

![[../../../annex/Pasted image 20240202171917.png]]
使用中文目录退出调试时会报错。


##### 堆
在整个过程中都没有感受到堆的存在。
```
void c_fun(void)
{
}

void b_fun(void)
{
	//里面什么都不做
}

int a_fun(int val)
{
	int a = 8;
	a += val;
	
	b_fun();//	return a之前让它调用b函数
	
	c_fun();
	
	return a;
}

int main(void)
{
	a_fun(46);
	
	return 0;
}

```

Q 1：返回地址保存在哪里？
：返回地址保存在栈中（栈即是一块空闲的内存）
![[../../../annex/Pasted image 20240202180823.png]]

在调用 main 函数之前，要使用汇编代码设置 SP（栈寄存器），让 SP 指向一块空闲的内存

Main 函数怎么去调用函数 a？
需要记录 a 的返回地址。
1、把返回地址保存在某个寄存器中（LR--Link Register，可以用来保存一些词）
Main 函数在调用函数 a 之前，会先把这条语句（return 0）的地址保存进来
（LR = ①的地址）
然后调用函数 a
![[../../../annex/Pasted image 20240202175749.png]]

函数 a 要去调用函数 b，也得把返回地址保存下来。（不保存下来的话，在函数 b 执行完后如何知道怎么跳转回来？）
所以说，a 函数在调用 b 函数时也是类似的

A_fun -> b_fun?
LR=②的地址
然后调用函数 b_fun

问题出现：①和②的地址都保存在 LR 中。
LR 被覆盖？
在这个场景中，如果不进行处理，那么 LR 寄存器中的值一定会被覆盖。
如何处理？
在函数 a 内部，把 LR 的值进行保存。（把 LR 存入栈中）
把语句①的地址保存在栈中，后面调用函数 b 时就不怕被覆盖了。

同理，函数 b 也会在函数 b 的内部也把返回地址进行保存在栈中。


![[../../../annex/Pasted image 20240202180634.png]]
汇编语言 BL 这条指令会把下一条指令（main 函数的返回地址保存在 LR 寄存器中）
![[../../../annex/Pasted image 20240202180745.png]]

函数 b 的返回地址是 c_fun，调用函数 b 的时候会先把地址赋给 LR 寄存器，然后去执行函数 b。
在函数 b 的开头会分配 P 字节的空间，且把 LR 寄存器的值保存在栈里面。这个 LR 就指向函数 b 的返回地址（c_fun）。
当函数 b 执行完之后，会从栈中把 LR 的值取出来，则返回 c_fun，准备执行 c 函数。

同理，当函数 a 执行完后，指向到 return 即执行完工作。返回到哪里？从自己的栈中把 LR 的值（return 0）取出来，跳过去执行

从这个过程中，我们可以看到栈在保存返回地址时是怎么起作用的。
![[../../../annex/Pasted image 20240202182346.png]]

再看局部变量 a 是怎么起作用的。
执行到 a=8 时，局部变量的内存的值就变为 8。
执行到 a=a+value 时，又让这块局部变量内存只等于 8+value。

![[../../../annex/Pasted image 20240202183932.png]]



弹幕：L 人寄存器记录下一条语句的地址，执行完当前 fun 后，程序回到该栈的 LR 地址继续执行
弹幕：可以理解为函数执行完的下一条语句
弹幕：相当于把栈拆借给每个函数了

为什么是减呢？这个不是相当于吧 SP 当基地址，然后每次执行函数的时候，就是在分配内存空间来储存对函数的局部变量吗？
栈是向下生长的
和硬件强相关的，arm 架构的栈是向下生长的，所以是减。


弹幕：学过汇编的都知道，压入堆栈再跳转
弹幕：地址入栈，断点保护


每个任务都要有栈，所谓的任务其实就是个函数。Tast_A 中会调用 a、b、c... 返回地址保存在 task_A 的栈空间中。
同理，另一个任务 task_B 也是如此。而任务之间的栈互相独立的，不能是同一个。所以说，每个任务都有自己的栈。
后面我们可以知道，创建一个任务，必须要给这个任务单独分配栈。


### 第二章-内存管理
![[../../../annex/Pasted image 20240202170841.png]]

![[../../../annex/Pasted image 20240202170921.png]]


























































































































