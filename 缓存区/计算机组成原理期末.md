填空题 30 分
选择题 20 分
... 10 分
（一位乘）计算题 10 分
简答题 10 分
汉明码 10 分
指令拓展 10 分

[(15条消息) 计算机组成原理（第3版）唐朔飞著 知识点总结 期末复习笔记 【索引】_唐朔飞第三版电子版pdf_m0_45917886的博客-CSDN博客](https://blog.csdn.net/m0_45917886/article/details/121774098)

[(15条消息) 计算机组成原理（第三版）唐朔飞-课后习题（完整版）_计算机组成原理唐朔飞第三版答案_蓝净云的博客-CSDN博客](https://blog.csdn.net/weixin_45735391/article/details/127336659)

补码、带宽、存储器、CPU 功能、海明码纠错、指令周期

# 沈
### 第一章课后习题P 19
1.7 解释概念: 主机、CPU、主存、存储单元、<font color="#ff0000">存储元件、存储基元、存储元</font>、存储字、存储字长、存储容量、机器字长、指令字长。
答：
<font color="#ff0000">主机</font>: 是计算机硬件的<font color="#ff0000">主体部分</font>，由 <font color="#ff0000">CPU </font>和<font color="#ff0000">主存储器</font> MM<font color="#ff0000"> 合成</font>为主机。
<font color="#ff0000">CPU: 中央处理器，是计算机硬件的核心部件</font>，由<font color="#ff0000">运算器和控制器组成</font>;(早期的运算器和控制器不在同一芯片上，现在的 CPU 内除含有<font color="#ff0000">运算器和控制器</font>外还<font color="#ff0000">集成了 CACHE</font>)。
<font color="#ff0000">主存</font>: 计算机中<font color="#ff0000">存放正在运行的程序和数据的存储器</font>，为计算机的<font color="#ff0000">主要工作存储器</font>，可随机存取; 由存储体、各种逻辑部件及控制电路组成。
<font color="#ff0000">存储单元</font>: <font color="#ff0000">可存放一个机器字并具有特定存储地址的存储单位</font>。
<font color="#ff0000">存储元件</font>: 存储一位二进制信息的<font color="#ff0000">物理元件</font>，是存储器中<font color="#ff0000">最小的存储单位</font>，又叫<font color="#ff0000">存储基元</font>或<font color="#ff0000">存储元</font>，不能单独存取。
<font color="#ff0000">存储字</font>: 一个存储单元所存二进制代码的<font color="#ff0000">逻辑单位</font>。
<font color="#ff0000">存储字长</font>: 一个存储单元所存二进制代码的<font color="#ff0000">位数</font>。
<font color="#ff0000">存储容量</font>: 存储器中可存二进制代码的<font color="#ff0000">总量</font>;(通常<font color="#ff0000">主、辅存容量分开描述</font>)。
<font color="#ff0000">机器字长</font>: 指 <font color="#ff0000">CPU 一次能处理的</font>二进制数据的<font color="#ff0000">位数</font>，通常<font color="#ff0000">与 CPU 的寄存器位数有关</font>。
<font color="#ff0000">指令字长</font>: <font color="#ff0000">一条指令</font>的二进制代码<font color="#ff0000">位数</font>。

1.8 解释英文代号: CPU、PC、IR、CU、ALU、ACC、MQ、X、MAR、MDR、I/O、MIPS、CPI、FLOPS。
答：
<font color="#ff0000">CPU</font>: Central Processing Unit，<font color="#ff0000">中央处理机 (器)</font>，是计算机硬件的<font color="#ff0000">核心部件</font>，<font color="#ff0000">主要由运算器和控制器</font>组成。
<font color="#ff0000">PC</font>: Program Counter，<font color="#ff0000">程序计数器</font>，其功能是<font color="#ff0000">存放当前欲执行指令的地址</font>，并可<font color="#ff0000">自动计数形成下一条指令地址</font>。
<font color="#ff0000">IR</font>: InstructionRegister，<font color="#ff0000">指令寄存器</font>，其功能是<font color="#ff0000">存放当前正在执行的指令</font>。
<font color="#ff0000">CU</font>: Control Unit，<font color="#ff0000">控制单元 (部件)</font>，为<font color="#ff0000">控制器的核心部件</font>，其功能是<font color="#ff0000">产生微操作命令序列</font>。
<font color="#ff0000">ALU:</font> Arithmetic Loqic Unit，<font color="#ff0000">算术逻辑运算单元</font>，为<font color="#ff0000">运算器的核心部件</font>，其功能是进行<font color="#ff0000">算术、逻辑运算</font>。
<font color="#ff0000">ACC</font>: Accumulator，<font color="#ff0000">累加器</font>，是<font color="#ff0000">运算器中既能存放运算前的操作数</font>，又能<font color="#ff0000">存放运算结果的寄存器</font>
<font color="#ff0000">MQ</font>: Multiplier-Quotient Reqister，<font color="#ff0000">乘商寄存器</font>，<font color="#ff0000">乘法运算时存放乘数、除法时存放商的寄存器</font>。
<font color="#ff0000">X</font>: 此字母没有专指的缩写含义，可以用作任一部件名，在此表示<font color="#ff0000">操作数寄存器</font>，即<font color="#ff0000">运算器中工作寄存器之一，用来存放操作数</font>;
<font color="#ff0000">MAR</font>: Memorv Address Reaister，<font color="#ff0000">存储器地址寄存器</font>，在<font color="#ff0000">主存中用来存放欲访问的存储单元的地址</font>。
<font color="#ff0000">MDR</font>: Memory Data Reqister，<font color="#ff0000">存储器数据缓冲寄存器</font>，在<font color="#ff0000">主存中用来存放从某单元读出、或要写入某存储单元的数据</font>。
<font color="#ff0000">I/O</font>: Input/Output equipment，<font color="#ff0000">输入/输出设备</font>，为输入设备和输出设备的总称，<font color="#ff0000">用于计算机内部和外界信息的转换与传送</font>。
<font color="#ff0000">MIPS</font>: Million Instruction Per Second，<font color="#ff0000">每秒执行百万条指令数</font>，为<font color="#ff0000">计算机运算速度指标</font>的一种<font color="#ff0000">计量单位</font>。
<font color="#ff0000">CPI 和 FLOPS 通常用来衡量运算速度</font>。

1.11 指令和数据都存于存储器中, 计算机如何区分它们?
解: 计算机区分指令和数据有以下 2 种方法
通过<font color="#ff0000">不同的时间段</font>来区分指令和数据，即在<font color="#ff0000">取指令阶段</font> (或取指微程序)取出的为<font color="#ff0000">指令</font>，在<font color="#ff0000">执行指令阶段 </font>(或相应微程序)取出的即为<font color="#ff0000">数据</font>。
通过<font color="#ff0000">地址来源</font>区分，由 <font color="#ff0000">PC</font> 提供存储单元地址的取出的是<font color="#ff0000">指令</font>，由<font color="#ff0000">指令地址码</font>部分提供存储单元地址的取出的是<font color="#ff0000">操作数</font>。
————————————————
版权声明：本文为 CSDN 博主「蓝净云」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接： https://blog.csdn.net/weixin_45735391/article/details/127212635
### 3.3.2 总线性能指标  P46
1. <font color="#ff0000">总线宽度</font>：通常是指<font color="#ff0000">数据总线的根数</font>，用<font color="#ff0000"> bit（位）</font>表示，如 8 位、16 位、32 位、64 位（即 8 根、16 根、32 根、64 根）。
2. <font color="#ff0000">总线宽度</font>：总线宽度可理解为总线的<font color="#ff0000">数据传输速率</font>，即<font color="#ff0000">单位时间内总线上传输数据的位数</font>，通常用<font color="#ff0000">每秒传输信息的字节数</font>来衡量，单位可用<font color="#ff0000"> MBps（兆字节每秒）</font>表示。例如，总线工作频率为 33 MHz，总线宽度为 32 位（4 B），则总线带宽为 33 X（32÷8）=132 MBps。<font color="#ff0000">频率 X 宽度</font>。
3. ![[f6fbb8681d877a7cfe38d33cb95add8.jpg]]

### 第三章课后习题 P 66
3.1 什么是总线? 总线传输有何特点? 为了减轻总线的负载, 总线上的部件都应具备什么特点？
答：
① 总线是<font color="#ff0000">连接多个部件的信息传输线, 是个部件共享的传输介质</font>。
② 总线传输特点: 在某一时刻, <font color="#ff0000">只允许有<u>一个</u>部件向总线<u>发送</u>信息</font>, 而<font color="#ff0000"><u>多个</u>部件可以同时从总线上<u>接受</u>相同的信息</font>。
③ 为<font color="#ff0000">减轻</font>总线上的<font color="#ff0000">负载</font>, 各种 I/O 设备要通过<font color="#ff0000"> I/O 接口</font>接在总线上, 而且还要通过<font color="#ff0000">三态门</font>挂在总线上, 没有数据交换时置成<font color="#ff0000">高阻态</font>。

√3.2 总线如何分类? 什么是系统总线? 系统总线又分为几类, 它们各有何作用, 是单向的, 还是双向的, 它们与机器字长、存储字长、存储单元有何关系?
答：
按照<font color="#ff0000">连接部件的不同</font>, 总线可以分为<font color="#ff0000">片内总线、系统总线和通信总线</font>。
<font color="#ff0000">系统总线</font>: 是<font color="#ff0000">连接 CPU、主存、 I/O 各部件之间的信息传输线</font>。
系统总线按照<font color="#ff0000">传输信息不同又分为地址线、数据线和控制线</font>。
<font color="#ff0000">地址线是单向的</font>, 其<font color="#ff0000">根数越多, 寻址空间越大</font>, <font color="#ff0000">即 CPU 能访问的存储单元的个数越多</font>;
<font color="#ff0000">数据线是双向的</font>,<font color="#ff0000"> 其根数与存储字长相同</font>, 是<font color="#ff0000">机器字长的整数倍</font>。
<font color="#ff0000">控制总线是双向的</font>。
### 第四章课后习题 P 150、P 151
###### 4 .5 什么是存储器的带宽? 若存储器的数据总线宽度为 32 位，存取周期为 200 ns，则存储器的带宽是多少?
答：
存储器的带宽指<font color="#ff0000">单位时间内从存储器进出信息的最大数量</font>。
存储器带宽= 1/200 ns ×32 位 = 160 M 位/秒 = 20 MB/秒 = 5 M 字/秒
注意 : 字长 32 位, 不是 16 位。(注: 1 n s = 1 0 − 9 s 1 ns=10^{-9} s 1 ns=10 
−9
 S)

###### 4 .6 机器字长为 32 位, 存储容量是 64 KB，按字编址其寻址范围是多少? 若主存以字节编址, 试画出主存字地址和字节地址的分配情况。
答：
存储容量是 64 KB 时, 按字节编址的寻址范围就是 64 K ,
如按字编址, 其寻址范围为: （先将容量 KB 转换成 b（bit）再除以机器字长）
```
64 KB/32 位=(64 * 1024* 8)/32=16*1024=16 K
```
16 K=2<sup>4</sup>，所以以 <font color="#ff0000">4 个字节划为 1 个字地址</font>
主存字地址和字节地址的分配情况: 如图
![[Pasted image 20230611224547.png]]
###### 4 .7 一个容量为 16 K×32 位的存储器, 其地址线和数据线的总和是多少? 当选用下列不同规格的存储芯片时, 各需要多少片? 1 K×4 位, 2 K×8 位, 4 K×4 位, 16 K×1 位, 4 K×8 位, 8 K×8 位
答：
地址线：16 KB=16 X 1024=14根——（将容量转换成二进制，二进制的指数为多少即地址线有几根）
数据线：32 根（位）——(即机器字长的位数)
地址线和数据线的总和 = 14 + 32 = 46 根;
选择不同的芯片时, 各需要的片数为:
（<font color="#ff0000">直接相除</font>，存储容量÷存储容量，机器字长÷机器字长）
1 K×4: (16 K×32) / (1 K×4) = 16 ×8 = 128 片
2 K×8: (16 K×32) / (2 K×8) = 8 ×4 = 32 片
4 K×4: (16 K×32) / (4 K×4) = 4 ×8 = 32 片
16 K×1: (16 K×32)/ (16 K×1) = 1 ×32 = 32 片
4 K×8: (16 K×32)/ (4 K×8) = 4 ×4 = 16 片
8 K×8: (16 K×32) / (8 K×8) = 2 ×4 = 8 片

###### 4 .8 试比较静态 RAM 和动态 RAM。
答：静态 RAM=SRAM，动态 RAM=DRAM。
静态 RAM 是靠双稳态<font color="#ff0000">触发器</font>来记忆信息的；动态 RAM 是靠 MOS 电路中的栅极<font color="#ff0000">电容</font>来记忆信息的。
由于<font color="#ff0000">电容上的电荷会泄漏，需要定时给与补充</font>，所以动态 RAM 需要设置<font color="#ff0000">刷新电路</font>。但动态 RAM 比静态 RAM <font color="#ff0000">集成度高、功耗低</font>，从而<font color="#ff0000">成本也低</font>，适于作<font color="#ff0000">大容量存储器</font>。所以<font color="#ff0000">主内存</font>通常采用动态 RAM，而<font color="#ff0000">高速缓冲存储器（Cache）</font>则使用静态 RAM。另外，内存还应用于显卡、声卡及 CMOS 等设备中，用于<font color="#ff0000">充当设备缓存或保存固定的程序及数据</font>。

解析：静态 RAM 的特点：是<font color="#ff0000">在不断电的条件下，其中的信息保持不变</font>，因而<font color="#ff0000">不必定期刷新</font>，<font color="#ff0000">其中的信息可读可写</font>，但<font color="#ff0000">断电后信息就会丢失</font>。
1、静态 RAM 用<font color="#ff0000">触发器</font>作为存储单元存放 1 和 0，<font color="#ff0000">存取速度快</font>，只要不掉电即可<font color="#ff0000">持续保持内容不变</font>。
2、，静态 RAM 的<font color="#ff0000">集成度较低</font>，并且静态 RAM <font color="#ff0000">无须考虑保持数据而设置的刷新电路</font>，故<font color="#ff0000">扩展电路较简单</font>。
动态 RAM：是绝大多数现代台式计算机的<font color="#ff0000">标准计算机内存</font>，它是一种<font color="#ff0000">易失性存储器</font>，需要<font color="#ff0000">用电压定期刷新</font>，否则，它会<font color="#ff0000">丢失存储</font>在上面的<font color="#ff0000">信息</font>。

![[Pasted image 20230611224611.png]]
###### 4 .9 什么叫刷新? 为什么要刷新? 说明刷新有几种方法。
答：
<font color="#ff0000">刷新: 对 （动态存储器）DRAM 定期进行的全部重写过程</font>;
<font color="#ff0000">刷新原因</font>: 因<font color="#ff0000">电容泄漏</font>而引起的 <font color="#ff0000">DRAM 所存信息的衰减</font> <font color="#ff0000">需要及时补充</font>, 因此安排了<font color="#ff0000">定期刷新操作</font>;
常用的刷新方法有三种: <font color="#ff0000">集中式、分散式、异步式</font>。
集中式: 在<font color="#ff0000"><u>最大刷新间隔时间内</u>, <u>集中</u>安排<u>一段时间</u>进行刷新, 存在 CPU 访存<u>死时间</u></font>。
分散式: 在<font color="#ff0000"><u>每个读 /写周期之后</u><u>插入一个刷新周期</u>, <u>无</u> CPU 访存<u>死时间</u></font>。
异步式: 是<font color="#ff0000">集中式和分散式的折衷</font>。

校验位 k（C1、C2、C4），2<sup>k</sup>≥n+k+1，汉明码共 n+k 位。
求汉明码即先求 C1, C2,C4，后加上已知的有效信息
求纠错码即求 P1,P2,P4（加上 C1, C2,C4），出错位数位 P1,P2,P4 的值
汉明码=有效信息（b1 、b2、 b3、 b4）+校验码（C1 、C2、 C4）
即：汉明码=C1 +C2 +b3 +C4 +b2 +b1
（奇数个 1 异或结果为 1，偶数个 1 异或为 0）
![[Pasted image 20230611224740.png]]

纠错异或需要加上 C1, C2，C4，而求汉明码异或不需要写 C，只需要写 b
求纠错码即求 P1,P2,P4（加上 C1, C2,C4），出错位数位 P1,P2,P4 的值
修正有效信息为出错位置的值取反（0 变 1，1 变 0）后的有效信息 b1、b2、b3、b4
![[Pasted image 20230611224747.png]]

求出 P 1 、P 2 、P 4→出错位置→取反→纠正汉明码→纠正的欲传送信息
欲传送的代码即为修正后的有效信息 b1 、b2、 b3、 b4
奇性配置和偶性配置，异或：相同为 0，不同为 1
奇性配置即 P 1、P 2、P 4 的异或取反（上面一条横线）
偶性配置即 P 1、P 2、P 4 的正常异或
![[Pasted image 20230611224820.png]]
![[Pasted image 20230611224827.png]]
![[Pasted image 20230611224837.png]]
![[Pasted image 20230611224843.png]]



### 6 .3.1 移位运算 P 234
![[52479416bd5b9d1ce939ce47eaec04a.jpg]]





### 补码一位乘 P 251
y*、x*，为 y，x 的绝对值
![[Pasted image 20230612103125.png]]
![[Pasted image 20230612102944.png]]
![[Pasted image 20230612102953.png]]
![[Pasted image 20230612102959.png]]
**所以布斯算法的算法过程为n+1次的”判断→加减→右移“的循环，右移的次数为n次。**


### 第六章课后习题 P 290、P 291
![[Pasted image 20230611225407.png]]
![[Pasted image 20230611225414.png]]

![[Pasted image 20230618175443.png]]

![[Pasted image 20230618180049.png]]

![[Pasted image 20230618180239.png]]


![[Pasted image 20230611225443.png]]
![[Pasted image 20230611225452.png]]
![[Pasted image 20230611225501.png]]

![[Pasted image 20230611225220.png]]
![[Pasted image 20230611225238.png]]
![[Pasted image 20230611225246.png]]






### 第七章课后习题 7.1， P 334
1. 什么叫机器指令？什么叫指令系统？为什么说指令系统与机器的主要功能以及硬件结构之间存在着密切的关系？
答：
机器语言是由一条条语句构成的，每一条语句又能准确表达某种语义。人们习惯<font color="#ff0000">把每一条机器语言的语句称为机器指令</font>，而<font color="#ff0000">将全部机器指令的集合称为机器的指令系统</font>。计算机就是<font color="#ff0000">连续执行每一条机器语句而实现全自动工作的</font>。
计算机设计者主要研究如何确定机器的指令系统，如何用硬件电路、芯片、设备来实现机器指令系统的功能。计算机的使用者则是依据机器提供的指令系统，使用汇编语言来编制各种程序。计算机使用者根据机器指令系统所描述的机器功能，能很清楚地了解计算机内部寄存器-存储器的内部结构，以及计算机能直接支持的各种数据类型，所以说指令系统与机器的主要功能以及硬件结构之间存在着密切的关系。
![[Pasted image 20230611225619.png]]



### 第八章课后习题 P 370
CPU 包含<font color="#ff0000">运算器和控制器</font>两大部分。第八章重点讲控制器。
控制器是专门完成程序进入存储器后，计算机自动完成取指令和执行指令的任务。
<font color="#ff0000">控制器的基本功能是取指令、分析指令和执行指令。</font>
CPU 必须具有控制程序的顺序执行（称<font color="#ff0000">指令控制</font>）、产生完成每条指令所需的控制命令（称<font color="#ff0000">操作控制</font>）、对各种操作加以时间上的控制（称<font color="#ff0000">时间控制</font>）、对数据进行算术运算和逻辑运算（<font color="#ff0000">数据加工</font>）以及<font color="#ff0000">处理中断</font>等功能。（20 个红字）
![[Pasted image 20230611225717.png]]
##### 8.2.1 指令周期的基本概念
指令周期的含义：<font color="#ff0000">CPU 每取出并执行一条指令所需的全部时间称为指令周期，也即 CPU 完成一条指令的时间</font>。
取指阶段<font color="#ff0000">完成取指令和分析指令的操作</font>又称取指周期。
执行阶段<font color="#ff0000">完成执行指令的操作</font>又称执行周期。
![[Pasted image 20230611225729.png]]
##### 8.2.2 指令周期的数据流
1. 取指周期的数据流
2. 间址周期的数据流
3. <font color="#ff0000">执行周期</font>的数据流
4. <font color="#ff0000">中断周期</font>的数据流
5. 下一个指令周期为<font color="#ff0000">取指周期</font>

中断周期 CPU 要完成的操作：
（1）CPU 的<font color="#ff0000">访存操作</font>。
（2）<font color="#ff0000">保护程序断点</font>。
（3）<font color="#ff0000">寻找中断服务程序的入口地址</font>。
（4）硬件完成<font color="#ff0000">关中断</font>。
（5）将<font color="#ff0000">向量地址</font>送<font color="#ff0000">程序计数器</font>（<font color="#ff0000">硬件向量法</font>），或将<font color="#ff0000">中断识别程序入口地址</font>送<font color="#ff0000">程序计数器</font>（<font color="#ff0000">软件查询法</font>）。
![[Pasted image 20230611225739.png]]



# 补充

数据传输。串行、并行两类。地址..... 三类
### 比特率和波特率 
![[Pasted image 20230612121255.png]]
![[Pasted image 20230612121303.png]]
![[Pasted image 20230612121311.png]]

### 3.3.1 片内总线 P 43
片内总线是指<font color="#ff0000">芯片内部的总线</font>，如在 CPU 芯片内部，寄存器与寄存器之间、寄存器与算术逻辑单元 ALU 之间都由片内总线连接。
### 3.2.2 系统总线 P 43
系统总线是指 CPU、主存、I/O 设备（通过 I/O 接口）<font color="#ff0000">各大部件之间的信息传输线</font>。由于这些部件通常都安放在主板或各个插件板（插卡）上，故又称<font color="#ff0000">板级总线</font>（在一块短路板上各芯片间的连线）或<font color="#ff0000">板间总线</font>。

##### 1. 数据总线
数据总线<font color="#ff0000">用来传输各功能部件之间的数据信息</font>，它是<font color="#ff0000">双向传输总线</font>，<font color="#ff0000">其位数与机器字长、存储字长有关</font>，一般为 8 位、16 位或 32 位。<font color="#ff0000">数据总线的位数称为数据总线宽度，</font>它是<font color="#ff0000">衡量系统性能的一个重要参数</font>。如果数据总线的宽度位 8 位，指令字长位 16 位，那么，CPU 在取指阶段必须两次访问主存。
##### 2. 地址总线
地址总线主要<font color="#ff0000">用来指出数据总线上的源数据或目的数据在主存单元的地址或 I/O 设备的地址</font>。例如，欲从存储器读出一个数据，则 CPU 要将此数据所在的存储单元的地址送到地址线上。又如，欲将某数据经 I/O 设备输出，则 CPU 除了需将数据送到数据总线外，还需将该输出设备的地址（经常都经 I/O 接口）送到地址总线上。可见，<font color="#ff0000">地址总线上的代码是用来指明 CPU 欲访问的存储单元或 I/O 端口的地址</font>，由 CPU 输出，单向传输。<font color="#ff0000">地址数的位数与存储单元的个数有关</font>，如地址线为 20 根，则对应的存储单元个数为 2<sup>20</sup>
##### 3. 控制总线
由于数据总线、地址总线都是被挂在总线上的所有部件共享的，<font color="#ff0000">如何使各部件能在不同时刻占有总线使用权</font>，需要依靠控制总线来完成，因此控制总线是用来发出各种控制信号的传输线。通常对任一控制线而言，它的<font color="#ff0000">传输是单向的</font>。例如，存储器读/写命令或 I/O 设备读/写命令都是由 CPU 发出的。但对于<font color="#ff0000">控制总线总体来说，又可认为是双向的</font>。例如，当某设备准备就绪时，便向 CPU 发中断请求。此外，控制总线还<font color="#ff0000">起到监视各部件状态的作用</font>。例如，查询该设备是处于"忙"还是“闲”，是否出错等。因此对于 CPU 而言，控制信号既有输出，又有输入。
![[77d9be6ff426da5d01b1fb399dfb559.jpg]]

### 3 .2.3 通信总线 P 44
##### 串行通信
<font color="#ff0000">串行通信</font>是指数据在<font color="#ff0000">单条 1 位宽的传输线上，一位一位地按顺序分时传送</font>。
如 1 字节的数据，在串行传送中，1 字节的数据要通过一条传输线分 8 次由低位到高位按顺序逐位传送。
##### 并行通信
<font color="#ff0000">并行通信</font>是指数据在<font color="#ff0000">多条并行 1 位宽的传输线上，同时由源传送到目的地</font>。如 1 字节的数据，在并行传送中，要<font color="#ff0000">通过 8 条并行传输线同时由源传送到目的地</font>。
<font color="#ff0000">并行通信</font>适用于<font color="#ff0000">近距离</font>的数据传输，<font color="#ff0000">通常小于 30m</font>，<font color="#ff0000">串行通信</font>适用于<font color="#ff0000">远距离传送</font>，可以从<font color="#ff0000">几米到数千千米</font>。而且，串行和并行通信的<font color="#ff0000">数据传送速率</font>都<font color="#ff0000">与距离</font>成<font color="#ff0000">反比</font>。在<font color="#ff0000">短距离</font>内，<font color="#ff0000">并行</font>数据传送速率比串行数据传送<font color="#ff0000">速率高</font>得多。随着大规模和超大规模集成电路的发展，逻辑器件的价格趋低，而通信线路费用趋高，因此对<font color="#ff0000">远距离</font>通信而言，采用<font color="#ff0000">串行</font>通信费用远比并行通信<font color="#ff0000">费用低</font>得多。此外串行通信还可利用现有的电话网络来实现远程通信，降低了通信费用。
![[a3d8201bcb2d1f8c30bd52532ae851e.jpg]]
地址总线 1 KB=2 <sup>10</sup> X 8、数据 64 位（MAX）、控制


### 3.4 总线结构 P 52
总线结构通常可分为<font color="#ff0000">单总线结构</font>和<font color="#ff0000">多总线结构</font>两种。
#### 3.4.1 单总线结构
![[979ec4c291d50096d4d3ab151765e87.jpg]]
#### 3.4.2 多总线结构
![[8d67543d84ec9466b32320fdfe78aba.jpg]]
![[cbde111d3aa7a9def9258e2aec406bb.jpg]]
![[eaa5de86e40c31e26b72801611912f5.jpg]]


### 3.5 总线控制 P 57
总线控制主要包括<font color="#ff0000">判优控制（或称仲裁逻辑）和通信控制</font>。
#### 3.5.1 总线判优控制
总线判优控制可分<font color="#ff0000">集中式和分布式</font>两种，前者将<font color="#ff0000">控制逻辑集中在一处</font>（如在 CPU 中），后者将<font color="#ff0000">控制逻辑分散在与总线连接的各个部件或设备上</font>。
（1）链式查询
（2）计数器定时查询
（3）独立请求方式
![[5a182c7afbe29797346c5d9ab056940.jpg]]
![[f69df8da4ba34fbe6d6e830d9bb740e.jpg]]
![[2168757efb415f34f78cf3dceec51e9.jpg]]

#### 3.5.2 总线通信控制
完成一次总线操作的时间称为总线周期，可分为以下 4 个阶段：
（1）<font color="#ff0000">申请分配阶段</font>：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定下一传输周期的总线使用权授予某一申请者。
（2）<font color="#ff0000">寻址阶段</font>：取得了使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块。
（3）<font color="#ff0000">传数阶段</font>：主模块和从模块进行数据交换，数据由源模块发出，经数据总线流入目的模块。
（4）<font color="#ff0000">结束阶段</font>：主模块的有关信息均从系统总线上被撤除，让出总线使用权。

总线通信控制通常用的四种方式：<font color="#ff0000">同步通信、异步通信、半同步通信和分离式通信</font>。
1. 同步通信
	1. <font color="#ff0000">通信双方由统一时标控制数据传送</font>称为同步通信。时标通常由 CPU 的总线控制器件发出，送到总线上的所有部件；也可以由每个部件各自的时许发生器发出，但必须由总线控制部件发出的时钟信号对它们进行同步。
	2. 该通信的优点是规定明确、统一，模块间的配合简单一致。
	3. 其缺点是主、从模块时间配合属于强制性“同步”，必须在限定时间内完成规定的要求。
2. 异步通信
	1. 异步通信克服了同步通信的缺点，允许各模块速度的不一致性。
	2. 异步通信的应答方式又可分为<font color="#ff0000">不互锁、半互锁和全互锁</font>三种类型。
	3. 异步通信可用于并行传送或串行传送。
		1. 异步串行通信时，没有同步时钟，也不需要在数据传送中传送同步信号。
	4. 异步串行通信的数据传送速率<font color="#ff0000">用波特率来衡量</font>。
	5. <font color="#ff0000">波特率是指单位时间内传送二进制数据的位数，单位用 bps（位/秒）表示，记作波特。</font>
	6. 由于异步串行通信字符格式中包含若干附加位，如起始位、终止位、校验位，而且终止位又有 1 位、1.5 位、2 位之分，若<font color="#ff0000">只考虑有效数据位，可用比特率来衡量异步串行通信的数据传输率，即单位时间内传送二进制有效数据的位数，单位用 bps 表示</font>。
	7. （1）不互锁方式（主、从模块都无互锁关系）
		1. 主模块发出请求信号后，不必等待接到从模块的回答信号，而是经过一段时间，确定从模块已经收到请求信号后，便撤销其请求信号；
		2. 从模块街道请求信号后，在条件允许时发出回答信号，并经过一段时间（这段时间的设置对不同设备而言是不同的）确定主模块已收到回答信号后，自动撤销回答信号。
		3. 可见通信双方并无互锁关系。例如，CPU 向主存写信息，CPU 要先后给出地址信号、写命令以及写入数据，即采用此种方式。
	8. （2）半互锁方式（主模块有互锁，从模块无互锁）
		1. 主模块发出请求信号，必须待接到从模块的回答信号后再撤销其请求信号，有互锁关系；
		2. 而从模块在接到请求信号后发出回答信号，但不必等待获知主模块的请求信号已经撤销，而是隔一段时间后自动撤销其回答信号，无互锁关系。
		3. 由于一方存在互锁关系，一方不存在互锁关系，故称半互锁方式。
	9. （3）全互锁方式（主、从模块都存在互锁关系）
		1. 主模块发出请求信号，必须待从模块回答后再撤销其请求信号；
		2. 从模块发出回答信号，必须待获知主模块请求信号已撤销后，再撤销其会打信号。
		3. 双方存在互锁关系，故称全互锁方式。例如，在网络通信中，通信双方采用的就是全互锁方式。
3. 半同步通信
	1. 半同步通信既保留了同步通信的基本特点，如所有的地址、命令、数据信号的发出时间，都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别；同时又像异步通信那样，允许不同速度的模块和谐地工作。
	2. 半同步通信适用于<font color="#ff0000">系统工作速度不高但又包含了由许多工作速度差异较大</font>的各类设备组成的简单系统。半同步通信控制方式比异步通信简单。
	3. 其缺点是对系统时钟频率不能要求太高，故从整体来看，系统工作的速度还是不能太高
4. 分离式通信
	1. 以上三种通信方式都是从主模块发在地址和读写命令开始，直到数据传输结束。在整个周期中，系统总线的使用权完全由占有使用权的主模块和由它选中的从模块占据。进一步分析读命令传输周期，出现除了申请总线这一阶段外，其余时间主要花费在如何 3 个方面。
	2. （1）主模块通过传输总线向从模块发现地址和命令
	3. （2）从模块按照命令进行读数据的必要准备
	4. （3）从模块经数据总线向主模块提供数据。
	5. <font color="#ff0000">分离式的通信方式的基本思想是：将一个传输周期（或总线周期）分解为两个子周期。两个传输子周期都只有单方向的信息流，每个模块都变成了主模块</font>。
	6. 特点：
		1. 各模块欲占用总线使用权都必须提出申请。
		2. 在得到总线使用权后，主模块在限定时间内向对方传送信息，采用同步方式传送，等待对方的回答信号。
		3. 各模块在准备数据的过程中都不占用总线，使总线可接受其他模块的请求。
		4. 总线被占用时都在做有效工作，充分地利用了总线的有效占用。
![[88e1337caa975039b2c6868577aad26.jpg]]
![[814c227791723f6355e1351424d2d75.jpg]]
![[f57793f26008ddf50e31acc228710e7.jpg]]

### 习题3.5-3.16 P 66 
##### 课后习题3 .5
3.5 解释概念: 总线宽度、总线带宽、总线复用、总线的主设备 (或主模块)、总线的从设备 (或从模块)、总线的传输周期、总线的通信控制。
答：
总线宽度: 通常指数据总线的根数;
总线带宽: 总线的数据传输率, 指单位时间内总线上传输数据的位数;
总线复用: 指<font color="#ff0000">同一条信号线可以分时传输不同的信号</font>。
总线的主设备 (主模块): 指<font color="#ff0000">一次总线传输期间, 拥有总线控制权的设备 (模块)</font>;
总线的从设备 (从模块) :指<font color="#ff0000">一次总线传输期间,配合主设备完成数据传输的设备 (模块), 它只能被动接受主设备发来的命令</font>;
总线的传输周期: 指<font color="#ff0000">总线完成一次完整而可靠的传输所需时间</font>;
总线的通信控制: 指<font color="#ff0000">总线传送过程中双方的时间配合方式</font>。

##### 课后习题 3.6
3.6 试比较同步通信和异步通信。
答：
同步通信：指由<font color="#ff0000">统一时钟控制的通信</font>，控制方式简单，灵活性差，当系统中各部件工作速度差异较大时，总线工作效率明显下降。适合于速度差别不大的场合。
异步通信：指<font color="#ff0000">没有统一时钟控制的通信</font>，部件间采用<font color="#ff0000">应答方式</font>进行联系，控制方式较同步复杂，灵活性高，当系统中各部件工作速度差异较大时，有利于提高总线工作效率。

##### 课后习题 3.7
3.7 画图说明异步通信中请求与回答有哪几种互锁关系。

答：  
异步通信的应答方式可分为不互锁、半互锁和全互锁三种，如下图。
![[Pasted image 20230612120905.png]]

##### 课后习题3.8
3.8 为什么说半同步通信同时保留了同步通信和异步通信的特点?
答：
半同步通信既保留了同步通信的基本特点，比如所有的地址、命令、数据信号的发出时间，都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别；同时又像异步通信那样，允许不同速度的模块和谐地工作。为此增设了一条“等待”（WAIT）响应信号线。采用插入时钟（等待）周期的措施来协调通信双方的配合问题。半同步通信<font color="#ff0000">适用于系统工作速度不高但又包含了由许多工作速度差异较大的各类设备组成的简单系统</font>，0
半同步通信控制方式比异步通信简单，在全系统内各模块又在统一的系统时钟控制下同步工作，可靠性较高，同步结构较方便。其缺点是对系统时钟频率不能要求太高，故从整体上来看，系统工作的速度还不是很高。
所以半同步通信既能像同步通信那样<font color="#ff0000">由统一时钟控制</font>，又能像异步通信那样<font color="#ff0000">允许传输时间不一致</font>，因此<font color="#ff0000">工作效率介于两者之间</font>。

##### 课后习题3.13
3.13什么是总线的数据传送速率,它与哪些因素有关?

答：  
总线的数据传输速率即<font color="#ff0000">总线带宽</font>,指<font color="#ff0000">单位时间内总线上传输数据的位数</font>,通常用每秒传输信息的字节数来衡量。  
它与总线宽度和总线频率有关,总线宽度越宽,频率越快,数据传输率越高。

##### 课后习题3.14
3.14 设总线的时钟频率为 8 MHz, 一个总线周期等于一个时钟周期。如果一个总线周期中并行传送 16 位数据, 试问总线的带宽是多少?
答：
由于:f=8 MHz, T=1/f=1/8 M 秒, 一个总线周期即是一个时钟周期
所以: 总线带宽=16/(1/8 M) = 128 Mbps

##### 课后习题 3.15
3.15 在一个 32 位的总线系统中，总线的时钟频率为 66 MHz, 假设总线最短传输周期为 4 个时钟周期, 试计算总线的最大数据传输率。若想提高数据传输率, 可采取什么措施?
答：
总线传输周期 =4 X1/66 M 秒
总线的最大数据传输率 =32/(4/66 M)=528 Mbps
若想提高数据传输率, 可以提高总线时钟频率、增大总线宽度或者减少总线传输周期包含的时钟周期个数。

##### 课后习题 3.16
3.16 在异步串行传送系统中, 字符格式为: 1 个起始位、8 个数据位、1 个校验位、2 个终止位。若要求每秒传送 120 个字符, 试求传送的波特率和比特率。
答：
一帧包含: 1+8+1+2=12 位
故波特率为: (1+8+1+2) X120=1440 bps
比特率为: 8 X120=960 bps


### 4.1.2 存储器的层次结构 P 70
存储器有 3 个主要性能指标：<font color="#ff0000">速度、容量</font>和每位价格（简称<font color="#ff0000">位价</font>）
存储系统层次结构主要体现在<font color="#ff0000">缓存-主存和主存-辅存</font>两个存储层次
<font color="#ff0000">缓存-主存</font>层次主要解决 CPU 和主存<font color="#ff0000">速度不匹配</font>的问题。即<font color="#ff0000">提高运行速度</font>。
<font color="#ff0000">主存-辅存</font>层次主要解决存储系统的<font color="#ff0000">容量问题</font>。
现代计算机系统几乎都具有这两个存储层次，构成了<font color="#ff0000">缓存、主存、辅存</font>三级存储系统。
![[01c09a9483675be64bb01bdabdd8eb9.jpg]]
![[08dd0592ff125b41b8e13c7176a25ee.jpg]]
### 4.2.1 主存储器
#### 主存的技术指标 P 74
主存的主要技术指标是<font color="#ff0000">存储容量和存储速度</font>。
![[a9f8a57fa56f9b20588ec4cb65e917f 1.jpg]]
1. 存储容量
存储容量是指主存能存放二进制代码的总位数,即

存储容量=存储单元个数 x 存储字长

它的容量也可用字节总数来表示，即

存储容量=存储单元个数 X 存储字长/8

目前的计算机存储容量大多以字节数来表示, 例如, 某机主存的存储容量为 256 MB, 则按字节寻址的地址线位数应对应 28 位。
2. 存储速度
存储速度是由存取时间和存取周期来表示的。

存取时间又称为存储器的访问时间(Memory Access Time),是指启动一次存储器操作(读或写)到完成该操作所需的全部时间。

存取周期(Memory Cycle Time)是指存储器进行连续两次独立的存储器操作(如连续两次读操作)所需的最小间隔时间,通常存取周期大于存取时间。

3. 存储器带宽
与存取周期密切相关的指标为存储器带宽,它表示单位时间内存储器存取的信息量,单位可用字/秒或字节/秒或位/秒表示。
（1）为了提高存储器的带宽, 可以采用以下措施: 缩短存取周期。
（2）增加存储字长, 使每个存取周期可读/写更多的二进制位数
（3）增加存储体 (详见 4.2.7 节)。

#### 4.2.2 半导体存储芯片 P 74
<font color="#ff0000">地址线是单向输入</font>的，其<font color="#ff0000">位数与芯片容量有关</font>。
<font color="#ff0000">数据线是双向的</font>（有的芯片可用成对出现的数据线分别作为输入或输出），其位数与芯片可读出或写入的数据位数有关。数据线的位数与芯片容量有关。
<font color="#ff0000">地址线和数据线的位数共同反映存储芯片的容量</font>。例如，地址线位 10 根，数据线为 4 根，则芯片容量为 2<sup>10</sup>X 4=4 K 位；又如地址线为 14 根，数据线为 1 根，则其容量为 16 K 位。

#### 4.2.3 随机存取存储器 P 76
随机存取存储器按其存储信息的原理不同，可分为静态 RAM 和动态 RAM 两大类。
##### 1. 静态 RAM（Static RAM，SRAM）P 76
存储器中用于寄存“0”和“1”代码的电路称为存储器的基本单元电路。
静态 RAM 是用触发器工作原理存储信息的，因此即使信息读出后，它仍保持其原状态，不需要再生。但电源掉电时，原存信息丢失，故它属易失性半导体存储器。
（1）读周期时序
读周期 t<sub>RC</sub>是指对芯片进行两次连续读操作的最小间隔时间。
（2）写周期时序
写周期 t<sub>WC</sub>是指对芯片进行连续两次写操作的最小间隔时间。

##### 2. 动态 RAM（Dynamic RAM，DRAM）P 81
常见的动态 RAM 基本单元电路有三管式和单管式两种，共同特点都是靠电容存储电荷的原理来寄存信息。
1.三管动态 RAM 芯片
2.单管动态 RAM 芯片
3.动态 RAM 时序
1. （1）读时序
	1. 读工作周期是指动态 RAM 完成一次“读”所需的最短时间 t<sub>CRD</sub>，也就是 RAS 的一个周期。
2. （2）写时序
3. （3）动态 RAM 的刷新
	1. 刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。
	2. 存储单元内的原信息将会慢慢消失，为此，必须采用定时刷新的方法，它规定在一定的时间内，对动态 RAM 的全部基本单元电路必作一次刷新，一般取 2ms，这个时间称为<font color="#ff0000">刷新周期，又称再生周期</font>。
	3. 通常有三种方式刷新：<font color="#ff0000">集中刷新、分散刷新和异步刷新</font>。
		1. （1）集中刷新：<font color="#ff0000">集中刷新是在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作</font>。
			1. 4000 个存取周期中，有 128 行集中刷新（128 个存取周期），其余 3872 个存取周期用来读/写或维持信息。64us （128 个存取周期）时间内，<font color="#ff0000">不能进行读/写操作的称为“死时间”，又称访存“死区”</font>。所占比率为 128/4000 x 100 ％=3.2％，称为<font color="#ff0000">死时间率</font>。
		2. （2）分散刷新
			1. 分散刷新是指对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期 t<sub>C</sub>分为两段，前半段 t<sub>M</sub>用来读/写或维持信息，后半段 t<sub>R</sub>用来刷新 t<sub>C</sub>=t<sub>M</sub>+t<sub>R</sub>。
		3. （3）异步刷新
			1. 异步刷新是前两种方式的结合，它既可缩短“死时间”，又充分利用最大刷新间隔为 2ms 的特点。
4. 动态 RAM 和静态 RAM 的比较
	1. 动态 RAM 的应用比静态 RAM 要广泛的多，原因如下：
		1. 在同样大小的芯片中，动态 RAM 的集成度远高于静态 RAM，如动态 RAM 的基本单元电路为一个 MOS 管，静态 RAM 的基本单元电路可为 4~6 个 MOS 管。
		2. 动态 RAM 行、列地址按先后顺序输送，减少了芯片引脚，封装尺寸也减少
		3. 动态 RAM 的功耗比静态 RAM 小。
		4. 动态 RAM 的价格比静态 RAM 的价格便宜。
	2. 动态 RAM 容量不断扩大，速度不断提高，它被广泛应用于计算机的主存。
	3. 动态 RAM 的缺点：
		1. 由于使用动态元件（电容），因此它的速度比静态 RAM 低。
		2. 动态 RAM 需要再生，故需配置再生电路，也需要消耗一部分功耗。通常，容量不大的高速缓冲存储器大多用静态 RAM 实现。

##### 4.2.5 存储容量的扩展、存储器与 CPU 的连接 P 91
1. 存储容量的扩展
由于<font color="#ff0000">单片存储芯片的容量总是有限的</font>，很难满足实际的需要，因此，必须将若干存储芯片连在一起才能组成足够容量的存储器，称为存储容量的扩展，通常有位扩展和字扩展。
（1）位扩展
<font color="#ff0000">位扩展是指增加存储字长。</font>
如，2 片 1 K X 4 位的芯片可组成 1 K X 8 位的存储器
（2）字扩展
<font color="#ff0000">字扩展是指增加存储器字的数量。</font>
如，用 2 片 1 K X 8 位的存储芯片可组成一个 2 K X 8 位的存储器，即存储字增加了一倍。
（3）字、位扩展
<font color="#ff0000">字、位扩展是指既增加存储字的数量，又增加存储字长。</font>
如，用 8 片 1 K X 4 位的芯片组成 4 K X 8 位的存储器。

2. 存储器与 CPU 的连接 P 94
存储芯片与 CPU 芯片相连时，特别要注意片与片之间的地址线、数据线与控制线的连接。
（1）地址线的连接
存储芯片的容量不同，其地址线数也不同，<font color="#ff0000">CPU 的地址线数往往比存储芯片的地址线数多</font>。通常总是将 CPU 地址线的<font color="#ff0000">低位与存储芯片的地址线相连</font>。CPU 地址线的<font color="#ff0000">高位或在存储芯片扩充时用</font>，或用做其他用途。
（2）数据线的连接
同样，<font color="#ff0000">CPU 的数据线数与存储芯片的数据线数也不一定相等</font>。此时，<font color="#ff0000">必须对存储芯片扩位，使其数据位数与 CPU 的数据线数相等</font>。
（3）读/写数据线的连接
CPU 读/写<font color="#ff0000">命令线</font>一般可<font color="#ff0000">直接</font>与存储芯片的读/写<font color="#ff0000">控制端</font><font color="#ff0000">相连</font>，通常<font color="#ff0000">高电平为读</font>，<font color="#ff0000">低电平为写</font>。
（4）片选线的连接
<font color="#ff0000">片选线的连接是 CPU 与存储芯片正确工作</font>的关键。
（5）合理选择存储芯片
合理选择存储芯片主要是指存储<font color="#ff0000">芯片类型（RAM 或 ROM）和数量</font>的选择。

### 4.2.6存储器的校验--海（汉）明码 P 101

![[e82afda78542bb408fa29b62b62697b.jpg]]

![[71dea4d855e0af68031e01464f9f285.jpg]]

###### 例 4.5 按奇原则配置 1100101 的汉明码。
根据 1100101，得 n=7。根据<font color="#ff0000">2<sup>k</sup>≥n+k+1 求出需增添 k=4 位检测位</font>。
![[2507258dfb1664944139dbd72678f2b.jpg]]

###### 课后习题 4.17-4.19，P 151
![[Pasted image 20230612183100.png]]
根据 1100101，得 n=7。根据2<sup>k</sup>≥n+k+1 求出需增添 k=4 位检测位。
<font color="#ff0000">画表格。</font>
4.17-4.18
码位    1       2     3      4      5      6      7 
码值    P<sub>1</sub>     P<sub>2</sub>    D<sub>4</sub>    P<sub>3</sub>    D<sub>3</sub>    D<sub>2</sub>    D<sub>1</sub> 
P<sub>1</sub>       √              √               √              √
P<sub>2</sub>                √     √                       √      √
P<sub>4</sub>                       √       √      √      √

---

P<sub>1</sub> =C<sub>1</sub>⊕b<sub>4</sub>⊕b<sub>3</sub>⊕b<sub>1</sub>  (1⊕3⊕5⊕7)  
P<sub>2</sub> =C<sub>2</sub>⊕b<sub>4</sub>⊕b<sub>2</sub>⊕b<sub>1</sub>  (2⊕3⊕6⊕7)  
P<sub>1</sub> =C<sub>4</sub>⊕b<sub>3</sub>⊕b<sub>2</sub>⊕b<sub>1</sub>  (4⊕5⊕6⊕7)  
（偶数个 1 结果为 0，奇数个 1 结果为 1）。

---
4.19
码位    1       2      3      4      5      6      7      8     9     10   11
码值    C<sub>1</sub>     C<sub>2</sub>    b<sub>7</sub>    C<sub>4</sub>    b <sub>6</sub>    b<sub>5</sub>    b<sub>4</sub>   C<sub>8</sub>   b<sub>3</sub>    b<sub>2</sub>   b<sub>1</sub>
![[86908fcfa577afa08ba1a3e29fc55a0.jpg]]
![[Pasted image 20230612183215.png]]
![[Pasted image 20230612183221.png]]
![[Pasted image 20230612183229.png]]
![[Pasted image 20230612183239.png]]
![[Pasted image 20230612183246.png]]


### 4.3 高速缓冲存储器 P 109
<font color="#ff0000">Cache--高速缓冲存储器</font>。由<font color="#ff0000">高速缓存 Cache 来解决主存与 CPU 速度的不匹配问题</font>。
Cache 的出现使 CPU 可以<font color="#ff0000">不直接访问主存，而与高速 Cache 交换信息</font>。
<font color="#ff0000">辅</font>助<font color="#ff0000">存</font>储器作为主存的后援设备，又称为外部存储器，简称<font color="#ff0000">外存</font>，它与主存一起组成了存储器系统的<font color="#ff0000">主存-辅存</font>层次。
### 原、反、补、移码 P 219、P 234
原反补移码的转换
![[6597c4780c477ead02559bd4d737bc1.png]]
减权定位
十→二，乘 2 取整
二→十，按权展开，相加求和
非十转换
八→二，按三位一组
十六→二，按四位一组
![[Pasted image 20230618212121.png]]

<font color="#ff0000">移码数值上等于补码，符号位相反</font>。
移码：在二进制存储中，补码的符号位取反即是移码，由于浮点数的特殊性，于是<font color="#ff0000">引入了移码用来解决浮点数中阶码的问题</font>。
溢出：超出表示范围。

<font color="#ff0000">移码：十进制小数中，小数点左移 n 为时，相当于该数乘以 10<sup>n</sup>；右移 n 位时，相当于该数除以 10<sup>n</sup></font>
<font color="#ff0000">对于正数，原码补码反码=真值，故移位后出现的空位均以 0 添之</font>。

算术移位和逻辑移位的区别：
<font color="#ff0000">有符号数</font>的移位称为<font color="#ff0000">算术移位</font>，<font color="#ff0000">无符号数</font>的移位称为<font color="#ff0000">逻辑移位</font>。
逻辑移位的规则是：逻辑<font color="#ff0000">左移</font>时，<font color="#ff0000">高位移丢</font>，<font color="#ff0000">低位添 0</font>；逻辑<font color="#ff0000">右移</font>时，<font color="#ff0000">低位移丢</font>，<font color="#ff0000">高位添 0</font>.
算术左移时，符号位移至 C<sub>y</sub>，最高数位就可避免移丢。
寄存器的内容位 01010011，逻辑左移位 10100110，算术左移为 11011001。

<font color="#ff0000">-B <sub>补</sub>由 B<sub>补</sub>连同符号位在内，每位取反，末位+1 而得</font>。

<font color="#ff0000">异或：同号相加=0，异号相加=1</font>。

![[Pasted image 20230612183803.png]]

【B】补与【-B】补相互转换：<font color="#ff0000">全部位</font>按位取反、末位<font color="#ff0000">+1</font>
更简便的方法：从右往左找到第一个“1”，这个“1”左边的<font color="#ff0000">全部位</font>按位取反（包括符号位），右边保持<font color="#ff0000">不变</font>
运算
	5. 补码的加法运算
		
		![[e0a9cc9fc27dbb3b5c69cf2d221f61e.png]]
		补位数值位不能解读为"位权"，要先将补码转换为原码，才可用位权解读出其真值
		![[f8767b999f9676e4ad44cf5f74aa6c7.jpg]]
		![[e583389f324e870fe7f11eaa2fcf48d.jpg]]
		![[69119262f1c45613b0fa95956ca55a9.jpg]]
	6. 补码的减法运算
		![[58d12e208cebef2d4fcb3c0d221e956.jpg]]
		[B]补与[-B]补相互转换：<font color="#ff0000">全部位</font>按位取反、末位<font color="#ff0000">+1</font>
		更简便的方法：从右往左找到第一个“1”，这个“1”左边的<font color="#ff0000">全部位</font>按位取反（包括符号位），右边保持<font color="#ff0000">不变</font>
		![[2378c91051d520feb89e11df91704b5.jpg]]
		![[6ada76eb06235c1533f239beb887f7f.jpg]]
	2. 移码的表示
		移码就是在补码的基础上将<font color="#ff0000">符号位取反</font>
		![[638b716c8fe9fae3c6fb61f32da9e39.png]]
	3. 移码与补码的对比
		![[ce5eeb0ff48001dc398d020fc8327f7.jpg]]
		![[178bf239e8f4d04b3d70267781c562f.png]]
		移码的特性使得更方便的用硬件电路对比大小
		所以，通常移码多用于浮点数、阶码
	4. 原、反、补、移码的特性总结表
		![[fdfd462b9c7f75ae98578092233364e.jpg]]
		![[b0e7d48110d28575ae2a19b140ccc7b.png]]


![[0c46b8ddb77e0cc6ebc5045ceb43b6b.jpg]]


机算
			![[b82173411be72f2bc741a89edf8966a.jpg]]
			机算补码转换到原码也是<u><font color="#ff0000">数值位取反，末位+1</font></u>
			<u></u>		![[49560b007f2fe62fd54f7c1357548e2.png]]
		手算
		原码与补码相互转化：从右往左找到第一个"1"，这个“1”左边的所有"<font color="#ff0000">数值位</font>"按位取反
			![[1ea536a169fdad5f95f60fd37266697.png]]
			![[7dae4d3b5622284958c000c93b39815.png]]
			![[7295d5bf715e5d2213eb922ec36bf6b.png]]
原、反、补、移码的转换
	![[6597c4780c477ead02559bd4d737bc1.png]]


### 规格化表示数值 P 229
二进制的最高位数值为 1
小数：小数点后第一位为 1
![[85b397571245311fee3d952e10e3e63.jpg]]
![[2b7bdb392ead911cecb57114ac0d924.jpg]]
阶码：阶码是整数，阶符和 m 位阶码的数值部分共同反映浮点数的表示范围及小数点的实际位置，常用移码或补码表示。IEEE 754 标准中采用移码的表示形式。

尾数：数符表示浮点数的符号，尾数的数值部分的位数 n 反映浮点数的精度，常用原码或补码表示。IEEE 754 标准中采用原码的表示形式。

**规格化：规定尾数的最高数位必须是一个有效值。非规格化浮点数要进行规格化操作才能变成规格化浮点数。**

-   左规：当浮点数运算的结果为非规格化时要进行规格化处理，将<font color="#ff0000">尾数算术左移一位，阶码减1</font>（基数为2时）。
- ![[Pasted image 20230612225746.png]]
-  右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数<font color="#ff0000">算术右移一位，阶码加1</font>（基数为2时）。
- ![[Pasted image 20230612225752.png]]
- ![[Pasted image 20230612225803.png]]
- ![[Pasted image 20230612225810.png]]
- 
![[56fcf26976de8205df0328f0b1a7f93.jpg]]
![[d0b5f9968d8530befaf12fcb1e63668.jpg]]
![[6d6afbd97db9d52e521b1875a36d32b.jpg]]
![[ff473d2b082c219567b888f9223a0af.jpg]]

![[Pasted image 20230612225515.png]]
![[Pasted image 20230612225523.png]]
![[Pasted image 20230612225530.png]]
![[Pasted image 20230612225536.png]]
![[Pasted image 20230612225546.png]]
![[Pasted image 20230612225551.png]]
![[Pasted image 20230612225556.png]]


### 按字寻址和按字节寻址
##### 基本概念

位 (bit)
位是电子计算机中<font color="#ff0000">最小的数据单位</font>。每一位的状态只有两种：0 或 1，在硬件上利用高电压和低电压两种信号实现；

字节 (Byte, B)
字节由 <font color="#ff0000">8 个位</font>组成，它是<font color="#ff0000">存储空间的基本计量单位</font>；

字
字由若干个字节组成。因此，字一定为字节的整数倍。<font color="#ff0000">字的位数称为字长</font>（注意：字不等于字长乘以字节！<font color="#ff0000">字=字长×位</font>）。比如一个 8 位的 CPU，这里的 8 位指其字长为 8 位，即单位时间内可以处理 8 位二进制数，即一个字节数。现在的 CPU 大部分为 64 位，即单位时间内可以处理 64 位二进制数，即 8 个字节数；

地址线
用于<font color="#ff0000">传输地址信息的数据线</font>，一根地址线可以通过高电平或低电平来区分 1 或 0，因此一根地址线有两个状态：1 或 0，那么 N 根地址线可以表示个不同的状态。

##### 寻址与寻址方式
什么是寻址？
<font color="#ff0000">寻址指当 CPU 请求数据时获得该数据在内存上的位置的过程</font>。内存上存储的所有数据都会有一个可以区分的地址，这与其存放的位置相对应，当 CPU 请求数据时，内存中的电路会根据 CPU 的地址线上的信号利用数据总线向 CPU 返回数据。

那么内存是如何编码数据保存的位置的？这里涉及到上文所述的字节的概念。内存每一个存储位置的最小单元都可以储存 0 或 1，即一个位的内容，而<font color="#ff0000">内存将 8 个位设定为一个存储空间的基本单位</font>。而在地址线上每一个地址的编号便对应的是一个存储位置的最小的基本单位。

如何在地址线上用信号表示这个地址，这个问题引出了两个不同的寻址方式：<font color="#ff0000">按字节寻址和按字寻址</font>。

###### 按字节寻址
<font color="#ff0000">按字节寻址指一个地址线表示的数（即状态）与一个字节地址相对应</font>。比如一台机器有 30 根地址线，如果按字节寻址，其寻址范围是=1 GB。注意这里用的单位是 B，原因如上文所述，30 根地址线对应的是磁盘中的存储空间的基本单位，即 1 B，8 个位。

###### 按字寻址
计算机以此方式寻址时，每一个地址值指向了一个字，这里指向的便不是按字节寻址中的字节了。如前文所述对字的定义，一个字里面有任意个字节，那么计算机如何知道其地址指向的到底是字中的第几个字节呢？这便需要地址线中分出一部分标出其所指的到底是字中的第一个字节，还是第二个，亦或是其他。比如一个计算机有 30 根地址线，如果按字寻址，其字的字长为 64 位的话，那么每个字长有 4 个字节，4 个字节用二进制编码需要两位来区分（比如第 1、2、3、4 个字节分别为 00，01，10，11）因此真正用来表示字的位置的地址线有 30-2=28 根，其寻址范围是 2^28=256 MW。注意这里单位为 W 表示一个字。

按字寻址和按字节寻址相同处
不难发现，不论哪种方式，其编码内存中存储基本单位（即 B）的数量是一样的。拿上述两个例子来说，按字节寻址可编码 1 GB，按字寻址编码 256 MW，而根据例子中对字长的约定 1 W=4 B，即其用来表示字中到底要第几个字节的两根地址线的值共可编码 4 个不同，其最终可编码的字节数：256 M×4 B=1 GB，因此寻址方式不同只是定义上的差异，其实际上搜索的地址范围（这里的地址范围指的是搜寻的字节数，不是寻址范围！寻址范围求法参考上文两个例子中的解法）是一样的。

![[Pasted image 20230612230044.png]]

设有一个<font color="#ff0000">1MB容量</font>的存储器，<font color="#ff0000">字长32位</font>，问：按字节编址，字编址的寻址范围以及各自的寻址范围大小? 

如果<font color="#ff0000">按字节编址</font>，则 

<font color="#ff0000">1MB = 2^20B </font>
<font color="#ff0000">1字节=1B=8bit </font>
<font color="#ff0000">2^20B/1B = 2^20 </font>

<font color="#ff0000">地址范围为0~(2^20)-1</font>,也就是说需要二十根地址线才能完成对1MB 空间的编码，所以<font color="#ff0000">地址寄存器为20位</font>,<font color="#ff0000">寻址范围大小为2^20=1M</font>。

如果<font color="#ff0000">按字编址</font>，则

<font color="#ff0000">1MB=2^20B</font>
<font color="#ff0000">1字=32bit=4B</font>
<font color="#ff0000">2^20B/4B = 2^18   </font>

 <font color="#ff0000">地址范围为0~2^18-1</font>，也就是说我们至少要用18根地址线才能完成对1MB空间的编码。因此<font color="#ff0000">按字编址的寻址范围是2^18</font>

以上题目注意几点：

1. 区分寻址空间与寻址范围两个不同的概念<font color="#ff0000">，寻址范围仅仅是一个数字范围，不带有单位</font>

而寻址范围的大小很明显是一个数，指寻址区间的大小

  而<font color="#ff0000">寻址空间指能够寻址最大容量</font>，单位一般用 MB、B 来表示；本题中寻址范围为 0~(2^20)-1, 寻址空间为 1 MB。

2. <font color="#ff0000">按字节寻址</font>，指的是<font color="#ff0000">存储空间的最小编址单位是字节</font>，<font color="#ff0000">按字编址</font>，是指<font color="#ff0000">存储空间的最小编址单位是字</font>，以上题为例，总的存储器容量是一定的，按字编址和按字节编址所需要的编码数量是不同的，按字编址由于编址单位比较大（<font color="#ff0000">1 字=32 bit=4 B</font>），从而编码较少，而按字节编址由于编码单位较小（<font color="#ff0000">1 字节=1 B=8 bit</font>），从而编码较多。1 字节=8 字位


3. 区别 M 和 MB。

 <font color="#ff0000">M为数量单位</font>。1024=1K，1024K=1M

 <font color="#ff0000">MB指容量大小</font>。1024B=1KB，1024KB=1MB.

##### 地址线和数据线
1. 
地址线：用来<font color="#ff0000">传输地址信息</font>。

数据线：用来<font color="#ff0000">传递数据信息</font>。

举个简单的例子：CPU 在内存或硬盘里面寻找一个数时，先通过地址线找到对应数据的地址，然后再通过数据线将对应地址下的数据取出。

地址线和数据线的根数计算：

用 16 k×8 的存储芯片构建 <font color="#ff0000">128 k×32 </font>的存储器系统，存储系统按照字节编址。

问：该存储系统数据线___根，地址线___根。

思路：

数据线的根数和存储器最大位宽有关，最大位宽为 32 位，表示存储器可以一次性存入 32 位的数据，所以<font color="#ff0000">数据线根数为 32</font>

地址线的根数和地址的个数有关系，存储系统按照<font color="#ff0000">字节编制，8 位为一个地址</font>，所以就有 <font color="#ff0000">128 k×4 B 个地址</font>，换算成 2^19 所以地址线就有<font color="#ff0000"> 19 根</font>。

更换条件：<font color="#ff0000">存储系统按照字编址</font>。

<font color="#ff0000">数据线的根数不会改变</font>。

<font color="#ff0000">地址线的根数改变</font>：字位拓展后的存储系统，字长为 32，地址按照字编址，一个地址里面就有 32 位的数据位，所以地址个数为 128 k 个，换算成 2^17，地址线就有 17 根。


例：某计算机字长为 32 位，其存储容量为 16 M×32 位，它的地址线和数据线的总和是？
答：字长 32 位的计算机即数据线有 32 位，其基本寻址的存储单元也是 1 个字节，即 8 位，32 位的字长共占 4 个存储单元，所以 16 M×32 位共需 16777216×4=67108864（64 M）个存储单元，所以需要对 67108864 个单元寻址，因此 67108864 个存储单元共需 26 根地址线，所以地址线和数据线的总和=26+32=58

2. 
存储 (存储单元):
16 M×32 位=16 M×4×B=64 M

寻址 (地址线):

64 M=64 X1024 kb=64 * 2^10 kB=64 * 2^20 B=2^26 B=2^26 字节（存储空间的基本计量单位）
其基本寻址的存储单元也是 1 个字节，即 8 位，32 位的字长共占 4 个存储单元，所以 16 M×32 位共需 16777216×4=67108864（64 M）个存储单元，所以需要对 67108864 个单元寻址，因此 67108864 个存储单元共需 26 根地址线，
地址总线的宽度，指的就是地址总线的根数
传输 (数据线):
字长=数据总线

位 (bit，简写为 b)：是电子计算机中最小的数据单位。每一位的状态只能是 0 或 1。

字节 (Byte, 简写为 B)：8 个二进制位构成 1 个“字节 (Byte)”，它是存储空间的基本计量单位。1 个字节可以储存 1 个英文字母或者半个汉字，换句话说，1 个汉字占据 2 个字节的存储空间。

字：“字”由若干个字节构成。如果是一台 16 位机，那么，它的 1 个字就由 2 个字节构成。字是计算机进行数据处理和运算的单位。

字长：字的位数叫做字长。，不同档次的机器有不同的字长。例如一台 8 位机，它的 1 个字就等于 1 个字节，字长为 8 位。如果是一台 16 位机，它的 1 个字就由 2 个字节构成，字长为 16 位。

===================

CPU 的位和字长 

位：在数字电路和电脑技术中采用二进制，代码只有“0”和“1”，其中无论是 “0”或是“1”在 CPU 中都是一“位”。 

字长：电脑技术中对 CPU 在单位时间内 (同一时间)能一次处理的二进制数的位数叫字长。所以能处理字长为 8 位数据的 CPU 通常就叫 8 位的 CPU。同理 32 位的 CPU 就能在单位时间内处理字长为 32 位的二进制数据。字节和字长的区别：由于常用的英文字符用 8 位二进制就可以表示，所以通常就将 8 位称为一个字节。字长的长度是不固定的，对于不同的 CPU、字长的长度也不一样。8 位的 CPU 一次只能处理一个字节，而 32 位的 CPU 一次就能处理 4 个字节，同理字长为 64 位的 CPU 一次可以处理 8 个字节。是指 CPU 或者 GPU 的数据传输位宽！越宽他的传输量以及速度越快。



### 一位乘
![[Pasted image 20230618212127.png]]
##### 逻辑移位与算术移位
逻辑移位：不管逻辑左移还是逻辑右移缺位补0
算术移位：1.无符号型值，和逻辑移位相同 2.有符号型值，根据符号位补缺位（和符号位相同）

在下面的原码一位乘和补码一位乘都遵循以下规则：

-   **1.多余进位舍去**
-   **2.一直执行到乘数被用完（被移除完）**
-   **3.原码最后需要移位，补码不需要移位**
-   **4.原码补码一位乘取值都不去原乘数的数**

<font color="#ff0000">总结：定点小数 n+1 位原码操作（包括符号位），进行 n 次（加法+右移）操作，得到 2n+1 位结果</font>。
逻辑右移，高位补 0
444 表示，4 位尾数，4 次加法，4 次右移

##### 原码一位乘法
运算法则：若 Yi=1,+X; 若 Yi=0,+0.
(<font color="#ff0000">n 次加法，n 次移位，结果共2n+1 位（1 位符号位，2n 位数值位），原码最后需要移位，补码最后不需要移位</font>）
定义：
符号位单独参加运算，数据位取绝对值，每次将一位乘数对应的部分积与原部分积的累加和进行相加，并右移一位，直到乘数的所有位被用完。
原码一位乘，乘积的符号位由两原码符号位<font color="#ff0000">异或</font>运算结果决定。
乘积的数值部分由两数绝对值相乘

<font color="#ff0000">原码一位乘保留符号位：防止溢出</font>.

举例

X=0.1101，Y=-0.1011，求XY
1.设置部分积，乘数与被乘数的绝对值
A=00.0000，B=|X|=00.1101，C=.1011
2.若判断位（C 的最后一位）为0，则部分积+0000；若为1，部分积+B
![[Pasted image 20230612103715.png]]
接着我们对符号的确定，是通过对被乘数与乘数的符号位进行异或判断的。

XY=(0⊕1).10001111=1.10001111

##### 补码一位乘

补码一位乘在操作和判断位上和原码一位乘有区别（符号位上，<font color="#ff0000">原码一位乘为一位，补码一位乘为两位</font>）

例题：X=-01101，Y=-01011，求（XY）补=？

做这道我们首先需要了解，两位判断位对应的操作
y<sub>i</sub> y<sub>i+1</sub>               <font color="#ff0000">y<sub>i+1</sub> - y<sub>i</sub></font>            操作
0 0                       0                  部分积右移一位
<font color="#ff0000">0 1</font>                       <font color="#ff0000"> 1</font>                  部分积<font color="#ff0000">+【x】<sub>补</sub></font>，再右移一位
<font color="#ff0000">1 0 </font>                      <font color="#ff0000">-1</font>                 部分积<font color="#ff0000">+【-x】<sub>补</sub></font>，再右移一位
1 1                        0                  部分积右移一位
![[Pasted image 20230612104000.png]]
 B 补，-B 补，C 分别对应 （X）补，（-X）补，（Y）补
 ![[Pasted image 20230612104057.png]]
 所以我们直接可以得到，XY=0010001111
P 251<font color="#ff0000">先判断乘数 y 的值是否小于零</font>，
y>0 时，按<font color="#ff0000">原码一位乘</font>的算法运算，只是在<font color="#ff0000">相加和移位时按补码规则</font>进行。（当乘数 y 为正数时，不管被乘数 x 符号如何，都可按原码乘法的规则运算，当然这里的加和移位都必须按补码规则运算。）
y<0 时<font color="#ff0000">先不考虑符号位</font>，用<font color="#ff0000">原码一位乘</font>的运算规则运算，<font color="#ff0000">最后再加上【-x】补校正</font>。（当乘数为负时是把乘法的补码<font color="#ff0000">【y】补去掉符号位</font>，当成一个正数与【x】补相乘，然后加上【-x】补进行校正。）
![[Pasted image 20230612133621.png]]
<font color="#ff0000">比较法又称 Booth 算法，符号位有两位数，符号位参与运算。</font>
![[Pasted image 20230612133654.png]]
![[Pasted image 20230612133727.png]]

（<font color="#ff0000">结果 1 位符号位+2n 位数值位，即共有 2n+1 位</font>）

溢出：溢出是指<font color="#ff0000">运算结果超过了数的表示范围</font>。通常，称大于机器所能表示的最大正数为上溢，称小于机器所能表示最小负数为下溢。举个例子，定点小数的表示范围是（-1,1），那么对于定点小数来说，小于-1的部分就是下溢，大于1的部分就是上溢。

1.  原码：两个 n 位数相乘，共需要进行 n 次加法和 n 次位移
2. ![[Pasted image 20230618202557.png]]
3. 所以布斯算法的算法过程为n+1次的”判断→加减→右移“的循环，右移的次数为n次。
​


### 指令扩展
<font color="#ff0000">指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数</font>。
![[7b76eb37180e69343cbcb8e520ae1ce.jpg]]
![[543145c4e0717dd028d4dc16794b5a5.jpg]]
![[60da3f9cf572a99df9298c041bed004.jpg]]

### 寻址
 寻址方式

1.  寻址方式是指<font color="#ff0000">确定本条指令的数据地址以及下一条将要执行的指令地址</font>的方法，它与硬件结构紧密相关，而且直接影响指令格式和指令功能。
2.  寻址方式分为<font color="#ff0000">指令寻址和数据寻址</font>。
3.  指令寻址：  
    （1）<font color="#ff0000">顺序寻址：程序计数器PC内</font>  
    （2）<font color="#ff0000">跳跃寻址：跳转指令内地址码给出</font>
4. 数据寻址
	1. （1）立即寻址
	2. （2）直接寻址
	3. （3）隐含寻址
	4. （4）间接寻址
	5. （5）寄存器寻址
	6. （6）寄存器间接寻址
	7. （7）基址寻址
	8. （8）变址寻址
	9. （9）相对寻址
	10. （10）堆栈寻址