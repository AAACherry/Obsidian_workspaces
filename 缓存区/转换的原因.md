一、为什么需要反码？

反码的作用就相当于数学中的负数。

对于小学生来说，会做的算术题是：5-3，但是不会做 3-5。于是，我们上初中的时候，数学里就引进了一个新的概念：负数。引入负数之后，本来是减法的运算就可以变成加法来实现：

3-5=3+[-5]=[-2]，中括号代表“负数”，“负数”就是我们人为给出的数学术语。

对于计算机来说，会做的算术题是：5+3，但是不会做 3-5。于是，我们就在编码里引进了一个新的概念：反码。引入反码之后，本来是减法的运算就可以变成加法来实现：

3-5=3+[-5]=[-2]，中括号代表“反码”，“反码”就是我们人为给出的计算机术语。

这里，你一定有一个疑问：为什么计算机只会做 5+3，不会做 3-5。这是因为在计算机的数字电路中只有加法器，没有所谓的“减法器”。不是说计算机厂商不会设计减法器，因为聪明的人既然发明了方法能够用加法来实现减法操作，那为什么还需要画蛇添足的弄一个减法器？

接着说：那么反码要怎么定义才能实现减法变加法的功能呢？聪明的人想的办法如下：

1. 正数的反码保持原码不变：3=[0_0000011]

2. 负数除最高位（正负符号位）外，全部取反 (0 变 1,1 变 0)：-5=1_0000101 取反=[1_1111010]

于是 3+[-5]=[-2]的计算过程为：

[0_0000011]+[1_1111010]=[1_11111101]

这样，这种反码方法就成功实现了目标！至于为什么，我想只有数学家能给出解释了。

二、为什么需要补码？

都是因为“0”这个特殊数字的存在。

先问你一个问题: 0 是正数还是负数？你肯定会说：0 既不是正数也不是负数，这是我们初中学到的数学知识。这个回答没有问题，所以以后每次碰到 0，人们都不会把它当正数或负数。

那么计算机呢？计算机不同于人脑，计算机在碰到任何数字之前只根据最高位的符号位来判断正负性，“0”表示正数,“1”表示负数。

前面我们推论了为何要用反码，那么用 8 位二进制反码表示的正数范围： +0 —— +127；负数范围： -127 —— -0。但是，其中有两个特殊的编码会出现：

[0_0000000]=+0 （反码）

[1_1111111]=-0 （反码）

其实，+0 和-0 代表的都是 0。这样一来，“0”这个数字在计算机中的编码就不是唯一的了。对于计算机来说，这是绝对不行的，因为任何数字都只能有 1 个编码。

于是，聪明的人就做了这样一个决定：把 0 当成正数，也即+0，这样 0 的编码就变成：0_0000000。那 8 位二进制表示的正数范围仍然是： +0 —— +127。

但是，对于负数就必须要做调整，也即-0 必须要让位---1_1111111 这个编码不能表示-0。我们可以把负数整体向后“挪动 1 位”：只要将 8 位二进制表示的负数范围从：-127 —— -0 变成：-128 —— -1，就能成功解决问题。

那么怎么整体挪动 1 位呢？方法就是反码+1。{1_1111111}编码就不再表示-0，而变成了-1。顺着推，最小的编码{1_0000000}就是-128。

我们给这个反码+1 又人为的取了一个新的名字，叫补码。于是乎，补码的定义如下：

1. 正数的补码保持原码不变：3={0_0000011}

2. 负数先求反码，然后再加 1：-5=[1_1111010]+1={1_1111011}

于是 3+{-5}={-2}的计算过程为：

{0_0000011}+{1_1111011}={11111110}

至此，通过补码就成功解决了数字 0 在计算机中非唯一编码的问题，且也能实现减法变加法。

所以，在计算机的世界里，0 是正数。这点和我们学的数学不一样。

{0_1111111}=+127 （补码）

{0_0000000}=+0 （补码）

{1_1111111}=-1 （补码）

{1_0000000}=-128 （补码）
————————————————
版权声明：本文为 CSDN 博主「程序猿 KIMI」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接： https://blog.csdn.net/kimichen123/article/details/113856174