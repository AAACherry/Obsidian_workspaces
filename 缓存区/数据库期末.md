
[数据库原理及应用教程（第4版）（微课版）-陈志泊-微信读书 (qq.com)](https://weread.qq.com/web/reader/25932750720f054d259ad6bkc1632f5021fc16a5320f3dc?)

[SQL是什么 (biancheng.net)](http://c.biancheng.net/sql/what-is-sql.html)

## 1 .选择题 20 分
### 第一章数据系统概述
#### 1.1 信息、数据、数据处理与数据管理
##### 1 .1.1 信息
1. 信息的定义：信息是人脑对现实世界事物的<font color="#ff0000">存在方式、运动状态以及事物之间联系</font>的<font color="#ff0000">抽象反映</font>。
2. 信息的特征：
	1. 信息<font color="#ff0000">源于物质和能量</font>。
	2. 信息是<font color="#ff0000">可以感知</font>的。
	3. 信息是<font color="#ff0000">可存储、加工、传递和再生的</font>。

##### 1.1.2 数据
1. 数据的定义：数据是由用来记录信息的<font color="#ff0000">可识别的符号组合</font>的，是信息的具体表现形式。
2. 数据的表现形式：其表现形式不仅包含<font color="#ff0000">数字，还包含文字、图形、图像、声音和视频等</font>（即一切可以存储形式的信息）。
3. <font color="#595959">数据与信息的联系：数据是信息的符号表示，信息则是对数据的语义解释</font>。
	1. <font color="#595959">信息=数据+语义</font>。
4. 数据处理与数据管理
	1. 数据处理的定义：数据处理是<font color="#ff0000">将数据转换成信息的过程</font>，包括<font color="#ff0000">对数据的收集、管理、加工利用乃至信息输出</font>等一系列活动。
	2. <font color="#7f7f7f">数据处理真正的含义应该是为了产生信息而处理数据</font>。
	3. 数据管理的过程：主要包括数据的<font color="#ff0000">分类、组织、编码、存储、维护、检索</font>等操作。

##### 1.1.2 数据库技术的产生、发展
随着计算机硬件和软件的发展，数据管理经历了<font color="#ff0000">人工管理、文件系统和数据库系统</font>三个发展阶段。
1. 人工管理阶段
	1. 产生时间：<font color="#ff0000">20 世纪 50 年代以前</font>。
	2. 作用：主要用于<font color="#ff0000">科学计算</font>。
	3. 特点，特征：
		1. 数据<font color="#ff0000">没有专门的存取设备</font>
		2. <font color="#595959">数据没有专门的管理软件</font>
		3. <font color="#595959">数据不共享</font>
		4. <font color="#595959">数据不具有独立性</font>
<center><font color="#ff0000">数据是否能够保存是文件系统阶段和人工管理阶段最根本的区别</font></center>
2. 文件系统阶段
	1. 产生时间：<font color="#ff0000">20 世纪 50 年代后期至 60 年代中期</font>
	2. 作用：不仅用于<font color="#ff0000">科学计算</font>，还大量用于<font color="#ff0000">信息管理</font>
	3. 特点、特征：
		1. <font color="#ff0000">数据以文件形式长期保存</font>
		2. <font color="#595959">由文件系统管理数据</font>
		3. <font color="#595959">程序与数据之间有一定独立性</font>
		4. <font color="#595959">文件的形式已经多样化</font>
		5. <font color="#595959">数据具有一定的共享性</font>
	4. <font color="#595959">根本问题：</font>
		1. <font color="#595959">数据共享性差、冗余度大</font>
		2. <font color="#595959">数据不一致性</font>
		3. <font color="#595959">数据独立性差</font>
		4. <font color="#595959">数据之间联系弱</font>
<center><font color="#ff0000">数据是否具有结构化是数据库系统阶段与文件系统阶段最根本的区别</font></center>
1. 数据库系统阶段
	1. 产生时间：<font color="#ff0000">20 世纪 60 年代后期开始</font>
	2. 数据库系统阶段管理数据的特点：
		1. <font color="#ff0000">结构化的数据及其联系的集合</font>
		2. 数据<font color="#ff0000">共享性高、冗余度低</font>
		3. 数据<font color="#ff0000">独立性高</font>
			- 数据的独立性分为两级：<font color="#ff0000">物理独立性和逻辑独立性</font>
		4. <font color="#ff0000">有统一的数据管理和控制功能</font>
*数据本身具有结构化
数据与数据之间具有结构化*

##### 1 .1.3 数据库系统的组成
Data->DB----->DBMS--------->DBS
数据--数据库--数据库管理系统--数据（库）系统
	数据库系统组成图 ![[Pasted image 20230610193322.png]]
	![[Pasted image 20230610193704.png]]

数据库系统（DataBase System，DBS）是指在<font color="#ff0000">计算机系统中引入数据库后的系统</font>。它主要由<font color="#ff0000">数据库、数据库用户、计算机硬件和计算机软件系统</font>等几部分组成。
1. 数据库（DB）是<font color="#ff0000">长期存储在计算机内、有组织的、可共享的数据的集合</font>。（和数据对象（如表、视图、存储过程和触发器等）的集合）
2. 数据库系统由<font color="#ff0000">数据库、数据库管理系统、应用系统和数据库管理员</font>组成。
3. 数据库的特点：
	1. 集成性
	2. 共享性
4. 用户：
	1. 定义：<font color="#ff0000">用户是指使用数据库的人，他们可对数据库进行存储、维护和检索等操作</font>。
	2. 第一类用户：<font color="#ff0000">最终用户</font>（End User）
	3. 第二类用户：<font color="#ff0000">应用程序员</font>（Application Programmer）
	4. 第三类用户：<font color="#ff0000">数据库管理员</font>（DataBase Administrator, DBA）
	5. 用户图 
		![[Pasted image 20230610193348.png]]

##### 1.1.4数据库系统的内部体系结构
数据库<font color="#ff0000">三级模式体系</font>结构的划分，<font color="#ff0000">有利于数据的独立性</font>。
数据库保护分为：<font color="#ff0000">安全性</font>控制、<font color="#ff0000">完整性</font>控制、<font color="#ff0000">并发性</font>控制和<font color="#ff0000">数据恢复</font>。
1. 数据库的三级结构:用户逻辑结构、数据库逻辑结构、物理结构。
2. 数据库系统的三级模式结构：数据库系统内部的体系结构从逻辑上分为 <font color="#ff0000">外模式、模式和内模式三级抽象模式结构和二级映像功能</font>。
3. 二级映像：
	1. <font color="#ff0000">外模式/模式映像：保证了逻辑独立性</font>。
	2. <font color="#ff0000">模式/内模式映像：保证了物理独立性</font>。
4. 模式
	1. 模式也称为<font color="#ff0000">概念模式，是数据库中全体数据的逻辑结构和特征的描述</font>，处于三级模式结构的中间层。
	2. 一个数据库只有一个模式。
5. 外模式
	1. 外模式（External Schema）又称为<font color="#ff0000">子模式</font>（Subchema）或<font color="#ff0000">用户模式</font>（User Schema），外模式是三级结构的最外层，<font color="#ff0000">是数据库用户/能看到并允许使用的/那部分数据的逻辑结构和特征的描述</font>。
6. 内模式
	1. 内模式（Internal Schema）又称<font color="#ff0000">存储模式</font>（Storage Schema）或<font color="#ff0000">物理模式</font>（Physical Schema），是三级结构中的最内层，也是最靠近物理存储的一层，它<font color="#ff0000">是对数据库存储结构的描述，是数据在数据库内部的表示方式</font>。
7. 模式图
	![[57bc6b78aa9c7d2986a306bd46e1d02.jpg]]

	<center><font color="#ff0000">在数据库系统中，外模式可有多个，而模式和内模式只能各有一个。</font></center>

8. 数据库系统的三级模式与二级映像的优点
	1. 保证数据的<font color="#ff0000">独立性</font>
	2. 简化了用户<font color="#ff0000">接口</font>
	3. 有利于数据<font color="#ff0000">共享</font>
	4. 有利于数据的<font color="#ff0000">安全保密</font>

##### 1.1.5数据库系统的外部体系结构
从<font color="#ff0000">最终用户角度来看</font>，数据库系统分为<font color="#ff0000">单用户结构、主从结构、分布式结构</font>和建立在主从结构和分布式结构基础上的<font color="#ff0000">客户机/服务器结构（Client/Server，C/S）和浏览器/服务器结构（Browser/Server，B/S）</font>。
浏览器/服务器结构是针对客户机/服务器结构的不足而提出的。

##### 1.1.6 数据库管理系统
数据库管理系统是<font color="#ff0000">位于用户和数据库之间的软件系统</font>。
<font color="#ff0000">数据库管理系统（DBMS）是/对数据进行管理的/大型系统软件。</font>
DBMS 的主要功能：包括数据<font color="#ff0000">定义</font>功能、数据<font color="#ff0000">操纵</font>功能、数据库<font color="#ff0000">运行管理</font>功能、数据库的<font color="#ff0000">建立和维护</font>功能、数据<font color="#ff0000">通信接口</font>及数据<font color="#ff0000">组织、存储和管理</font>功能。
	图 ![[05ba0f881e4e4e290675531e20324e6.jpg]]
1. 数据定义语言（DDL）
	1. Data Define Language（DDL），定义数据的模式、外模式和内模式三级模式结构，定义模式/内模式和外模式/模式二级映像，定义有关的约束条件
2. 数据操纵语言（DML）
	1. Data Manipulation Language, DML, 实现对数据库的基本操作，包括检索、更新（包括插入、修改和删除）等。
3. 数据控制语言（DCL）
4. DBMS 的六个功能：
	1. 数据定义功能-创建、删除、修改
	2. 数据操纵功能-增删改查
	3. 数据库运行管理功能-DMBS 对数据库的控制主要通过四个方面实现
		1. 数据的安全性控制
		2. 数据的完整性控制
		3. 多用户环境下的数据并发现控制
		4. 数据库的恢复
	4. 数据库的建立和维护功能
		1. 数据库的建立包括数据库的初始数据的装入与数据转换等
		2. 数据库的维护主要包括数据库的转储、恢复、重组织与重构造、系统性能监视与分析等
	5. 数据通信接口-与操作系统协调完成
	6. 数据组织、存储和管理
		1. 对需要存放的数据进行组织、存储和管理，确定以何种文件结构和存取方式<font color="#ff0000">物理地</font>组织这些数据，提高增删改查的效率
5. 一个完整的 DBMS 通常应由语言编译处理程序、系统运行控制程序及系统建立、维护程序和数据字典（Data Dictionary，DD）等几部分组成。
6. 图。<font color="#ff0000">授权为 GRANT</font>
	1. 数据库管理系统的语言 ![[b6f78f9910fd35965fbf9926a51c10b.jpg]]
	2. DBMS 的工作方式![[65af7ae2b52628dc526439fba62b953.jpg]]

##### 1.1.7 数据模型
1. 数据模型的分类：
	1. 根据<font color="#ff0000">模型应用的不同目的</font>，可以将这些模型划分为两类
		1. 第一类模型是<font color="#ff0000">概念模型</font>，也称为<font color="#ff0000">信息模型</font>。
		2. 第二类模型是<font color="#ff0000">逻辑模型</font>（或称<font color="#ff0000">数据模型</font>）和<font color="#ff0000">物理模型</font>。
		3. 逻辑模型主要包括<font color="#ff0000">层次模型</font>（Hierarchical Model）、<font color="#ff0000">网状模型</font>（Network Model）、<font color="#ff0000">关系模型</font>（Relational Model）和<font color="#ff0000">面向对象模型</font>（Object-oriented Model）等。
2. 数据模型的概念：
	1. <font color="#ff0000">数据模型是现实世界中的事物及其联系的一种模拟和抽象表示</font>。
3. 数据模型的三大组成：
	1. 数据模型通常由<font color="#ff0000">数据结构、数据操作和数据的完整性约束</font>三个要素组成。
	2. 数据结构描述了数据库的组成对象以及对象间的联系。
	3. 数据操作描述了数据库的动态特性
	4. 数据的完整性约束的完整性规则是制约和依存规则

##### 1.1.8 三个世界及其有关概念
1. 信息世界及其有关概念
	1. 实体（Entity）。
		1. 客观存在并且可以相互区别的“事物”称为实体。
		2. 具体的人、事和物，如：一个学生、一本书；抽象事件，如：一堂课、学生选修课程等
	2. 属性（Attribute）
		1. 实体所具有的某一特性称为属性。
		2. 如学生实体由学号、姓名、年龄、系等方面的属性组成。属性有“型”和“值”之分。“型 ”即为属性名，姓名、性别、年龄都是属性的型；“值”即为属性具体的内容，如学生（990001、张三、20、男、计算机），这些属性值的集合表示了一个学生实体。
	3. 实体型（Entity Type）
		1. 具有相同属性的实体必然具有共同的特征。
		2. 用实体名及其属性名集合来抽象和描述同类实体，称为实体型。如学生（学号，姓名，年龄，性别，系）就是一个实体型，它描述的是学生这一类实体
	4. 实体集（Entity Set）
		1. 同型实体的集合称为实体集。
		2. 如所有的学生、所有的课程等。
	5. 码（Key）
		1. 在实体型中，<font color="#ff0000">能唯一标识一个实体的属性或属性集称为实体的码</font>。
		2. 如学生的学号就是学生实体的码，而学生实体的姓名属性可能有重名，不能作为学生实体的码。有些教材也称为：键。
	6. 域（Domain）
		1. 某一属性的<font color="#ff0000">取值范围</font>称为该属性的域。
		2. 如学号的域为 6 位整数，姓名的域为字符串集合，年龄的域为小于 40 的整数，性别的域为男或女等。
	7. 联系（Relationship）
		1. 事物内部以及事物之间是有联系的。
2. 两个实体型之间的联系
	1. 一对一联系（1：1）
	2. 一对多联系（1：n）
	3. 多对多联系（m：n）
	4. 图 ![[5a7ce752a9f0b2cb98caaea80ea8066.jpg]]
3. 计算机世界
	1. 现实世界的事物反映到人的头脑中经过思维加工成数据，这一过程需要经过三个阶段，依次是<font color="#ff0000">现实世界、信息世界、计算机世界</font>。
	2. 字段（Field）<font color="#ff0000">标示实体属性的命名单位</font>称为<font color="#ff0000">字段</font>，也称为<font color="#ff0000">数据项</font>。
	3. 记录 （Record）<font color="#ff0000">字段的有序集合称为记录</font>。
	4. 文件（File）<font color="#ff0000">同一类记录的集合称为文件</font>。
	5. 关键字。<font color="#ff0000">能够唯一标识文件中每个记录的字段或字段集，称为记录的关键字，或简称键</font>。
	6. 图 ![[b514b3fd633eaf868f3499b949d6ed6.jpg]]

##### 1.1.9 四种数据模型
1. <font color="#ff0000">层次模型</font>
	1. 特点：
		1. <font color="#ff0000">每棵树</font><font color="#ff0000">有且仅有一个结点没有双亲，该结点就是根节点</font>。
		2. <font color="#ff0000">根节点以外的其他结点有且仅有一个双亲结点</font>。
		3. 父子结点之间的联系是<font color="#ff0000">一对多</font>（1：n）的联系。
2. <font color="#ff0000">网状模型</font>
	1. 特点：
		1. <font color="#ff0000">有一个以上的结点没有双亲结点</font>。
		2. <font color="#ff0000">允许结点有多个双亲结点</font>。
		3. 允许两个结点之间有<font color="#ff0000">多种联系</font>（<font color="#ff0000">复合联系</font>）。
3. <font color="#ff0000">关系模型</font>
	1. 关系模型的数据结构及其有关概念
		1. 关系模型的<font color="#ff0000">数据结构</font>是<font color="#ff0000">一张规范化的二维表</font>，它由<font color="#ff0000">表名、表头和表体</font>三部分构成。
		2. 关系（Relation）与关系实例
		3. 元组（Tuple）元组是二维表格中的一<font color="#ff0000">行</font>。
		4. 属性（Attribute）二维表格中的一<font color="#ff0000">列</font>。
		5. 域（Domain）属性的<font color="#ff0000">取值范围</font>。
		6. 分量。每一行元组对应的列的属性值，即为元组中的一个属性值。
		7. 候选码。<font color="#ff0000">能够唯一标识<u>元组</u>的最小的属性集</font>。
		8. 主码。多个候选码中选一个作为主码，一个关系只能有一个主码。
		9. 关系模式。关系模式是对关系的描述，一般表示为：关系名（属性 1，属性 2 ,..., 属性 n)。主码表示：用下划横线标出。
		10. 图 ![[Pasted image 20230610210221.png]]![[Pasted image 20230610210245.png]]
##### 1.1.10 数据库领域的新技术
（1）分布式数据库---集中式系统和分布式系统
	其基本特点如下：
	（1）集中控制处理效率高，可靠性好；
	（2）数据冗余少，数据独立性高；
	（3）易于支持复杂的物理结构去获得对数据的有效访问。
（2）数据仓库与数据挖掘技术。
（3）多媒体数据库。
（4）大数据技术。
	**大数据的4V特性**即“<font color="#ff0000">数据量大(Volume)”“数据类型繁多(Variety)”“数据处理速度快(Velocity)”和“数据价值密度低(Value)</font>”

##### 第一章习题与拓展
二、填空题
1.数据管理技术发展过程经过人工管理、文件系统和数据库系统三个阶段，其中数据独立性最高的阶段是<font color="#ff0000">数据库系统阶段</font>。
2.在关系数据库中，把数据表示成二维表，每一个二维表称为<font color="#ff0000">___关系___</font>。
3.在数据库理论中，数据物理结构的改变，如存储设备的更换、物理存储的更换、存取方式等都不影响数据库的逻辑结构，从而不引起应用程序的变化，称为<font color="#ff0000">___物理独立性___</font>。
4.数据库管理系统是位于用户与<font color="#ff0000">___操作系统___</font>之间的软件系统。
5.数据库系统中，实现数据管理功能的核心软件称为<font color="#ff0000">___数据库管理系统___</font>。
6.一个项目具有一个项目主管，一个项目主管可管理多个项目，则实体“项目主管”与实体“项目”间的关系属于<font color="#ff0000">___一对多___</font>的关系。
7.数据库三级模式体系结构的划分，有利于保持数据的<font color="#ff0000">___独立性___</font>。
8.数据库保护分为：安全性控制、<font color="#ff0000"><u>完整性控制</u></font>、并发性控制和数据恢复。
9.在数据库理论中，数据库总体逻辑结构的改变，如修改数据模式、增加新的数据类型、改变数据间联系等，不需要修改相应的应用程序，称为<font color="#ff0000">__逻辑独立性____</font>
10.数据库管理系统常见的数据模型有层次模型、网状模型和<font color="#ff0000">__关系模型__</font>三种。
11.对现实世界进行第一层抽象的模型，称为<font color="#ff0000">_概念__</font>模型；对现实世界进行第二层抽象的模型，称为<font color="#ff0000">_逻辑__</font>模型。
12.层次模型的数据结构是<font color="#ff0000">_树__</font>结构；网状模型的数据结构是<font color="#ff0000">_有向图__</font>结构；关系模型的数据结构是<font color="#ff0000">_二维表__</font>结构；面向对象模型的数据结构之间可以<font color="#ff0000">_嵌套和递归_</font>
13.在数据库技术中，编写应用程序的语言一般是 C、Basic 等高级语言，这些语言被称为<font color="#ff0000">__宿主_</font>语言。
14.数据库系统中，用于存放三级结构定义的数据库称为<font color="#ff0000">__数据字典____</font>
15.从最终用户来看，数据库系统的外部体系结构可分为五种类型：<font color="#ff0000">单用户结构、主从结构、分布式结构、客户机/服务器结构、浏览器/服务器结构</font>。
16.现实世界的事物反映到人的头脑中经过思维加工成数据，这一过程需要经过三个世界的转换，依次是<font color="#ff0000">现实世界、信息世界、计算机世界</font>。

- DBS 包含 DB 和 DBMS
- <font color="#ff0000">子模式是模式的子集</font>。
- 用<font color="#ff0000">树形结构</font>表示实体之间联系的模型是<font color="#ff0000">层次模型</font>
- 数据的模式定义与数据的物理存取构建的是<font color="#ff0000">数据定义语言</font>
- <font color="#ff0000">数据库是一组文件</font>
- 数据库系统是采用了数据库技术的计算机系统，数据库系统由数据库、数据库管理系统、应用系统和（C）。
A.系统分析员
B.程序员
C<font color="#ff0000">.数据库管理员</font>
D.操作员
- 数据库的三级模式结构的描述，正确的是_B__。
A.一个数据库可以有多个概念模式
B.<font color="#ff0000">数据库的概念模式与内模式之间的映射是有DBMS提供的</font>
C.应用程序直接访问概念模式，可以实现数据库的逻辑独立性
D.概念模式与外模式之间的映射关系应该定义在应用程序中
- 在数据库中存储的是（C）。
A.数据库
B.数据库管理员
C.<font color="#ff0000">数据以及数据之间的联系</font>
D.信息
- 关系数据库中用<font color="#ff0000">外码</font>实现参照完整性。
- 数据库系统由数据库、<font color="#ff0000">数据管理系统</font>、应用系统和<font color="#ff0000">数据库管理员</font>组成。
- <font color="#ff0000">视图</font>对应数据库三级模式中的<font color="#ff0000">外模式</font>。
- SQL 语言支持数据库三级模式结构，在 SQL 中，<font color="#ff0000">模式对应于基本表</font>，<font color="#4f81bd">内模式对应于存储文件</font>，<font color="#ffc000">外模式对应于视图和部分基本表</font>，<font color="#00b050">元组对应于表中的行</font>，<font color="#fac08f">属性对应于表中的列</font>。
1. 数据：是<font color="#ff0000">描述客观事物的符号</font>，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整形、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。
	<font color="#ff0000">数据，也就是符号</font>，必须具备两个前提：
	a.可以输入到计算机中
	b.能被计算机程序处理
	对于整型、实型等数值类型，可以进行数值计算。
	对于字符数据类型，就需要非数值的处理。而声音、图像、视频等其实是可以通过编码的手段变成字符数据来处理的

2. 数据元素：是<font color="#ff0000">组成数据的、有一定意义的基本单位</font>，在计算机中通常作为整体处理。也被称为<font color="#ff0000">记录</font>。
	比如畜类牛、马、羊、鸡、猪、狗等动物当然就是畜类的数据元素。

3. 数据项：<font color="#ff0000">一个数据元素可以由若干个数据项组成</font>。
	比如人这样的元素，可以有眼、耳、鼻、嘴等数据项，也可以有姓名、年龄、性别等数据项。
	<font color="#ff0000"><center>数据项是数据不可分割的最小单位。</center></font>

4. 数据对象**：是<font color="#ff0000">性质相同的数据元素的集合，是数据的子集</font>。
	什么叫性质相同呢？是指数据元素具有相同数量和类型的数据项，比如人这个例子，都有姓名、生日、性别等相同的数据项。
	既然数据对象是数据的子集，在实际应用中，处理的数据元素通常具有相同性质，在不产生混淆的情况下，我们将<font color="#ff0000">数据对象简称为数据</font>。

5. 数据结构
	结构，简单的理解就是<font color="#ff0000">关系</font>，比如分子结构，就是组成分子的原子之间的排列方式。严格带你说，结构是指各个组成部分相互搭配的排列的方式。在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系成为结构。
	数据结构：是<font color="#ff0000">相互之间存在一种或者多种特定关系的数据元素的集合</font>。



### 第二章关系数据库
#### 2 .1 关系模型的数据结构及其形式化定义
##### 2.1.1 关系的形式化定义及其有关概念
1. 域（Domain）
	1. 定义：域是一组具有相同数据类型的值的集合，又称为值域（用 D 表示）。
	2. 域中所包含的值的个数称为域的基数（用 m 表示）。
2. 笛卡儿积（Cartesian Product）
	1. <font color="#ff0000">每一个元素（d1,d2,…,dn）中的每一个值 di 叫做一个分量</font>（Component），分量来自相应的域（di∈Di）。
	2. <font color="#ff0000">每一个元素（d1,d2,…,dn）叫做一个 n 元组（n-Tuple），简称元组（Tuple）。但元组是有序的</font>，相同分量 di 的不同排序所构成的元组不同。如，以下三个元组是不同的，（1,2,3）≠（2,3, 1）≠（1,3,2）。
	3. 笛卡儿积实际是一个<font color="#ff0000">二维表</font>，<font color="#ff0000">表的框架即每一列由域构成。表的每一行就是一个元组</font>，表中的每一列可以来自同一个域。
3. 图
	1. ![[bedb84fe07c2be6982b6b685d4ec5e2.jpg]]
##### 2.1.2 关系的性质
1. <font color="#ff0000">列是同质的，即每一列中的分量必须来自同一个域，必须是同一类型的数据</font>。
2. <font color="#ff0000">不同的属性可来自同一个域，但不同的属性必须有不同的名字</font>。例如，设有如表2.5所示的关系，职业与兼职是两个列，它们来自同一个域，职业={教师，工人，辅导员}，但这两个列是两个不同的属性，必须给它们起不同的名字“职业”和“兼职”。
3. <font color="#ff0000">列的顺序可以任意交换</font>。但交换时，应连同属性名一起交换，否则将得到不同的关系。如关系 T1作（如表2.6所示）的交换时，对它无任何影响。
4. <font color="#ff0000">关系中元组的顺序（即行序）可任意</font>，在一个关系中可以任意交换两行的次序。因为关系是以元组为元素的集合，而集合中的元素是无序的，所以作为集合元素的元组也是无序的。根据关系的这个性质，可以改变元组的顺序使其具有某种排序，然后按照顺序查询数据，这样可以提高查询速度，如按照学号对元组进行排序等。
5. <font color="#ff0000"> 关系中不允许出现相同的元组</font>。因为数学上集合中没有相同的元素，而关系是元组的集合，所以作为集合元素的元组应该是唯一的。
6. <font color="#ff0000">关系中每一分量必须是不可分的数据项</font>，或者说所有属性值都是原子的，即是一个确定的值，而不是值的集合。属性值可以为空值，表示“未知”或“不可使用”，但不可“表中有表”。满足此条件的关系称为规范化关系，否则称为非规范化关系。
##### 关系的码与关系的完整性
1. 候选码（Candidate Key）<font color="#ff0000">能唯一标识关系中元组的一个属性或属性集，称为候选码，也称候选关键字或候选键</font>。
	1. 如“学生关系”中的学号能唯一标识每一个学生，则属性“学号”是学生关系的候选码。在“选课关系”中，只有属性的组合“学号+课程号”才能唯一地区分每一条选课记录，则属性集“学号+课程号”是选课关系的候选码。
	2. 定义2.6 设关系 R 有属性 A1,A2,…,An，其属性集 K=（Ai,Aj,…,Ak），当且仅当满足下列条件时，K 被称为候选码。
	3. （1）<font color="#ff0000">唯一性（Uniqueness），关系 R 的任意两个不同元组，其属性集 K 的值是不同的</font>。
	4. （2）<font color="#ff0000">最小性（Minimum），组成关系键的属性集（Ai,Aj,…,Ak）中，任一属性都不能从属性集 K 中删掉，否则将破坏唯一性的性质</font>。例如“学生关系”中的每个学生的学号是唯一的，“选课关系”中“学号+课程号”的组合也是唯一的。在属性集“学号+课程号”满足最小性，从中去掉任一属性，都无法唯一标识选课记录。
2. 主码（Primary Key）
	1. 如果一个关系中有多个候选码，可以从中<font color="#ff0000">选择一个</font>作为查询、插入或删除元组的操作变量，被选用的候选码称为主码，或称为主关系键、主键、关系键、关键字等。
	2. <font color="#ff0000">每个关系必须选择一个主码</font>，选定以后，不能随意改变。因为关系的元组无重复，因此关系的所有属性的组合可以唯一标识每个元组，但通常用属性数量最少的属性组合作为主码。
3. 主属性（Prime Attribute）与非主属性（Non-Prime Attribute）
	1. <font color="#ff0000">主属性（Prime Attribute）：包含在</font>（~~主码~~）<font color="#ff0000">候选码中的各个属性称为主属性。</font>
	2. <font color="#ff0000">非主属性（Non-Prime Attribute）：不包含在任何候选码中的属性称为非主属性（或非码属性）</font>。
##### 2.2.2 外码（外部关系键）
定义2.7 如果关系 R2的一个或一组属性 X 不是 R2的主码，而<font color="#ff0000">是另一关系 R1的主码</font>，则该属性或属性组<font color="#ff0000"> X 称为关系 R2的外码</font>（Foreign key）或外部关系键（在后续章节中统一称为外码），并称关系 R2为参照关系（Referencing Relation），关系 R1为被参照关系（Referenced Relation）。
##### 2.2.3 关系的完整性
关系模型中，有三类完整性约束，<font color="#ff0000">即实体完整性、参照完整性和用户自定义的完整性</font>。
1. <font color="#ff0000">实体完整性（Entity Integrity）实体完整性是指主码的值不能为空或部分为空</font>。
	1. 例如，一条学生记录对应着一个学生，学生关系对应着学生的集合。现实世界中的实体是可区分的，即它们具有某种唯一性标识。与此相对应，关系模型中以主关系键来唯一标识元组。
	2. 例如，学生关系中的属性“学号”可以唯一标识一个元组，也可以唯一标识学生实体。如果主码中的值为空或部分为空，即主属性为空，则不符合关系键的定义条件，不能唯一标识元组及与其相对应的实体。这就说明存在不可区分的实体，从而与现实世界中的实体是可以区分的事实相矛盾。因此主码的值不能为空或部分为空。
	3. 例如，学生关系中的主码“学号”不能为空，选课关系中的主码“学号+课程号”不能部分为空，即“学号”和“课程号”两个属性都不能为空。
2. <font color="#ff0000">参照完整性（Referential Integrity）如果关系 R2的外码 X 与关系 R1的主码相符，则 X 的每个值或者等于 R1中主码的某一个值或者取空值。</font>
	1. 在例2-2中，学生关系 S 的“系别”属性与系别关系 D 的主码“系别”相对应，因此，学生关系 S 的“系别”属性是该关系 S 的外码，学生关系 S 是参照关系，系别关系 D 是被参照关系。如图2-2所示，学生关系中某个学生（如 S1或 S2）“系别”的取值，必须在参照的系别关系中主码“系别”的值中能够找到，否则表示把该学生分配到一个不存在的部门中，显然不符合语义。如果某个学生（如 S11）“系别”取空值，则表示该学生尚未分配到任何一个系；否则，它只能取系别关系中某个元组的系别号值。
	2. 再如，在例2-3中，如果按照参照完整性规则，选课关系中的外码“学号”和“课程号”可以取空值或者取被参照关系中已经存在的值。但由于“学号+课程号”是选课关系中的主码，根据实体完整性规则，两个属性都不能为空。所以选课关系中的外码“学号”和“课程号”中只能取被参照关系中已经存在的值。
3. 图
	![[Pasted image 20230610220737.png]]
4. <font color="#ff0000">用户自定义完整性（User-defined Integrity）用户自定义完整性是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求</font>。
	1. 例如，属性值根据实际需要，要具备一些约束条件，如规定选课关系中成绩属性的取值范围在0和100之间；某些数据的输入格式要有一些限制等。关系模型应该提供定义和检验这类完整性的机制，以便用统一的、系统的方法处理它们，而不要由应用程序承担这一功能。
##### 2.3.1 关系代数的分类及其运算符
1. <font color="#ff0000">任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果。所以，运算对象、运算符和运算结果是运算的三大要素</font>。
2. <font color="#ff0000">关系代数的运算对象是关系，运算结果也是关系</font>。
3. 关系代数用到的运算符主要包括以下四类。
	1. （1）集合运算符：∪（并）、–（差）、∩（交）、×（广义笛卡儿积）。
	2. （2）专门的关系运算符：σ（选取）、∏（投影）、⋈xθy（θ连接）、 ⋈（自然连接）、÷（除）。
	3. （3）算术比较运算符：＞（大于）、≥（大于等于）、＜（小于）、≤（小于等于）、=（等于）、≠（不等于）。
	4. （4）逻辑运算符有：∧（与）、∨（或）、┐（非）。算术比较运算符和逻辑运算符是用来辅助专门的关系运算符进行操作的，所以，关系代数的运算按运算符的不同主要分为以下两类。
4. 
（1）传统的集合运算：<font color="#ff0000">该类运算把关系看成元组的集合，以元组作为集合中的元素来进行运算，其运算是从关系的“水平”方向即行的角度进行的。</font>它包括并、差、交和笛卡儿积等运算。
（2）专门的关系运算：<font color="#ff0000">该类运算不仅涉及行运算（水平方向），也涉及列运算（垂直方向）</font>，这种运算是为数据库的应用而引进的特殊运算。它包括选取、投影、连接和除法等运算。
从关系代数完备性角度看，关系代数分为以下两种操作类型。
（1）五种基本操作：并、差、积、选取和投影，构成关系代数完备的操作集。
（2）其他非基本操作：可用以上五种基本操作合成的所有其他操作。

定义2.8 设给定两个关系 R,S，若满足：
<font color="#ff0000">（1）具有相同的列数（或称度数）n</font>；
<font color="#ff0000">（2）R 中第 i 个属性和 S 中第 i 个属性必须来自同一个域（列同质）</font>。
则说关系 R,S 是相容的。
<font color="#ff0000">除笛卡儿积运算外，其他的集合运算要求参加运算的关系必须满足上述的相容性定义</font>。

1. 图
	1. ![[Pasted image 20230610221537.png]]
	2. ![[Pasted image 20230610221548.png]]

##### 2.3.3 专门的关系运算
1. 选择
	1. <font color="#ff0000">选取（Selection）选取运算是单目运算，它根据一定的条件从关系 R 中选择若干个元组，组成一个新关系</font>。选取改为选择。
	2. 记作：σF（R） = {t | t∈R∧F（t） = ’真’}
	3. 其中，σ为选取运算符；F 为选取的条件，它是由运算对象（属性名、常数、简单函数）、算术比较运算符（＞、≥、＜、≤、=、≠）和逻辑运算符（∨、∧、┐）连接起来的逻辑表达式，结果为逻辑值“真”或“假”。
	4. 选取运算实际上是从关系 R 中选取使逻辑表达式 F 为真的元组，是从行的角度进行的运算。
2. 投影
	1. <font color="#ff0000">投影（Projection）投影运算也是单目运算，关系 R 上的投影是从 R 中选择出若干属性列，组成新的关系</font>，即对关系在垂直方向进行的运算，从左到右按照指定的若干属性及顺序取出相应列，删去重复元组。
	2. 记作：ΠA（R）={t【A】| t∈R}
	3. 其中，A 为 R 中的属性列；Π为投影运算符。
	4. 从其定义可看出，投影运算是从列的角度进行的运算，这正是选取运算和投影运算的区别所在。选取运算是从关系的水平方向上进行运算的，而投影运算则是从关系的垂直方向上进行的。
3. 总结
	1. 选择和投影都涉及<font color="#ff0000">单目运算符</font>（<font color="#ff0000">只能对单个关系进行操作</font>）。
	2. 选择就是找出符合条件的<font color="#ff0000">元组</font>，当有多个条件时，<font color="#ff0000">中间用逻辑符号进行连接</font>。
	3. 投影是找出所需的属性，当有多个属性时，<font color="#ff0000">中间用逗号进行分隔</font>。
	4. 当选择和投影组合使用时，<font color="#ff0000">先做选择</font>。
4. θ连接（θJoin）
	1. θ连接运算是<font color="#ff0000">二目运算</font>，是<font color="#ff0000">从两个关系</font>的笛卡儿积中选取满足连接条件的元组，组成新的关系。
	2. 设有两个关系 R（A1,A2,…,An）及 S（B1,B2,…,Bm），连接属性集 X 包含于{A1,A2,…， An},Y 包含于{B1,B2,…,Bm},X 与 Y 中属性列数目相等，且对应属性有共同的域。若 Z={A1， A2,…,An}/X（/X 表示去掉 X 之外的属性）及 W={B1,B2,…,Bm}/Y，则 R 及 S 可表示为 R（Z， X）,S（W,Y）；关系 R 和 S 在连接属性 X 和 Y 上的θ连接，就是在 R×S 笛卡儿积中，选取 X 属性列上的分量与 Y 属性列上的分量满足θ比较条件的那些元组，也就是在 R×S 上选取在连接属性 X， Y 上满足θ条件的子集组成新的关系。新关系的列数为 n+m
	3. 记作：
		1. ![[Pasted image 20230610223932.png]]
		2. ![[Pasted image 20230610223946.png]]
		3. ![[Pasted image 20230610224114.png]]
		4. ![[Pasted image 20230610224127.png]]

##### 第二章习题
1. 简答题第六题 P 68
2. 以第1章的图1-21所示的教学管理数据库为例，用关系代数表达式表示以下各种查询要求。
	1. （1）查询 T1老师所授课程的课程号和课程名。
	2. （2）查询年龄大于18岁的男同学的学号、姓名、系别。
	3. （3）查询“李力”老师所讲授课程的课程号、课程名、课时。
	4. （4）查询学号为 S1的同学所选修课的课程号、课程名和成绩。
	5. （5）查询“钱尔”同学所选修课程的课程号、课程名和成绩。
	6. （6）查询至少选修“刘伟”老师所授全部课程的学生姓名。
	7. （7）查询“李思”同学未选修的课程号和课程名。
	8. （8）查询全部学生都选修了的课程的课程号、课程名。
	9. （9）查询选修了课程号为 C1和 C2的学生的学号和姓名。
	10. （10）查询选修了全部课程的学生的学号和姓名。
3. 答案
	1. ![[Pasted image 20230610225109.png]]
	2. ![[Pasted image 20230610224815.png]]
	3. ![[Pasted image 20230610224826.png]]
	4. ![[Pasted image 20230610224845.png]]

### 第三章关系数据库标准语言 ——SQL
#### 3.3 数据库的创建和使用
##### 3.3.1数据库的结构
SQL Server 至少产生两个文件：数据文件和事物日志文件
1. 数据文件
	1. 数据文件（Database File）是存放数据库数据和数据库对象的文件。一个数据库可以有一个或多个数据文件，一个数据文件只属于一个数据库。当有多个数据文件时，有一个文件被定义为<font color="#ff0000">主数据文件（Primary Database File），扩展名为．mdf，用来存储数据库的启动信息和部分或全部数据</font>。一个数据库<font color="#ff0000">只能有一个主数据文件</font>，<font color="#ff0000">其他数据文件被称为次数据文件（Secondary Database File），扩展名为．ndf，用来存储主要数据文件未存储的其他数据</font>。采用多个数据文件来存储数据的优点体现如下：
	2. （1）数据文件可以不断扩充，不受操作系统文件大小的限制；
	3. （2）可以将数据文件存储在不同的硬盘中，这样可以同时对几个硬盘并行存取，提高了数据的处理性能。
2. 事务日志文件
	1. <font color="#ff0000">事务日志文件（Transaction Log File）保存用于恢复数据库的日志信息，扩展名是.ldf</font>，每个数据库必须至少有一个事务日志文件。Microsoft SQL Server 将任何一次更新操作立即写入事务日志文件，之后更改计算机缓存中的数据，再以固定的时间间隔将缓存中的内容批量写入数据文件。Microsoft SQL Server 重启时会将事务日志中最新标记点后面的事务记录抹去，因为这些事物记录并没有真正的从缓存写入数据文件。
3. 文件组
	1. 文件组（File Group）是将多个数据文件集合起来形成的一个整体，每个文件组有一个组名。与数据文件一样，文件组也分为主要文件组和次要文件组。一个数据文件只能存在于一个文件组中，一个文件组也只能被一个数据库使用。当建立数据库时，主要文件组包括了主要数据文件和未指定组的其他文件。在次要文件组中可以指定一个缺省文件组，在创建数据库对象时，如果没有指定将其放在哪一个文件组中，就会将它放在缺省文件组中；如果没有指定缺省文件组，则主要文件组为缺省文件组。日志文件不分组，它不属于任何文件组。

##### 3.3.2 SQL Server 2012 的系统数据库
1. master 数据库 
	1. <font color="#ff0000">master 数据库是核心数据库</font>，记录 Microsoft SQL Server 系统的<font color="#ff0000">所有系统级信息</font>，包括实例范围的元数据（例如登录账户）、端点、链接服务器和系统配置信息。
	2. 此外，master 数据库还记录了所有其他数据库的存在、数据库文件的位置以及 Microsoft SQL Server 的初始化信息。如果 master 数据库不可用，则 Microsoft SQL Server 无法启动。
	3. 因此，用户尽量不要对 master 数据库执行操作，而且要保证始终有一个 master 数据库的当前备份可用。执行了创建与使用任意数据库、更改服务器或数据库的配置值、修改或添加登录账户等操作之后，应尽快备份 master 数据库。如果 master 数据库不可用，可以从当前数据库备份还原 master，也可以重新生成 master。注意，重新生成 master 将重新生成所有系统数据库。
2. model 数据库 
	1. model 数据库是所有用户数据库的创建模板，必须始终存在于 Microsoft SQL Server 系统中。当创建用户数据库时，系统将 model 数据库的全部内容（包括数据库选项）复制到新的数据库中，由此可以简化数据库及其对象的创建及设置工作。
3. msdb 数据库 
	1. SQL Server Agent 使用 msdb 数据库来计划警报和作业。此外，SQL Server Management Studio、Service Broker 和数据库邮件等功能也使用该数据库。
4. tempdb 数据库 
	1. tempdb 数据库用作系统的临时存储，主要用于保存以下内容。
	2. （1）显式创建的临时用户对象，如临时表、临时存储过程、表变量或游标。
	3. （2）数据库引擎创建的内部对象，如用于存储假脱机或排序中间结果的工作表。每次重新启动 SQL Server 时，SQL Server 都会重新创建 tempdb，从而获得一个干净的数据库副本。tempdb 数据库采用最小日志策略，在该数据库中的表上进行数据操作，比在其他数据库中要快得多。
5. resource 数据库 
	1. resource 数据库包含了 Microsoft SQL Server 中的所有系统对象，这些系统对象在物理上保留在 resource 数据库中，但在逻辑上显示在每个数据库的 sys 架构中。通过 resource 数据库可以更为轻松快捷地升级到新的 Microsoft SQL Server 版本。在早期版本的 Microsoft SQL Server 中，进行升级需要删除和创建系统对象。由于 resource 数据库文件包含所有系统对象，因此，现在仅通过将 resource 数据库文件复制到本地服务器便可完成升级。
##### 3.3.4 创建用户数据库
创建用户数据库有两种典型方法：一是通过 Management Studio 创建；二是通过 SQL 语句创建。
1. 用 Management Studio 创建数据库在 SQL Server 2012的 Management Studio 中，按下列步骤创建用户数据库。
	1. （1）在图3-2所示的 Management Studio 界面中，在“对象资源管理器”窗口，右键单击“数据库”节点，在弹出的快捷菜单中选择“新建数据库（N）…”命令（见图3-3），即可打开新建数据库窗口（见图3-4）。
		图 ![[Pasted image 20230611103629.png]]
	2. （2）图 3-4 中，在“常规”选项卡的“数据库名称”文本框中输入数据库的名称。在“数据库文件”列表中，指定数据库文件的名称、存储位置、初始容量大小和所属文件组等信息，并进行数据库文件大小、扩充方式和容量限制的设置。
	3. （3）单击“确定”按钮，则创建一个新数据库。
		1. 图 ![[Pasted image 20230611103736.png]]
2. 2.用 SQL 命令创建数据库创建数据库的 SQL 命令的语法格式如下所示：
```
CREATE DATABASE 数据库名称
[ON
[FILEGROUP 文件组名称]
（NAME=数据文件逻辑名称，
FILENAME=’路径+数据文件名’,
SIZE=数据文件初始大小，
MAXSIZE=数据文件最大容量，
FILEGROWTH=数据文件自动增长容量，
）]
[LOG ON
（NAME=日志文件逻辑名称，
FILENAME=’路径+日志文件名’,
SIZE=日志文件初始大小，
MAXSIZE=日志文件最大容量，
FILEGROWTH=日志文件自动增长容量，
）]
[COLLATE 数据库校验方式名称]
[FOR ATTACH]
```
对于上述命令，有以下几点说明。
<font color="#ff0000">默认为 M 字节，可以不用写出来</font>
（1）用【】中括号括起来的语句，表示在创建数据库的过程中可以选用或者不选用，例如，在创建数据库的过程中，如果只用第一条语句“CREATE DATABASE 数据库名称”，DBMS 将会按照默认的“逻辑名称”“文件组”“初始大小”“自动增长”和“路径”等属性创建数据库。
（2）“FILEGROWTH”可以是具体的容量，也可以是 UNLIMITED，表示文件无增长容量限制。
（3）“数据库校验方式名称”可以是 Windows 校验方式名称，也可以是 SQL 校验方式名称。
（4）“FOR ATTACH”表示将已经存在的数据库文件附加到新的数据库中。
（5）用（ ）括起来的语句，除了最后一行命令之外，其余的命令都用逗号作为分隔符。
【例3-1】用 SQL 命令创建一个教学数据库 Teach，数据文件的逻辑名称为 Teach_Data，数据文件存放在 E 盘根目录下，文件名为 TeachData.mdf，数据文件的初始存储空间大小为10MB，最大存储空间为500MB，存储空间自动增长量为10MB；日志文件的逻辑名称为 Teach_Log，日志文件物理地存放在 E 盘根目录下，文件名为 TeachData.ldf，初始存储空间大小为5MB，最大存储空间为500MB，存储空间自动增长量为5MB。
```
CREATE DATABASE Teach
ON（ 
NAME=Teach_Data,
FILENAME='D:\TeachData.mdf',
SIZE=10,MAXSIZE=500,
FILEGROWTH=10）
LOG ON（
NAME=Teach_Log,
FILENAME='D:\TeachData.ldf',
SIZE=5,MAXSIZE=500,
FILEGROWTH=5）
```
##### 3.3.5 修改用户数据库
创建数据库后，还可以对数据库的名称、大小和属性等进行修改。
1. 用 Management Studio 修改数据库在“对象资源管理器”窗口，右键单击要修改的数据库，从弹出菜单中选择“属性”命令，即可打开数据库属性对话框，如图3-5所示。
	图 ![[Pasted image 20230611104347.png]]
	1. （1）“常规”选项卡中包含数据库的状态、所有者、创建日期、大小、可用空间、用户数、备份和维护等信息。
	2. （2）“文件”选项卡中包含数据文件和日志文件的名称、存储位置、初始容量大小、文件增长和文件最大限制等信息。
	3. （3）“文件组”选项卡中可以添加或删除文件组。但是，如果文件组中有文件则不能删除，必须先将文件移出文件组，才能删除文件组。
	4. （4）“选项”选项卡中可以设置数据库的许多属性，如排序规则、恢复模式、兼容级别等。
	5. （5）“更改跟踪”选项卡可以设定是否对数据库的修改进行跟踪。
	6. （6）“权限”选项卡可以设定用户或角色对此数据库的操作权限。
	7. （7）“扩展属性”选项卡可以设定表或列的扩展属性。在设计表或列时，通常通过表名或列名来表达含义，当表名或列名无法表达含义时，就需要使用扩展属性。
	8. （8）“镜像”选项卡可以设定是否对数据库启用镜像备份。镜像备份是一种高性能的备份方案，但需要投入一定的设备成本，一般用于高可靠性环境。
	9. （9）“事务日志传送”选项卡设定是否启用事务日志传送。事务日志传送备份是仅次于镜像的高可靠性备份方案，可以达到分钟级的灾难恢复能力，实施成本远小于镜像备份，是一种经济实用的备份方案。
2. 用 SQL 命令修改数据库可以使用 ALTER DATABASE 命令修改数据库。注意，只有数据库管理员（DBA）或者具有 CREATE DATABASE 权限的人员才有权执行此命令。下面列出常用的修改数据库的 SQL 命令的语法格式。

```
ALTER DATABASE 数据库名称 
ADD FILE（
   具体文件格式）
[,…n]
[TO FILEGROUP 文件组名]
|ADD LOG FILE（
   具体文件格式）
[,…n]
|REMOVE FILE 文件逻辑名称
|MODIFY FILE（
   具体文件格式）
|ADD FILEGROUP 文件组名
|REMOVE FILEGROUP 文件组名
|MODIFY FILEGROUP 文件组名
{
READ_ONLY|READ_WRITE,
   | DEFAULT,
   | NAME = 新文件组名}
}
其中，“具体文件格式”为：
（NAME = 文件逻辑名称
[ , NEWNAME = 新文件逻辑名称]
[ , SIZE = 初始文件大小]
[ , MAXSIZE = 文件最大容量]
[ , FILEGROWTH =文件自动增长容量]
）

```
各主要参数说明如下。
1. ADD FILE：向数据库中添加数据文件。
2. ADD LOG FILE：向数据库中添加日志文件。
3. REMOVE FILE：从数据库中删除逻辑文件，并删除物理文件。如果文件不为空，则无法删除。
4. MODIFY FILE：指定要修改的文件。
5. ADD FILEGROUP：向数据库中添加文件组。
6. REMOVE FILEGROUP：从数据库中删除文件组。若文件组非空，无法将其删除，需要先从文件组中删除所有文件。
7. MODIFY FILEGROUP：修改文件组名称、设置文件组的只读（READ_ONLY）或者读写（READ_WRITE）属性、指定文件组为默认文件组（DEFAULT）。
8. ALTER DATABASE 命令可以在数据库中添加或删除文件和文件组、更改数据库属性或其文件和文件组、更改数据库排序规则和设置数据库选项。应注意的是，只有数据库管理员（DBA）或具有 CREATE DATABASE 权限的数据库所有者才有权执行此命令。

```
【例3-2】修改 Teach 数据库中的 Teach_Data 文件增容方式为一次增加20MB。

ALTER DATABASE Teach
MODIFY FILE
（ 
NAME = Teach_Data,
FILEGROWTH = 20）

【例3-3】用 SQL 命令修改数据库 Teach，添加一个次要数据文件，逻辑名称为 Teach_Datanew，存放在 E 盘根目录下，文件名为 Teach_Datanew.ndf。数据文件的初始大小为100MB，最大容量为200MB，文件自动增长容量为10MB。

ALTER DATABASE Teach
ADD FILE（
NAME=Teach_Datanew,
FILENAME='E:\Teach_Datanew.ndf',
SIZE=100,
MAXSIZE=200,
FILEGROWTH=10）

【例3-4】用 SQL 命令，从 Teach 数据库中删除例3-3中增加的次要数据文件。

ALTER DATABASE Teach
REMOVE FILE Teach_Datanew

```
3. 用 SQL 命令删除数据库使用 DROP DATABASE 命令可以从 SQL Server 中删除数据库，可以一次删除一个或多个数据库。只有数据库管理员（DBA）和拥有此权限的人员才能使用此命令。


```
DROP DATABASE 命令的语法如下：

DROP DATABASE 数据库名称 [,...n]

【例3-5】删除数据库 Teach。

DROP DATABASE Teach
```

4. 查看数据库信息
	1.用 Management Studio 查看数据库信息在 Management Studio 的“对象资源管理器”窗口中，选中“数据库”节点下的某个数据库，单击鼠标右键，在快捷菜单中选择“属性”，即可查看该数据库的详细信息。
	2.用系统存储过程查看数据库信息 SQL Server 2012提供了不少有用的系统存储过程，可以用它们获得许多从 Management Studio 界面中不易或不能看到的信息。有关存储过程的详细介绍请参见第7章，读者如果目前不了解存储过程也不要紧，可以把它当作函数或命令来用。
	（1）用系统存储过程显示数据库结构。可以使用系统存储过程 Sp_helpdb 来显示数据库结构，
```
其语法如下：Sp_helpdb [[@dbname=] 'name']
```
   使用 Sp_helpdb 系统存储过程可以显示指定数据库的信息。如果不指定
```
[@dbname=]'name'
```
子句，则会显示在 master.dbo.sysdatabases 表中存储的所有数据库信息，命令执行成功会返回0，否则返回1。如显示 Adventure Works2012数据库的信息：

```
EXEC Sp_helpdb Adventure Works2012
```

（2）用系统存储过程显示文件信息。
可以使用存储过程 Sp_helpfile 来显示当前数据库中的文件信息，

```
其语法如下：Sp_helpfile [[@filename =] 'name']
```

如果不指定文件名称，则会显示当前数据库中所有的文件信息。命令执行成功会返回0，否则返回1。如显示 Adventure Works2012数据库中的 Address 表的信息：
EXEC Sp_helpfile Address
（3）用系统存储过程显示文件组信息。可以系统存储过程 Sp_helpfilegroup 来显示当前数据库中的文件组信息，

```
其语法如下：Sp_helpfilegroup [[@filegroupname =] 'name']
```

如果不指定文件组名称，则会显示当前数据库中所有的文件组信息。命令执行成功会返回0，否则返回1。如显示 Adventure Works2012数据库中的所有文件组信息：

```
use AdventureWorks2008R2EXEC 
Sp_helpfilegroup
```
#### 3.4 数据表的创建和使用
##### 3.4.1 数据类型
图 ![[Pasted image 20230611105751.png]]
![[Pasted image 20230611105803.png]]

（1）整数型：按照取值范围从大到小，包括 bigint、int、smallint、tinyint、bit。在实际应用中，可以根据属性的具体取值范围选择适合的整数型。例如，第1章图1-21中的学生关系表（S）中的属性“年龄（Age）”的数据类型可以设置为 int。（2）数值型：包括精确数值型 numeric、decimal 和近似数值型 float、real。
numeric 与 decimal 在功能上等效，用于精确存储数值。以 numeric 为例，格式为 numeric（p，s），其中 p 表示数据长度，s 表示小数位数。例如，第1章图1-21中的选课关系表（SC）中的属性“成绩（Score）”的数据类型可以设置为 numeric（4，1），表示数据长度为4，小数位为小数点后一位。float 和 real 用来存储数据的近似值，当数值的位数太多时，可用它们存取数值的近似值。
（3）货币型：按照取值范围从大到小，包括 money 和 smallmoney，它们可以精确到所代表的货币单位的万分之一，也就是小数点后面4位。通常情况下，货币型可以转换为精确数值型。
（4）日期型：按照时间范围从大到小，包括 datetime 和 smalldatetime，可以精确到秒，smalldatetime 比 datetime 多占用4个字节。此外，还有一个常用的日期型是 date，这种数据类型只显示日期，不显示时间。
（5）字符型：包括 char、varchar、nchar、nvarchar、text、ntext。其中，char、varchar 存放非 Unicode 字符（即 ASCII 字符），一个字符占1个字节，char 是定长的，varchar 是非定长的。例如，第1章图1-21中的学生关系表（S）中的属性“学号（SNo）”可以设置为 char
（6），表示学号最多可以包含6个非 Unicode 字符，即使小于6个，在内存中也要分配6个字节的空间；如果设置为 varchar（6），则学号实际包含多少非 Unicode 字符，在内存中就分配多少字节，例如，学号“S1”包含2个字符，内存中删除尾端空白的4字节，分配2字节的空间。nchar、nvarchar 存放 Unicode 字符，一个字符占2个字节，nchar 是定长的，nvarchar 是非定长的。nchar、nvarchar 的用法与 char、varchar 相同，只是占用内存空间不同。例如，如果“学号（SNo）”设置为 nchar（6），则学号“S1”占12个字节；如果设置为 nvarchar（6），则学号“S1”占4个字节。当字符串中包含非 ASCII 字符时，最好不要使用 char、varchar。例如，学生关系表（S）中的属性“姓名（SN）”可以设置为 nchar、nvarchar。当某个字符型属性需要描述的字符数比较多时，可以将其设置为 text、ntext。其中，text 存放非 Unicode 字符，定长，最大可存储2GB；ntext 存放 Unicode 字符，非定长，最大可存储2GB。
（6）二进制数据型：包括 binary、varbinary、image。其中，binary 是定长的二进制数据型，varbinary 是非定长的二进制数据型，两者最多可以表示8000个字节。任何类型的数据都可存储在这种类型的字段中，不需数据转换。image 类型可以存储图片本身，这时需要事先将图片转换成二进制流的形式；也可以存储图片路径。此外，由于图片路径是字符串的形式，也可以使用字符型。
（7）特殊类型：包括 timestamp、uniqueidentifier、sql_variant、table。timestamp 数据类型提供数据库范围内的唯一值。此类型相当于 binary（8）或 varbinary（8），但当它所定义的列更新或添加数据行时，此列的值会被自动更新，一个计数值将自动地添加到此 timestamp 数据列中。每个数据库表中只能有一个 timestamp 数据列。如果建立一个名为“timestamp”的列，则该列的类型将被自动设为 timestamp 数据类型。uniqueidentifier 数据类型称为全球唯一标识符（Globally Unique Identifier， GUID），可用 NEWID（　　）函数产生。sql_variant 数据类型可以存储除文本、图形数据和 timestamp 类型数据外的其他任何合法的 SQL Server 数据，此数据类型大大方便了 SQL Server 的开发工作。table 数据类型用于存储对表或视图处理后的结果集，这一类型使得变量可以存储一个表，从而使函数或过程返回查询结果更加方便、快捷。
##### 3.4.3 数据库的约束
在 SQL Server 中，对于数据表的约束分为列约束和表约束。其中，列约束是对某一个特定列的约束，包含在列定义中，直接跟在该列的其他定义之后，用空格分隔，不必指定列名；表约束与列定义相互独立，不包括在列定义中，通常用于对多个列一起进行约束，与列定义用“，”分隔，定义表约束时必须指出要约束的列的名称。

```
完整性约束的基本语法格式为：[CO NSTRAINT <约束名> ] <约束类型>
CONSTRAINT不能空开，连在一起用
```

约束名：约束不指定名称时，系统会给定一个名称。
约束类型：在定义完整性约束时必须指定完整性约束的类型。在 SQL Server 中可以定义5种类型的完整性约束，下面分别加以介绍。
1、NULL/NOT 
<font color="#ff0000">NULL 约束 NULL 值不是0，也不是空白，更不是填入字符串“NULL”，而是表示“不知道”“不确定”或“没有数据”的意思</font>。当某一字段的值一定要输入值才有意义的时候，则可以设置为 NOT NULL。例如，主键列就不允许出现空值，否则就失去了唯一标识一条记录的作用。该约束只能用于定义列约束，
```
其语法格式如下：[CONSTRAINT <约束名> ][NULL|NOT NULL]
```
【例3-7】建立一个 S 表，对 SNo 字段进行 NOT NULL 约束。
CREATE TABLE S（
SNo VARCHAR（6）<font color="#ff0000"> CONSTRAINT</font> S_CONS NOT NULL,
SN NVARCHAR（10）,
Sex NCHAR（1）,
Age INT,
Dept NVARCHAR（20））
其中，S_CONS 为指定的约束名称。有了 NOT NULL 约束，在 S 表中录入数据，当 SNo 为空时，系统给出错误信息。无 NOT NULL 约束时，系统缺省为 NULL。
在字段的后面，也可以不加约束名称，直接写约束类型，这种情况下，系统会自动产生一个名字。如下列语句的功能与例3-7相同，只是省略约束名称。
CREATE TABLE S
（ SNo VARCHAR（6）NOT NULL,
SN NVARCHAR（10）,
Sex NCHAR（1）,
Age INT,
Dept NVARCHAR（20））

2.UNIQUE 约束（唯一约束）UNIQUE 约束用于指明基本表在某一列或多个列的组合上的取值必须唯一。定义了 UNIQUE 约束的那些列称为唯一键，系统自动为唯一键建立唯一索引，从而保证了唯一键的唯一性。唯一键允许为空，但系统为保证其唯一性，最多只可以出现一个 NULL 值。在建立 UNIQUE 约束时，需要考虑以下几个因素。
● 使用 UNIQUE 约束的字段允许为 NULL 值。
● 一个表中可以允许有多个 UNIQUE 约束。
● 可以把 UNIQUE 约束定义在多个字段上。
● UNIQUE 约束用于强制在指定字段上创建一个 UNIQUE 索引，缺省为非聚集索引。UNIQUE 既可用于列约束，也可用于表约束。UNIQUE 用于定义列约束时，

```
其语法格式如下：[CONSTRAINT <约束名>] UNIQUE
```
【例3-8】建立一个 S 表，定义 SN 为唯一键。
CREATE TABLE S
（ SNo VARCHAR（6）,
SN NVARCHAR（10） CONSTRAINT SN_UNIQ UNIQUE,
Sex NCHAR（1）,
Age INT,
Dept NVARCHAR（20））
其中，SN_UNIQ 为指定的约束名称，约束名称可以省略，
如下例：
CREATE TABLE S
（ SNo VARCHAR（6）,
SN NVARCHAR（10） UNIQUE,
Sex NCHAR（1）,
Age INT,
Dept NVARCHAR（20））

UNIQUE 用于定义表约束时，

```
其语法格式如下：[CONSTRAINT <约束名>] UNIQUE（<列名>[{,<列名>}]）
```

【例3-9】建立一个 S 表，定义 SN+Sex 为唯一键，此约束为表约束。
CREATE TABLE S
（ SNo VARCHAR（6）,
SN NVARCHAR（10） UNIQUE,
Sex NCHAR（1）,
Age INT,
Dept NVARCHAR（20）
CONSTRAINT S_UNIQ UNIQUE（SN, Sex））
系统为 SN+Sex 建立唯一索引，确保同一性别的学生没有重名。

3.PRIMARY KEY 约束（主键约束）
PRIMARY KEY 约束用于定义基本表的主键，起唯一标识作用，其值不能为 NULL，也不能重复，以此来保证实体的完整性。PRIMARY KEY 与 UNIQUE 约束类似，通过建立唯一索引来保证基本表在主键列取值的唯一性，但它们之间存在着很大的区别。
● 在一个基本表中只能定义一个 PRIMARY KEY 约束，但可定义多个 UNIQUE 约束。
● 对于指定为 PRIMARY KEY 的一个列或多个列的组合，其中任何一个列都不能出现 NULL 值，而对于 UNIQUE 所约束的唯一键，则允许为 NULL。
● 不能为同一个列或一组列，既定义 UNIQUE 约束，又定义 PRIMARY KEY 约束。PRIMARY KEY 既可用于列约束，也可用于表约束。
PRIMARY KEY 用于定义列约束时，

```
其语法格式如下：CONSTRAINT <约束名> PRIMARY KEY
```

【例3-10】建立一个 S 表，定义 SNo 为 S 的主键，建立另外一个数据表 C，定义 CNo 为 C 的主键。
定义数据表 S：
CREATE TABLE S
（ SNo VARCHAR（6） CONSTRAINT S_Prim PRIMARY KEY,
SN NVARCHAR（10） UNIQUE,
Sex NCHAR（1）,
Age INT,
Dept NVARCHAR（20））
定义数据表 C：
CREATE TABLE C
（ CNo VARCHAR（6） CONSTRAINT C_Prim PRIMARY KEY,
CN NVARCHAR（20）,
CT INT）

PRIMARY KEY 用于定义表约束时，即将某些列的组合定义为主键时，

```
其语法格式如下：[CONSTRAINT <约束名>] PRIMARY KEY （<列名>[{,<列名>}]）
```

【例3-11】建立一个 SC 表，定义 SNo+CNo 为 SC 的主键。
CREATE TABLE SC
（ SNo VARCHAR（6） NOT NULL,
CNo VARCHAR（6） NOT NULL,
Score NUMERIC（4,1）,
CONSTRAINT SC_Prim PRIMARY KEY（SNo,CNo））

4.FOREIGN KEY 约束（外键约束）
FOREIGN KEY 约束指定某一列或几列作为外部键。其中，包含外部键的表称为从表，包含外部键所引用的主键或唯一键的表称为主表。系统保证从表在外部键上的取值是主表中某一个主键值或唯一键值，或者取空值，以此保证两表间的参照完整性。
FOREIGN KEY 既可用于列约束，也可用于表约束，

```
其语法格式为：[CONSTRAINT<约束名>] FOREIGN KEY REFERENCES <主表名> （<列名>[{,<列名>}]）
```

【例3-12】建立一个 SC 表，定义 SNo、CNo 为 SC 的外部键。
```
CREATE TABLE SC
（ SNo VARCHAR（6） NOT NULL CONSTRAINT S_Fore FOREIGN KEY REFERENCES S（SNo）,

CNo VARCHAR（6） NOT NULL CONSTRAINT C_Fore FOREIGN KEY REFERENCES C（CNo）,

Score NUMERIC（4,1）,

CONSTRAINT S_C_Prim PRIMARY KEY （SNo,CNo））
```

5.CHECK 约束 
CHECK 约束用来检查字段值所允许的范围，如一个字段只能输入整数，而且限定在0～100的整数，以此来保证域的完整性。在建立 CHECK 约束时，需要考虑以下几个因素。
● 一个表中可以定义多个 CHECK 约束。
● 每个字段只能定义一个 CHECK 约束。
● 在多个字段上定义的 CHECK 约束必须为表约束。
● 当执行 INSERT、UPDATE 语句时，CHECK 约束将验证数据。
CHECK 既可用于列约束，也可用于表约束，

```
其语法格式为：[CONSTRAINT <约束名>] CHECK （<条件>）
```

【例3-13】建立一个 SC 表，定义 Score 的取值范围为0～100之间。

```
CREATE TABLE SC
（ SNo VARCHAR（6）,
CNo VARCHAR（6）,
Score NUMERIC（4,1） CONSTRAINT Score_Chk CHECK（Score>=0 AND Score <=100））
```


【例3-14】建立包含完整性定义的学生表 S。

```
CREATE TABLE S（ SNo VARCHAR（6） CONSTRAINT S_Prim PRIMARY KEY,
SN NVARCHAR（10） CONSTRAINT SN_Cons NOT NULL,
Sex NCHAR（1） CONSTRAINT Sex_Cons NOT NULL DEFAULT '男',
Age INT CONSTRAINT Age_Cons NOT NULLCONSTRAINT Age_Chk CHECK （Age BETWEEN 15 AND 50）,
Dept NVARCHAR（20） CONSTRAINT Dept_Cons NOT NULL）
```


与例3-6相比，例3-14所创建的学生表中的每一列都增加了完整性约束定义。其中，指定 SNo 为主键，指定 SN、Sex、Age、Dept 各个列均不能为空，同时 Sex 的默认值为“男”，Age 的取值范围为15～50。
读者可以模仿上例建立第1章图1-21中包含完整性定义的表 T、表 C、表 SC 和表 TC。

##### 3.4.4 修改数据库
用 SQL 命令修改数据表 SQL 使用 ALTER TABLE 命令来完成这一功能，有如下三种修改方式。
（1）ADD 方式。
ADD 方式用于增加新列和完整性约束，定义方式与 CREATE TABLE 语句中的定义方式相同，

```
其语法格式为：ALTER TABLE <表名> ADD <列定义> | <完整性约束定义>
```

【例3-15】在 S 表中增加一个班号列和住址列。

```
ALTER TABLE S
ADD
Class_No VARCHAR（6）,
Address NVARCHAR（20）
```

注意：使用此方式增加的新列自动填充 NULL 值，所以不能为增加的新列指定 NOT NULL 约束。

【例3-16】在 SC 表中增加完整性约束定义，使 Score 在0～100之间。
ALTER TABLE SC
ADD
CONSTRAINT Score_Chk CHECK（Score BETWEEN 0 AND 100）

（2）ALTER 方式。
ALTER 方式用于修改某些列，

```
其语法格式为：ALTER TABLE <表名>ALTER COLUMN <列名> <数据类型> [NULL|NOT NULL]
```

【例3-17】把 S 表中的 SN 列加宽到12个字符。
ALTER TABLE S
ALTER COLUMN
SN NVARCHAR（12）

注意：使用此方式有如下一些限制。
● 不能改变列名。
● 不能将含有空值的列的定义修改为 NOT NULL 约束。
● 若列中已有数据，则不能减少该列的宽度，也不能改变其数据类型。
● 只能修改 NULL/NOT NULL 约束，其他类型的约束在修改之前必须先将约束删除，然后再重新添加修改过的约束定义。

（3）DROP 方式。
DROP 方式只用于删除完整性约束定义，

```
其语法格式为：ALTER TABLE<表名>DROP CONSTRAINT <约束名>
```

【例3-18】删除 S 表中的主键。
ALTER TABLE S
DROP CONSTRAINT S_Prim

##### 3.4.5 删除基本表
用 SQL 命令删除数据表删除表的 SQL 命令

```
语法格式为：DROP TABLE <表名>
```

【例3-19】删除表 S。
DROP TABLE S

### 第四章
### 第六章数据库设计
P 213
##### 6.1.3数据库设计的步骤
图 ![[Pasted image 20230611111921.png]]
数据库设计中，前两个阶段是面向用户的应用要求和面向具体的问题；中间两个阶段是面向数据库管理系统；最后两个阶段是面向具体的实现方法。前四个阶段可统称为“分析和设计阶段”，后两个阶段统称为“实现和运行阶段”。

这六个阶段的主要工作各有不同。

1. 系统需求分析阶段
<font color="#ff0000">系统需求分析阶段需求分析是整个数据库设计过程的基础，要收集数据库所有用户的信息内容和处理要求，并加以规格化和分析</font>。这是最费时、最复杂的一步，但也是最重要的一步，相当于待构建的数据库大厦的地基，它决定了以后各步设计的速度与质量。需求分析做得不好，可能会导致整个数据库设计返工重做。在分析用户需求时，要确保用户目标的一致性。
2.概念结构设计阶段
<font color="#ff0000">概念结构设计是把用户的信息要求统一到一个整体逻辑结构中，此结构能够表达用户的要求，是一个独立于任何 DBMS 软件和硬件的概念模型</font>。
3.逻辑结构设计阶段
<font color="#ff0000">逻辑结构设计是将上一步所得到的概念模型转换为某个 DBMS 所支持的数据模型，并对其进行优化。</font>
4.物理结构设计阶段
<font color="#ff0000">物理结构设计是为逻辑数据模型建立一个完整的、能实现的数据库结构，包括存储结构和存取方法</font>。上述分析和设计阶段是很重要的，如果做出的分析或设计不恰当，则会设计出一个不恰当或反应迟钝的数据库系统。
5.数据库实施阶段
<font color="#ff0000">此阶段可根据物理结构设计的结果把原始数据装入数据库，建立一个具体的数据库并编写和调试相应的应用程序。</font>应用程序的开发目标是开发一个可依赖的有效的数据库存取程序，来满足用户的处理要求。
6.数据库运行与维护阶段
<font color="#ff0000">这一阶段主要是收集和记录实际系统运行的数据，数据库运行的记录用来提供用户要求的有效信息，用来评价数据库系统的性能，并进一步调整和修改数据库</font>。在运行中，必须保持数据库的完整性，且能有效地处理数据库故障和进行数据库恢复。在运行和维护阶段，可能要对数据库结构进行修改或扩充。
可以看出，以上六个阶段是从数据库应用系统设计和开发的全过程来考察数据库设计的问题。因此，它既是数据库也是应用系统的设计过程。在设计过程中，努力使数据库设计和系统其他部分的设计紧密结合，把数据和处理的需求收集、分析、抽象、设计和实现在各个阶段同时进行、相互参照、相互补充，以完善两方面的设计。按照这个原则，数据库各个阶段的设计可用图6-4描述。
在图6-4有关处理特性的描述中，采用的设计方法和工具属于软件工程和管理信息系统等课程中的内容，本书不再讨论，这里重点介绍数据特性的设计描述以及满足数据特性的数据模型的设计。
![[Pasted image 20230611112317.png]]
1．数据库设计分为哪几个阶段？每个阶段的主要工作是什么？

按规范设计法可将数据库设计分为六个阶段:

1. 系统需求分析阶段
需求分析是整个数据库设计过程的基础，要收集数据库所有用户的信息内容和处理要求，并加以规格化和分析。

2. 概念结构设计阶段
概念结构设计是把用户的信息要求统一到一个整体逻辑结构中。

3. 逻辑结构设计阶段
逻辑结构设计是将上一步所得到的概念模型转换为某个 DBMS 所支持的数据模型，并对其进行优化。

4. 物理结构设计阶段
物理结构设计是为逻辑数据模型建立一个完整的、能实现的数据库结构，包括存储结构和存取方法。

5. 数据库实施阶段
此阶段可根据物理结构设计的结果把原始数据装入数据库，建立一个具体的数据库并编写和调试相应的应用程序。

6. 数据库运行与维护阶段
这一阶段主要是收集和记录实际系统运行的数据，数据库运行的记录用来提供用户要求的有效信息，用来评价数据库系统的性能，并进一步调整和修改数据库。
————————————————

##### 6.3.3 概念模型 E-R 表示方法
在概念模型中，比较著名的是由P.P.Chen 于1976年提出的实体联系模型（Entity Relationship Model），简称 E-R 模型。E-R 模型是广泛应用于数据库设计工作中的一种概念模型，它利用 E-R 图来表示实体及其之间的联系。
E-R 图的基本成分包含实体型、属性和联系，它们的表示方式如下。
（1）实体型：用<font color="#ff0000">矩形框</font>表示，框内标注实体名称，如图6-11（a）所示。
（2）属性：用<font color="#ff0000">椭圆形框</font>表示，框内标注属性名称，并用无向边将其与相应的实体相连，如图6-11（b）所示。
（3）联系：联系用<font color="#ff0000">菱形框</font>表示，框内标注联系名称，并用无向边与有关实体相连，同时在无向边旁标上联系的类型，即1:1、1: n 或 m: n，如图6-11（c）所示。
![[Pasted image 20230611112521.png]]
![[Pasted image 20230611112539.png]]
![[Pasted image 20230611112556.png]]

#### 6.4 逻辑结构设计
在数据库设计中，需求分析阶段的任务是什么？主要包括哪些内容？

从数据库设计的角度来看，需求分析的任务是：对现实世界要处理的对象（组织、部门、企业）等进行详细的调查，通过对原系统的了解，收集支持新系统的基础数据并对其进行处理，在此基础上确定新系统的功能。

<font color="#ff0000">需求分析阶段的任务包括</font>：
<font color="#ff0000">（1)调查分析用户活动</font>；
<font color="#ff0000">（2)收集和分析需求数据，确定系统边界</font>；
<font color="#ff0000">（3)编写系统分析报告</font>。
————————————————

##### 6.4.1 逻辑结构设计的任务和步骤
概念结构设计阶段得到的 E-R 模型是用户的模型，它独立于任何数据模型，独立于任何一个具体的 DBMS。为了建立用户所要求的数据库，需要把上述概念模型转换为某个具体的 DBMS 所支持的数据模型。数据库逻辑设计的任务是将概念模型转换成特定 DBMS 所支持的数据模型的过程。从此开始便进入了“实现设计”阶段，需要考虑到具体的 DBMS 的性能、具体的数据模型特点。
从 E-R 图所表示的概念模型可以转换成任何一种具体的 DBMS 所支持的数据模型，如网状模型、层次模型和关系模型。这里只讨论关系数据库的逻辑设计问题，所以只介绍 E-R 图如何向关系模型进行转换。
<font color="#ff0000">一般的逻辑结构设计分为以下三步</font>（如图6-24所示）。
![[Pasted image 20230611112812.png]]
<font color="#ff0000">（1）初始关系模式设计。</font>
<font color="#ff0000">（2）关系模式规范化。</font>
<font color="#ff0000">（3）模式的评价与改进。</font>

##### 6.4.2 初始关系模式设计
<font color="#ff0000">1.转换原则</font>
概念设计中得到的 E-R 图是由实体、属性和联系组成的，而关系数据库逻辑设计的结果是一组关系模式的集合。所以将 E-R 图转换为关系模型实际上就是将实体、属性和联系转换成关系模式。在转换中要遵循以下原则。
<font color="#ff0000">（1）一个实体转换为一个关系模式，实体的属性就是关系的属性，实体的码就是关系的主码</font>。
<font color="#ff0000">（2）一个联系转换为一个关系模式，与该联系相连的各实体的主码以及联系的属性均转换为该关系的属性。该关系的主码有三种情况</font>。
①如果联系为1:1，则每个实体的主码都可以是关系的候选码。
②如果联系为1: n，则 n 端实体的主码是关系的主码。
③如果联系为 n: m，则每个实体的主码的组合是关系的主码。
<font color="#ff0000">2.具体做法</font>
<font color="#ff0000">（1）把每一个实体转换为一个关系</font>。首先分析各实体的属性，从中确定其主码，然后分别用关系模式表示。
<font color="#ff0000">（2）把每一个联系转换为关系模式</font>。由联系转换得到的关系模式中，包含联系本身的属性和联系的关系的主码，其关系的主码确定与联系的类型有关。
<font color="#ff0000">（3）特殊情况的处理</font>。三个或三个以上实体间的一个多元联系在转换为一个关系模式时，与该多元联系相连的各实体的主码及联系本身的属性均转换成为关系的属性，转换后所得到的关系的主码为各实体主码的组合。
【例 6-1】图 6-25 表示供应商、项目和零件三个实体之间的多对多联系，如果已知三个实体的主码分别为“供应商号”，“项目号”与“零件号”，则它们之间的联系“供应”可转换为以下关系模式，其中供应商号、项目号、零件号为此关系的组合关系的主码。
供应（供应商号，项目号，零件号，数量）
![[Pasted image 20230611112948.png]]

##### 6.4.3 关系模式规范化
应用规范化理论对上述产生的关系的逻辑模式进行初步优化，以减少乃至消除关系模式中存在的各种异常，改善完整性、一致性和存储效率。规范化理论是数据库逻辑设计的指南和工具，规范化过程可分为两个步骤：确定范式级别和实施规范化处理。
<font color="#ff0000">1.确定范式级别考察关系模式的函数依赖关系，确定范式等级。</font>逐一分析各关系模式，考查主码和非主属性之间是否存在部分函数依赖、传递函数依赖等，确定它们分别属于第几范式。
<font color="#ff0000">2.实施规范化处理</font>
利用第4章的规范化理论，逐一考察各个关系模式，根据应用要求，判断它们是否满足规范要求，可用已经介绍过的规范化方法和理论将关系模式规范化。
实际上，数据库规范化理论可用于整个数据库开发生命周期中。在需求分析阶段、概念结构设计阶段和逻辑结构设计阶段，数据库规范化理论的应用如下。
<font color="#ff0000">（1）在需求分析阶段，用函数依赖的概念分析和表示各个数据项之间的联系。</font>
<font color="#ff0000">（2）在概念结构设计阶段，以规范化理论为指导，确定关系的主码，消除初步 E-R 图中冗余的联系。</font>
<font color="#ff0000">（3）在逻辑结构设计阶段，从 E-R 图向数据模型转换过程中，用模式合并与分解方法达到指定的数据库规范化级别（至少达到3NF）。</font>

##### 6.4.4 模式评价与改进
关系模式的规范化不是目的而是手段，数据库设计的目的是最终满足应用需求。因此，为了进一步提高数据库应用系统的性能，还应该对规范化后产生的关系模式进行评价、改进，经过反复多次的尝试和比较，最后得到优化的关系模式。
<font color="#ff0000">1.模式评价</font>
模式评价的目的是检查所设计的数据库模式是否满足用户的功能要求、效率要求，从而确定加以改进的部分。模式评价包括功能评价和性能评价。
（1）<font color="#ff0000">功能评价。功能评价指对照需求分析的结果，检查规范化后的关系模式集合是否支持用户所有的应用要求。</font>关系模式必须包括用户可能访问的所有属性。在涉及多个关系模式的应用中，应确保连接后不丢失信息。如果发现有的应用不被支持，或不完全被支持，则应进行关系模式的改进。发生这种问题的原因可能是在逻辑结构设计阶段，也可能是在系统需求分析或概念结构设计阶段。是哪个阶段的问题就返回到哪个阶段去改进，因此有可能对前两个阶段再进行评审，解决存在的问题。

在功能评价的过程中，可能会发现冗余的关系模式或属性，这时应对它们加以区分，搞清楚它们是为未来发展预留的，还是某种错误造成的，比如名字混淆。如果属于错误造成的，进行改正即可，而如果这种冗余来源于前两个设计阶段，则也要返回改进，并重新进行评审。
（2）<font color="#ff0000">性能评价</font>。对于目前得到的数据库模式，由于缺乏物理结构设计所提供的数量测量标准和相应的评价手段，所以性能评价是比较困难的，只能<font color="#ff0000">对实际性能进行估计</font>，<font color="#ff0000">包括逻辑记录的存取数、传送量以及物理结构设计算法的模型等</font>。同时，可根据模式改进中关系模式合并的方法，提高关系模式的性能。
<font color="#ff0000">2.模式改进</font>
<font color="#ff0000">根据模式评价的结果，对已生成的模式进行改进。</font>如果因为系统需求分析、概念结构设计的疏漏导致某些应用不能得到支持，则应该增加新的关系模式或属性。如果因为性能考虑而要求改进，则可采用合并或分解的方法。
<font color="#ff0000">（1）合并。如果有若干个关系模式具有相同的主码，并且对这些关系模式的处理主要是查询操作，而且经常是多关系的连接查询，那么可对这些关系模式按照组合使用频率进行合并</font>。这样便可以减少连接操作而提高查询效率。
<font color="#ff0000">（2）分解。为了提高数据操作的效率和存储空间的利用率，</font>最常用和最重要的模式优化方法就是分解，<font color="#ff0000">根据应用的不同要求，可以对关系模式进行垂直分解和水平分解</font>。
水平分解是把关系的元组分为若干个子集合，将分解后的每个子集合定义为一个子关系。对于经常进行大量数据的分类条件查询的关系，可进行水平分解，这样可以减少应用系统每次查询需要访问的记录数，从而提高了查询性能。

例如，有学生关系（学号，姓名，类别，……），其中类别包括大专生、本科生和研究生。如果多数查询一次只涉及其中的一类学生，就应该把整个学生关系水平分解为大专生、本科生和研究生三个关系。
垂直分解是把关系模式的属性分解为若干个子集合，形成若干个子关系模式，每个子关系模式的主码为原关系模式的主码。垂直分解的原则是把经常一起使用的属性分解出来，形成一个子关系模式。
例如，有教师关系（教师号，姓名，性别，年龄，职称，工资，岗位津贴，住址，电话），如果经常查询的仅是前六项，而后三项很少使用，则可以将教师关系进行垂直分解，得到两个教师关系：
教师关系1（教师号，姓名，性别，年龄，职称，工资）
教师关系2（教师号，岗位津贴，住址，电话）
这样，便减少了查询的数据传递量，提高了查询速度。
垂直分解可以提高某些事务的效率，但也有可能使另一些事务不得不执行连接操作，从而降低了效率。因此是否要进行垂直分解要看分解后的所有事务的总效率是否得到了提高。垂直分解要保证分解后的关系具有无损连接性和函数依赖保持性。相关的算法在第4章已经进行了详细介绍。
经过多次的模式评价和模式改进之后，最终的数据库模式得以确定。逻辑结构设计阶段的结果是全局逻辑数据库结构。对于关系数据库系统来说，就是一组符合一定规范的关系模式组成的关系数据库模式。
数据库系统的数据物理独立性特点消除了由于物理存储改变而引起的对应程序的修改。数据库的逻辑结构设计完成后，就可以开展物理结构设计。






## 2.传统的集合运算 8 分
并、交、差、笛卡儿积
R∪S——（从S中找出不同于R的，然后与R连接起来）
R∩S——（R与S相同点保留）
R-S——（R与S相同点去掉，然后剩下的写出来）
RXS——(R 的三列分别与 S 的三列组合成6 列×9 行 的表格)
	图 ![[Pasted image 20230610221627.png]]

## 3.专门的关系运算 16 分，P 68 十选四
1. 简答题第六题 P 68
2. [(15条消息) 数据库原理及应用教程(第4版|微课版)陈志泊-第二章习题_设有两组关系r与s,如表2-29与表2-30所示,试画出下列关系代数 r/s_陈九礼的博客-CSDN博客](https://blog.csdn.net/weixin_41640994/article/details/103636998)
3.  以第 1 章的图 1-21 所示的教学管理数据库为例，用关系代数表达式表示以下各种查询要求。
	1. ![[dfbb024f225c74aa29802d5fea98d28.jpg]]
	2. （1）查询 T 1 老师所授课程的课程号和课程名。
		1. ΠCNO，CN (σTNO= ‘T1’(TC)⋈Π CNO,CN( C))
		2. ![[Pasted image 20230610225447.png]]
		3. ![[Pasted image 20230610224926.png]]
	3. （2）查询年龄大于 18 岁的男同学的学号、姓名、系别。
		1. ΠSNO,SN,Dept(σAge>18∧Sex=‘男’ (S))
		2. ![[Pasted image 20230610225440.png]]
		3. ![[Pasted image 20230610224931.png]]
	4. （3）查询“李力”老师所讲授课程的课程号、课程名、课时。
		1. ΠCNo (ΠTNo(σTN=‘李力’(T)⋈TC) ⋈ C
		2. ![[Pasted image 20230610225433.png]]
		3. ![[Pasted image 20230610224939.png]]
	5. （4）查询学号为 S 1 的同学所选修课的课程号、课程名和成绩。
		1. ΠCNo,CN,Score (σSNo=‘S1’ (SC) ⋈ ΠCNo,CN ( C))
		2. ![[Pasted image 20230610225425.png]]
		3. ![[Pasted image 20230610224945.png]]
	6. （5）查询“钱尔”同学所选修课程的课程号、课程名和成绩。
		1. ΠCNo,CN,Score(ΠSNo (σSNo=‘钱尔’(S)) ⋈ ΠCno, CN( C) ⋈ SC)
		2. ![[Pasted image 20230610225416.png]]
		3. ![[Pasted image 20230610224952.png]]
	7. （6）查询至少选修“刘伟”老师所授全部课程的学生姓名。
		1. ΠSN (ΠSNo,SN (S)⋈ΠSNo,CNo(SC)÷ ΠCNO (σTN=‘刘伟’(T⋈TC)))
		2. ![[Pasted image 20230610225408.png]]
		3. ![[Pasted image 20230610225003.png]]
	8. （7）查询“李思”同学未选修的课程号和课程名。
		1. ΠCNo,CN((ΠCNo ( C) - ΠCNo (σTN=‘李思’ (S)⋈SC))⋈C）
		2. ![[Pasted image 20230610225400.png]]
		3. ![[Pasted image 20230610225009.png]]
	9. （8）查询全部学生都选修了的课程的课程号、课程名。
		1. ΠCNo,CN (C⋈(ΠSNo,CNo (SC) ÷ ΠSNo (S)))
		2. ![[Pasted image 20230610225352.png]]
		3. ![[Pasted image 20230610225015.png]]
	10. （9）查询选修了课程号为 C 1 和 C 2 的学生的学号和姓名。
		1. ΠSNo,CNo(SC) ÷ ΠCNo (σCNo= ‘C1’ ⋁ CNo=‘C2’ ) ( C))⋈ΠSNo,SN (S)
		2. ![[Pasted image 20230610225341.png]]
		3. ![[Pasted image 20230610225022.png]]
	11. （10）查询选修了全部课程的学生的学号和姓名。
		1. ΠSNo,SN (S⋈(ΠSNo,CNo(SC)÷ ΠCNo( C)))
		2. ![[Pasted image 20230610225334.png]]
		3. ![[Pasted image 20230610225026.png]]

## 4.E -R 图 16 分，P 241 四选一
[(15条消息) 【数据库原理及应用教程(第4版|微课版)陈志泊】【第六章习题】_数据库原理及应用教程陈志泊第四版答案_爱笑的冷面鬼的博客-CSDN博客](https://blog.csdn.net/weixin_52034760/article/details/124994505)

[(15条消息) 【数据库原理及应用教程(第4版|微课版)陈志泊】【第四章习题】_数据库原理及应用教程第四版课后答案_爱笑的冷面鬼的博客-CSDN博客](https://blog.csdn.net/weixin_52034760/article/details/124982519)

6.3.3 概念模型的 E-R 表示方法在概念模型中，比较著名的是由P.P.Chen 于1976年提出的实体联系模型（Entity Relationship Model），简称 E-R 模型。E-R 模型是广泛应用于数据库设计工作中的一种概念模型，它利用 E-R 图来表示实体及其之间的联系。E-R 图的基本成分包含实体型、属性和联系，它们的表示方式如下。
（1）<font color="#ff0000">实体型</font>：用<font color="#ff0000">矩形框</font>表示，框内标注实体名称，如图6-11（a）所示。
（2）<font color="#ff0000">属性</font>：用<font color="#ff0000">椭圆形框</font>表示，框内标注属性名称，并用无向边将其与相应的实体相连，如图6-11（b）所示。
（3）<font color="#ff0000">联系</font>：联系用<font color="#ff0000">菱形框</font>表示，框内标注联系名称，并用无向边与有关实体相连，同时在无向边旁标上联系的类型，即1:1、1: n 或 m: n，如图6-11（c）所示。
![[Pasted image 20230611014113.png]]
实体之间的联系有一对一（1:1）、一对多（1:n）和多对多（m:n）三种联系类型。例如，系主任领导系、学生属于某个系、学生选修课程、工人生产产品，这里“领导”“属于”“选修”“生产”表示实体间的联系，可以作为联系名称。

1．一个图书管理系统中有如下信息。
图书：书号、书名、数量、位置
借书人：借书证号、姓名、单位
出版社：出版社名、邮编、地址、电话、E-mail
其中约定：
任何人可以借多种书，任何一种书可以被多个人借，借书和还书时，要登记相应的借书日期和还书日期；一个出版社可以出版多种书籍，同一本书仅为一个出版社所出版，出版社名具有唯一性。
根据以上情况，完成如下设计。
（1）设计该系统的 E-R 图。
（2）将 E-R 图转换为关系模式。
（3）指出转换后的每个关系模式的主码。
————————————————
![[Pasted image 20230611120504.png]]
关系模式及主码:  
图书（<u>书号</u>，书名，数量，位置，出版社名）  
借书人（<u>借书证号</u>，姓名，单位）  
出版社（<u>出版社名</u>，邮编，地址，电话，E-mail)  
借阅（<u>借书证号</u>，<u>书号</u>，借书日期，还书日期）

![[Pasted image 20230611120536.png]]
![[7c1a3b5a48d32adbb4ca19f95d004e8.jpg]]

3．经过需求分析可知，某医院病房计算机管理系统中需要管理以下信息。
科室：科室名、科室地址、科室电话、医生姓名
病房：病房号、床位号、所属科室
医生：工作证号、姓名、性别、出生日期、联系电话、职称、所属科室名
病人：病历号、姓名、性别、出生日期、诊断记录、主管医生、病房号
其中，一个科室有多个病房、多名医生，一个病房只属于一个科室，一个医生只属于一个科室，但可负责多个病人的诊治，一个病人的主管医生只有一个。
根据以上需求分析的情况，完成以下有关的设计。
（1）画出该计算机管理系统中有关信息的 E-R 图。
（2）将该 E-R 图转换为对应的关系模式。
（3）指出转换以后的各关系模式的范式等级和对应的候选码。
————————————————
![[Pasted image 20230611120602.png]]
关系模式及候选码:  
科室（<u>科室名</u>，科室地址，科室电话）  
病房（<u>病房号</u>，床位号，科室名）  
医生（<u>工作证号</u>，姓名，性别，出生日期，联系电话，职称，科室名）  
病人（<u>病历号</u>，姓名，性别，出生日期，诊断记录，主管医生，病房号）

4．排课是教学环节中的重要过程，该过程包括以下实体。
1. 课程实体：course（cid，cname，chour，ctype）
Cid 唯一标识每一个课程
Cname : 课程名
Chour : 课程学时
Ctype : 课程类别（0 表示选修课，1 表示必修课）
2. 教室实体：classroom（crid，crname，crbuilding）
Crid 用于标识每一个教室
Crbuilding: 教室的楼宇
Crname : 教室的名称
3. 教师实体：teacher（tid，tname）
Tid 唯一标识每一名教师
Tname : 教师姓名
各实体的关系是：每一个教师可以教授多门课程，一门课程可以被多个教师教授，一个教室可以承载多门课程，一个课程可以被安排在多个教室中。当课程安排在指定教室的时候，需指明安排的日期（cdata）以及当天的第几节课（carrange）。
请根据上述需求，回答以下问题。
（1）设计该系统的 E-R 图。
（2）将 E-R 图转换成关系模式，并指出主码。
（3）根据关系模式，使用 SQL 创建课程实体，要求 SQL 语句中包含主码约束和非空约束，各属性的类型及长度自选。
————————————————
![[Pasted image 20230611120643.png]]
关系模式：
Course (<u>cid</u>, cname, chour, ctype)
Classroom (<u>crid</u>, crname, crbuilding)
Teacher (<u>tid</u>, tname)
Teach (tid, cid)
Arrangement (<u>cid</u>, <u>crid</u>, cdate, carrage)

5．图书管理系统是一类常见的信息管理系统。分析图书管理系统后，初步获得的实体信息如下。
图书：book（bookid，bookname，num）
Bookid 用于标识每一本图书
Bookname : 图书名称
Num : 图书数量
借阅用户：bookuser（tid，username，age）
Tid : 用于标识每一个借书用户
Username 为借书用户姓名
Age 为借书用户年龄
图书实体与借阅用户实体间的关系是：借阅用户可以借阅多本图书，同时，一本图书可以被多个借阅用户借阅。借阅过程产生借书日期（borrow_time）和还书日期（return_time）等属性。
请根据上述需求，回答以下问题。
（1）设计该系统的 E-R 图。
（2）将 E-R 图转换成关系模式，并指出主码。
（3）根据关系模式，使用 SQL 创建借书用户实体，要求 SQL 语句中包含主码约束和非空约束。
————————————————
![[Pasted image 20230611120710.png]]
关系模式：  
book (<u>bookid</u>, bookname, num)  
bookuser(<u>tid</u>,username,age)  
borrow (<u>bookid</u>, tid, borrow_time, return_time)

## 5.数据库设计 8 分，P 213，229
### 第六章数据库设计
P 213
##### 6.1.3 数据库设计的步骤
图 ![[Pasted image 20230611111921.png]]
数据库设计中，前两个阶段是面向用户的应用要求和面向具体的问题；中间两个阶段是面向数据库管理系统；最后两个阶段是面向具体的实现方法。前四个阶段可统称为“分析和设计阶段”，后两个阶段统称为“实现和运行阶段”。

这六个阶段的主要工作各有不同。

1. 系统需求分析阶段
<font color="#ff0000">系统需求分析阶段需求分析是整个数据库设计过程的基础，要收集数据库所有用户的信息内容和处理要求，并加以规格化和分析</font>。这是最费时、最复杂的一步，但也是最重要的一步，相当于待构建的数据库大厦的地基，它决定了以后各步设计的速度与质量。需求分析做得不好，可能会导致整个数据库设计返工重做。在分析用户需求时，要确保用户目标的一致性。
2. 概念结构设计阶段
<font color="#ff0000">概念结构设计是把用户的信息要求统一到一个整体逻辑结构中，此结构能够表达用户的要求，是一个独立于任何 DBMS 软件和硬件的概念模型</font>。
3. 逻辑结构设计阶段
<font color="#ff0000">逻辑结构设计是将上一步所得到的概念模型转换为某个 DBMS 所支持的数据模型，并对其进行优化</font>。
4. 物理结构设计阶段
<font color="#ff0000">物理结构设计是为逻辑数据模型建立一个完整的、能实现的数据库结构，包括存储结构和存取方法</font>。上述分析和设计阶段是很重要的，如果做出的分析或设计不恰当，则会设计出一个不恰当或反应迟钝的数据库系统。
5. 数据库实施阶段
<font color="#ff0000">此阶段可根据物理结构设计的结果把原始数据装入数据库，建立一个具体的数据库并编写和调试相应的应用程序。</font>应用程序的开发目标是开发一个可依赖的有效的数据库存取程序，来满足用户的处理要求。
6. 数据库运行与维护阶段
<font color="#ff0000">这一阶段主要是收集和记录实际系统运行的数据，数据库运行的记录用来提供用户要求的有效信息，用来评价数据库系统的性能，并进一步调整和修改数据库</font>。在运行中，必须保持数据库的完整性，且能有效地处理数据库故障和进行数据库恢复。在运行和维护阶段，可能要对数据库结构进行修改或扩充。
可以看出，以上六个阶段是从数据库应用系统设计和开发的全过程来考察数据库设计的问题。因此，它既是数据库也是应用系统的设计过程。在设计过程中，努力使数据库设计和系统其他部分的设计紧密结合，把数据和处理的需求收集、分析、抽象、设计和实现在各个阶段同时进行、相互参照、相互补充，以完善两方面的设计。按照这个原则，数据库各个阶段的设计可用图 6-4 描述。
在图 6-4 有关处理特性的描述中，采用的设计方法和工具属于软件工程和管理信息系统等课程中的内容，本书不再讨论，这里重点介绍数据特性的设计描述以及满足数据特性的数据模型的设计。
![[Pasted image 20230611112317.png]]
1．数据库设计分为哪几个阶段？每个阶段的主要工作是什么？

按规范设计法可将数据库设计分为六个阶段:

1. 系统需求分析阶段
需求分析是整个数据库设计过程的基础，要收集数据库所有用户的信息内容和处理要求，并加以规格化和分析。

2. 概念结构设计阶段
概念结构设计是把用户的信息要求统一到一个整体逻辑结构中。

3. 逻辑结构设计阶段
逻辑结构设计是将上一步所得到的概念模型转换为某个 DBMS 所支持的数据模型，并对其进行优化。

4. 物理结构设计阶段
物理结构设计是为逻辑数据模型建立一个完整的、能实现的数据库结构，包括存储结构和存取方法。

5. 数据库实施阶段
此阶段可根据物理结构设计的结果把原始数据装入数据库，建立一个具体的数据库并编写和调试相应的应用程序。

6. 数据库运行与维护阶段
这一阶段主要是收集和记录实际系统运行的数据，数据库运行的记录用来提供用户要求的有效信息，用来评价数据库系统的性能，并进一步调整和修改数据库。
————————————————

##### 6.3.3 概念模型 E-R 表示方法
在概念模型中，比较著名的是由P.P.Chen 于 1976 年提出的实体联系模型（Entity Relationship Model），简称 E-R 模型。E-R 模型是广泛应用于数据库设计工作中的一种概念模型，它利用 E-R 图来表示实体及其之间的联系。
E-R 图的基本成分包含实体型、属性和联系，它们的表示方式如下。
（1）实体型：用<font color="#ff0000">矩形框</font>表示，框内标注实体名称，如图 6-11（a）所示。
（2）属性：用<font color="#ff0000">椭圆形框</font>表示，框内标注属性名称，并用无向边将其与相应的实体相连，如图 6-11（b）所示。
（3）联系：联系用<font color="#ff0000">菱形框</font>表示，框内标注联系名称，并用无向边与有关实体相连，同时在无向边旁标上联系的类型，即1:1、1: n 或 m: n，如图 6-11（c）所示。
![[Pasted image 20230611112521.png]]
![[Pasted image 20230611112539.png]]
![[Pasted image 20230611112556.png]]

#### 6.4 逻辑结构设计
在数据库设计中，需求分析阶段的任务是什么？主要包括哪些内容？

从数据库设计的角度来看，需求分析的任务是：对现实世界要处理的对象（组织、部门、企业）等进行详细的调查，通过对原系统的了解，收集支持新系统的基础数据并对其进行处理，在此基础上确定新系统的功能。

需求分析阶段的任务包括：
（1)调查分析用户活动；
（2)收集和分析需求数据，确定系统边界；
（3)编写系统分析报告。
————————————————

##### 6.4.1 逻辑结构设计的任务和步骤
概念结构设计阶段得到的 E-R 模型是用户的模型，它独立于任何数据模型，独立于任何一个具体的 DBMS。为了建立用户所要求的数据库，需要把上述概念模型转换为某个具体的 DBMS 所支持的数据模型。数据库逻辑设计的任务是将概念模型转换成特定 DBMS 所支持的数据模型的过程。从此开始便进入了“实现设计”阶段，需要考虑到具体的 DBMS 的性能、具体的数据模型特点。
从 E-R 图所表示的概念模型可以转换成任何一种具体的 DBMS 所支持的数据模型，如网状模型、层次模型和关系模型。这里只讨论关系数据库的逻辑设计问题，所以只介绍 E-R 图如何向关系模型进行转换。
一般的逻辑结构设计分为以下三步（如图 6-24 所示）。
![[Pasted image 20230611112812.png]]
（1）初始关系模式设计。
（2）关系模式规范化。
（3）模式的评价与改进。

##### 6.4.2 初始关系模式设计
1. 转换原则
概念设计中得到的 E-R 图是由实体、属性和联系组成的，而关系数据库逻辑设计的结果是一组关系模式的集合。所以将 E-R 图转换为关系模型实际上就是将实体、属性和联系转换成关系模式。在转换中要遵循以下原则。
（1）一个实体转换为一个关系模式，实体的属性就是关系的属性，实体的码就是关系的主码。
（2）一个联系转换为一个关系模式，与该联系相连的各实体的主码以及联系的属性均转换为该关系的属性。该关系的主码有三种情况。
①如果联系为1:1，则每个实体的主码都可以是关系的候选码。
②如果联系为 1: n，则 n 端实体的主码是关系的主码。
③如果联系为 n: m，则每个实体的主码的组合是关系的主码。
2. 具体做法
（1）把每一个实体转换为一个关系。首先分析各实体的属性，从中确定其主码，然后分别用关系模式表示。
（2）把每一个联系转换为关系模式。由联系转换得到的关系模式中，包含联系本身的属性和联系的关系的主码，其关系的主码确定与联系的类型有关。
（3）特殊情况的处理。三个或三个以上实体间的一个多元联系在转换为一个关系模式时，与该多元联系相连的各实体的主码及联系本身的属性均转换成为关系的属性，转换后所得到的关系的主码为各实体主码的组合。
【例 6-1】图 6-25 表示供应商、项目和零件三个实体之间的多对多联系，如果已知三个实体的主码分别为“供应商号”，“项目号”与“零件号”，则它们之间的联系“供应”可转换为以下关系模式，其中供应商号、项目号、零件号为此关系的组合关系的主码。
供应（供应商号，项目号，零件号，数量）
![[Pasted image 20230611112948.png]]

##### 6.4.3 关系模式规范化
应用规范化理论对上述产生的关系的逻辑模式进行初步优化，以减少乃至消除关系模式中存在的各种异常，改善完整性、一致性和存储效率。规范化理论是数据库逻辑设计的指南和工具，规范化过程可分为两个步骤：确定范式级别和实施规范化处理。
1. 确定范式级别考察关系模式的函数依赖关系，确定范式等级。逐一分析各关系模式，考查主码和非主属性之间是否存在部分函数依赖、传递函数依赖等，确定它们分别属于第几范式。
2. 实施规范化处理利用第 4 章的规范化理论，逐一考察各个关系模式，根据应用要求，判断它们是否满足规范要求，可用已经介绍过的规范化方法和理论将关系模式规范化。
实际上，数据库规范化理论可用于整个数据库开发生命周期中。在需求分析阶段、概念结构设计阶段和逻辑结构设计阶段，数据库规范化理论的应用如下。
（1）在需求分析阶段，用函数依赖的概念分析和表示各个数据项之间的联系。
（2）在概念结构设计阶段，以规范化理论为指导，确定关系的主码，消除初步 E-R 图中冗余的联系。
（3）在逻辑结构设计阶段，从 E-R 图向数据模型转换过程中，用模式合并与分解方法达到指定的数据库规范化级别（至少达到 3 NF）。

##### 6.4.4 模式评价与改进
关系模式的规范化不是目的而是手段，数据库设计的目的是最终满足应用需求。因此，为了进一步提高数据库应用系统的性能，还应该对规范化后产生的关系模式进行评价、改进，经过反复多次的尝试和比较，最后得到优化的关系模式。
1. 模式评价模式评价的目的是检查所设计的数据库模式是否满足用户的功能要求、效率要求，从而确定加以改进的部分。模式评价包括功能评价和性能评价。
（1）功能评价。功能评价指对照需求分析的结果，检查规范化后的关系模式集合是否支持用户所有的应用要求。关系模式必须包括用户可能访问的所有属性。在涉及多个关系模式的应用中，应确保连接后不丢失信息。如果发现有的应用不被支持，或不完全被支持，则应进行关系模式的改进。发生这种问题的原因可能是在逻辑结构设计阶段，也可能是在系统需求分析或概念结构设计阶段。是哪个阶段的问题就返回到哪个阶段去改进，因此有可能对前两个阶段再进行评审，解决存在的问题。

在功能评价的过程中，可能会发现冗余的关系模式或属性，这时应对它们加以区分，搞清楚它们是为未来发展预留的，还是某种错误造成的，比如名字混淆。如果属于错误造成的，进行改正即可，而如果这种冗余来源于前两个设计阶段，则也要返回改进，并重新进行评审。
（2）性能评价。对于目前得到的数据库模式，由于缺乏物理结构设计所提供的数量测量标准和相应的评价手段，所以性能评价是比较困难的，只能对实际性能进行估计，包括逻辑记录的存取数、传送量以及物理结构设计算法的模型等。同时，可根据模式改进中关系模式合并的方法，提高关系模式的性能。
2. 模式改进根据模式评价的结果，对已生成的模式进行改进。如果因为系统需求分析、概念结构设计的疏漏导致某些应用不能得到支持，则应该增加新的关系模式或属性。如果因为性能考虑而要求改进，则可采用合并或分解的方法。
（1）合并。如果有若干个关系模式具有相同的主码，并且对这些关系模式的处理主要是查询操作，而且经常是多关系的连接查询，那么可对这些关系模式按照组合使用频率进行合并。这样便可以减少连接操作而提高查询效率。
（2）分解。为了提高数据操作的效率和存储空间的利用率，最常用和最重要的模式优化方法就是分解，根据应用的不同要求，可以对关系模式进行垂直分解和水平分解。
水平分解是把关系的元组分为若干个子集合，将分解后的每个子集合定义为一个子关系。对于经常进行大量数据的分类条件查询的关系，可进行水平分解，这样可以减少应用系统每次查询需要访问的记录数，从而提高了查询性能。
例如，有学生关系（学号，姓名，类别，……），其中类别包括大专生、本科生和研究生。如果多数查询一次只涉及其中的一类学生，就应该把整个学生关系水平分解为大专生、本科生和研究生三个关系。
垂直分解是把关系模式的属性分解为若干个子集合，形成若干个子关系模式，每个子关系模式的主码为原关系模式的主码。垂直分解的原则是把经常一起使用的属性分解出来，形成一个子关系模式。
例如，有教师关系（教师号，姓名，性别，年龄，职称，工资，岗位津贴，住址，电话），如果经常查询的仅是前六项，而后三项很少使用，则可以将教师关系进行垂直分解，得到两个教师关系：
教师关系 1（教师号，姓名，性别，年龄，职称，工资）
教师关系 2（教师号，岗位津贴，住址，电话）
这样，便减少了查询的数据传递量，提高了查询速度。
垂直分解可以提高某些事务的效率，但也有可能使另一些事务不得不执行连接操作，从而降低了效率。因此是否要进行垂直分解要看分解后的所有事务的总效率是否得到了提高。垂直分解要保证分解后的关系具有无损连接性和函数依赖保持性。相关的算法在第 4 章已经进行了详细介绍。
经过多次的模式评价和模式改进之后，最终的数据库模式得以确定。逻辑结构设计阶段的结果是全局逻辑数据库结构。对于关系数据库系统来说，就是一组符合一定规范的关系模式组成的关系数据库模式。
数据库系统的数据物理独立性特点消除了由于物理存储改变而引起的对应程序的修改。数据库的逻辑结构设计完成后，就可以开展物理结构设计。
## 6.SQL 题 32 分
Student（Sno、Sname、Ssex、Sage）
Course（Cno、Cname、Tno）
Teacher（Tno、Tname）
SC（Sno、Cno、Score）

1.建表
```
创建数据库
--在 C 盘创建文件夹 SQL，在 C 盘创建文件夹 data
CREATE DATABASE XS
ON
(NAME=xs_dat,
FILENAME='C:\SQL\xs_dat. Mdf',
SIZE=10,
MAXSIZE=50,
FILEGROWTH=1
)
LOG ON
(NAME=xs_log,
FILENAME='C:\data\xs_log. Ldf',
SIZE=1,
MAXSIZE=UNLIMITED,
FILEGROWTH=10%
)
GO
```

```
创建表
 Create  Table  Student 
(
	Sno  char (5), 
	Sname  varchar (20),
	Ssex  char (2),
	Sage  int,
	Sdept  varchar (15)
) 

SELECT * FROM Student
GO

Create Table Course
(
	Cno char (5),                            
	Cname varchar (20),
	Cpno char (5),
	Ccredit int
)

SELECT * FROM Course
GO

Create Table SC
(
	Sno char (5),
	Cno char (5),
	Grade int
)

SELECT * FROM SC
GO

```

2.改表里面一个列的长度
![[Pasted image 20230611145156.png]]
alter table 表名 modify 字段名字段类型（长度）

例如：alter   table   classes modify c_id varchar2(44)  （将班级表 classes 中的主键 c_id 的最大长度修改为44）

![[Pasted image 20230611145235.png]]
alter table 表名 alter column 字段名 varchar(新长度)

```
修改列的长度
Alter table 表名
Alter column [列名] varchar (50)

```
```
实验三
--6．修改李华同学的年龄为 19；

UPDATE Student SET Sage='19' WHERE Sage='18'

SELECT *FROM Student
GO

--7．将每位同学的年龄增加一岁；

Update Student Set Sage=Sage+1

SELECT *FROM Student
GO

```

3.把一条记录插到一个表的列里面
![[Pasted image 20230611144949.png]]
```
        格式
               Insert  into  表名[（列名）]
               Values (列值) 
```

```
插入单条数据
--实验二3．
在Student关系中，插入数据：‘2018001’，‘张三’，‘男’，‘19’，‘软件学院’；
INSERT INTO Student values
('2018001','张三','男','19','软件学院'
)

SELECT *FROM Student
GO

插入多条数据
INSERT INTO S4 VALUES
('K 001','计算机图形学','2.5','40','胡晶晶'),
('K 002','计算机应用基础','3','48','任泉'),
('K 006','数据结构','4','64','马跃先'),
('M 001','政治经济学','4	','64','孔繁新'),
('S 001','高等数学','3','48','赵晓尘');
```


4.修改信息把某个表里的某个信息修改
![[Pasted image 20230611145600.png]]

```
实验三--6．修改李华同学的年龄为19；

UPDATE Student SET Sage='19' WHERE Sage='18'

SELECT *FROM Student
GO

实验三--7．将每位同学的年龄增加一岁；

Update Student Set Sage=Sage+1

SELECT *FROM Student
GO

实验三--18．使用 Update 语句，将 Student 关系中李华的年龄改为与张三一致。
INSERT INTO Student VALUES
(
	'2018003','张三','男','19','软件学院'
)
SELECT *FROM Student
GO

UPDATE Student SET Sage=(SELECT Sage FROM Student WHERE Sname='张三') WHERE Sname='李华'
SELECT *FROM Student
GO

可用Select 子句查询来代替表达式，从而将Select 子查询得到的值更新指定的列。
           例：Update Student 
                  Set Sage= (Select Sage from Student 
                                       Where Sno=’95002’)
                   Where Sno=’95001’

```


5.单表查询，比如查某个学生的姓名和年龄

```
查询选修课程号为C1的学生的学号和成绩
SELECT SNo,Score
FROM SC
WHERE CNo='C1'

1.使用关键字 DISTINCT 才会消去重复行
SELECT DISTINCT SNO
FROM SC

2.AS 后面的 TotalScore 和 AvgScore 是别名
SELECT SUM (Score) AS TotalScore, AVG (Score) AS AvgScore
FROM SC
WHERE (SC='S 1')

3.利用关键字JOIN进行连接
INNER JOIN 内连接。显示符合条件的记录，此为默认值。引用列名前加上表名前缀。
LEFT (OUTER) JOIN 左（外）连接。主表在左边。用于显示符合条件的数据行以及左边表中不符合条件的数据行。此时右边数据行会以NULL来显示。
RIGHT (OUTER) JOIN 右（外）连接。主表在右边。用于显示符合条件的数据行以及右边表中不符合条件的数据行。此时左边数据行会以NULL来显示。
FULL (OUTER) JOIN 完全连接。示符合条件的数据行以及左边表和右边表中不符合条件的数据行。此时缺乏数据的数据行会以NULL来显示。
CROSS JOIN 交叉查询。将一个表的每一个记录和另一表的每个记录匹配成新的数据行。

JOIN关键词放于FROM字句中时，应有关键词ON与之对应，以表明连接的条件

SELECT [ALL|DISTINCT][TOP N [PERCENT][WITH TIES]]
列名1 [AS 别名1]
[, 列名2 [ AS 别名2]…]
[INTO 新表名]
FROM 表名 1[[AS] 表1别名]
[INNER|RIGHT|FULL|OUTER|CROSS]JOIN
	表名2 [[AS] 表2别名]
ON 条件
```

6.用子查询查询信息（一层嵌套），比如查所有女生的信息

```
查询全体学生的姓名、学号和年龄
SELECT SN Name，SNo，Age
FROM S

1.ANY含义为任意一个
查询讲授课程号为C5的教师姓名
SELECT TN FROM T
WHERE( TNO=ANY( SELECT TNO
				FROM TC
				WHERE CNO='C5'))

2.IN(=ANY)可以使用IN来代替"=ANY"
查询讲授课程号为C5的教师姓名（使用IN）
SELECT TN
FROM T
WHERE(TNO IN(SELECT TNO
			FROM TC
			WHERE CNO='C5'))

3.ALL含义为全部
查询其他系中比计算机系所有教师工资都高的教师的姓名和工资
SELECT TN,Sal
FROM T
WHERE(Sal>ALL(SELECT Sal
				FROM T
				WHERE Dept='计算机'))
			AND(Dept<>'计算机')

实验四--12．利用子查询检索选修了‘002’号课程所有学生的名字；
SELECT Sname 
FROM Course, Student, SC
WHERE SC. Sno=Student. Sno AND Course. Cno=SC. Cno AND Course. Cno='002'
```
```
当不知道完全精确的值时，用户还可以使用 LIKE 或 NOT LIKE 进行部分匹配查询（也称模糊查询）。
LIKE 定义的一般格式为：<属性名> LIKE <字符串常量>
其中，属性名必须为字符型，字符串常量中的字符可以包含通配符，利用这些通配符，可以进行模糊查询，字符串中的通配符及其功能如表3.3所示。
【例3-31】查询所有姓张的教师的教师号和姓名。
SELECT TNo, TN
FROM T
WHERE TN LIKE '张%'
【例3-32】查询姓名中第二个汉字是“力”的教师号和姓名。
SELECT TNo, TN
FROM TWHERE TN LIKE'__力%'
```


7.分组查询，比如查某两门课程都没过的学生

```sql
在Where 子句后可用“Group by +列名”来对查询结果按列名进行分组，并可用Having 子句对分组后利用聚合函数进行条件查询。
         例：Select  Sno from SC
                Where Grade < 60
                Group  by  Sno 
                Having count(*) > 2 


3、查询出有两门以上不及格的学生：

SELECT s.sno,s.sname 
    from student s
    LEFT JOIN sgrade g on s.sno=g.sno
WHERE g.sgrade<60
GROUP BY s.sno HAVING COUNT(s.sno)>2

4、查询出全部及格的学生:

SELECT * FROM student WHERE sno not in (
    SELECT s.sno
        from student s
        LEFT JOIN sgrade g on s.sno=g.sno
    WHERE g.sgrade<60 
)

GROUP BY子句可以将查询结果按属性列或属性列组合在行的方向上进行分组，每组在属性列或属性列组合上具有相同的值。

【例3-40】查询每个教师的教师号及其任课的门数。
SELECT TNo,COUNT（*） AS C_NumFROM TCGROUP BY TNo

GROUP BY子句按TNo的值分组，所有具有相同TNo的元组为一组，对每一组使用函数COUNT进行计算，统计出各位教师任课的门数。

若在分组后还要按照一定的条件进行筛选，则需使用HAVING子句。

【例3-41】查询选修两门以上（含两门）课程的学生的学号和选课门数。
SELECT SNo, COUNT（*） AS SC_Num
FROM SC
GROUP BY SNo
HAVING （COUNT（*） >= 2）

GROUP BY子句按SNo的值分组，所有具有相同SNo的元组为一组，对每一组使用函数COUNT进行计算，统计出每个学生选课的门数。HAVING子句去掉不满足COUNT（*）>=2的组。
当在一个SQL查询中同时使用WHERE子句，GROUP BY子句和HAVING子句时，其顺序是WHERE、GROUP BY、HAVING。WHERE与HAVING子句的根本区别在于作用对象不同。WHERE子句作用于基本表或视图，从中选择满足条件的元组；HAVING子句作用于组，选择满足条件的组，必须用在GROUP BY子句之后，但GROUP BY子句可没有HAVING子句。

当需要对查询结果排序时，应该使用ORDER BY子句，ORDER BY子句必须出现在其他子句之后。排序方式可以指定，DESC为降序，ASC为升序，缺省时为升序。
【例3-42】查询选修C1的学生学号和成绩，并按成绩降序排列。
SELECT SNo, Score
FROM SC
WHERE （CNo = 'C1'）
ORDER BY Score DESC
【例3-43】查询选修C2、C3、C4或C5课程的学号、课程号和成绩，查询结果按学号升序排列，学号相同再按成绩降序排列。
SELECT SNo, CNo, Score
FROM SC
WHERE CNo IN （'C2', 'C3', 'C4', 'C5'）
ORDER BY SNo, Score DESC

**分组查询**：
select * from 表名 group by 字段 having 条件; 
（having作用和where一样，但having只能用于group by）
```

8.创建视图

```
实验五
--1．定义一个所有年龄为 18 岁的学生的视图 V_Student_1；
--DROP VIEW V_Student_1
CREATE VIEW V_Student_1
AS
SELECT Sno, Sname, Ssex, Sage, Sdept
FROM Student
WHERE Sage='18'

SELECT *FROM V_Student_1
GO
--2．将学生的学号，平均成绩定义为一个视图 V_Student_2；
CREATE VIEW V_Student_2 (Sno, AVGGrade)
AS
SELECT Sno,AVG (Grade)
FROM SC
GROUP BY Sno
 
SELECT *FROM V_Student_2
GO
--3．定义一个学分为 4 的只有课程号、课程名称的视图 V_Course_1；
CREATE VIEW V_Course_1
AS
SELECT Cno, Cname
FROM Course
WHERE Ccredit='4'

SELECT *FROM V_Course_1
GO

--4．定义一个学生的姓名，所选修的课程名及成绩的视图 V_Student_3；
--DROP VIEW V_Student_3
CREATE VIEW V_Student_3
AS
SELECT Sname, Cname, Grade
FROM SC, Student, Course
WHERE Student. Sno=SC. Sno AND Course. Cno=SC. Cno
WITH CHECK OPTION

SELECT *FROM V_Student_3
GO
--5．定义一个“经济管理学院”的学生学号、姓名，性别，年龄的视图 V_Student_4；
--DROP VIEW V_STUDENT_4
CREATE VIEW V_Student_4
AS
SELECT Sno, Sname, Ssex, Sage
FROM Student
WHERE Sdept='经管学院'
WITH CHECK OPTION

SELECT *FROM V_Student_4
GO

--6．删除视图 V_Student_2；
DROP VIEW V_Student_2

```





9. 拓展
```
实验二
查询全部的约束名
SELECT * FROM SYS.OBJECTS
11、将SC关系中Grade属性名改为Score；
EXEC sp_rename 'SC.[Grade]', 'Score', 'column'
SELECT * FROM SC
GO
```

```
实验三--8．分离和附加数据库 TSET；
CREATE DATABASE TEST 1
ON
(
NAME=TEST 1_DATA,
FILENAME='D:\TEST 1 Data. Mdf',
SIZE=10,
MAXSIZE=500,
FILEGROWTH=10
)
LOG ON
(
NAME=TEST 1_LOG,
FILENAME='D:\TEST 1 Data. Ldf',
SIZE=5,
MAXSIZE=500,
FILEGROWTH=5
)
--分离
EXEC sp_detach_db @dbname=TEST 1
GO

--附加
EXEC sp_attach_db @dbname=TEST 1,
@filename 1='D:\TESTData. Mdf',
@filename 2='D:\TESTData. Ldf'
GO

```

```
实验三--9．在 Student 关系中删除年龄大于 20 岁的学生的元组；

DELETE FROM Student WHERE Sage>'20'

SELECT *FROM Student
GO

实验三--10．删除 SC 关系中所有元组。

DELETE FROM SC

SELECT *FROM SC
GO
```

```
实验三--17．建立 STU（Sno, Sname），将 Student 关系中的 Sno，Sname 两个列的数据插入到 STU 关系中；
--(1)
CREATE TABLE STU
(
	Sno char (10),
	Sname varchar (20),
)

SELECT *FROM STU
GO


INSERT INTO STU
SELECT Sno, Sname FROM Student

SELECT *FROM STU
GO
--(2)
SELECT Student. Sno, Student. Sname into #STU from Student
SELECT *FROM #STU
GO
```

```
实验三--18．使用 Update 语句，将 Student 关系中李华的年龄改为与张三一致。
INSERT INTO Student VALUES
(
	'2018003','张三','男','19','软件学院'
)
SELECT *FROM Student
GO

UPDATE Student SET Sage=(SELECT Sage FROM Student WHERE Sname='张三') WHERE Sname='李华'
SELECT *FROM Student
GO
```


```
实验四--5．求 Student, Course, SC 三个关系的笛卡尔积；
SELECT Student.*, Course.*, SC.*
FROM Student, Course, SC
```


```
实验五
--7．在 V_Student_4 查询年龄小于 20 岁的学生信息；
SELECT *FROM V_Student_4
WHERE Sage<'20'

--8．在 V_Student_4 视图中，将所有的年龄增加一岁；
UPDATE V_Student_4 SET Sage=Sage+1

SELECT * FROM V_Student_4
--9．为表 Course 在 Cname 上建立非主簇索引 i_Course；
CREATE NONCLUSTERED INDEX i_Course ON Course (Cname)

--10．为表 Student 在 Sname 和 Sage 上建立非主簇索引 i_Student；
CREATE NONCLUSTERED INDEX i_Student ON Student (Sname, Sage)

--11．为表 SC 在 Sno 和 Cno 上建立唯一索引 i_SC；
CREATE UNIQUE INDEX i_SC ON SC (Sno, Cno)

--12．利用 SP_HELPINDEX 查看 Student 关系的所有类型的索引；
EXEC SP_HELPINDEX Student

--13．将 i_Student 索引的名字改为 i_Student_1；
EXEC SP_RENAME 'Student. I_Student','i_Student_1'

--14．删除索引 i_Course。
DROP INDEX Course. I_Course
```

```
列的修改
1.添加列（add）

alter table 表名 add 列名 列的类型( 列的约束);

alter table student add chengji int not null;

2.修改列（modify）

alter table 表名 modify  列名 列的类型( 列的约束);

alter table student modify sex varchar(2);

3.修改列名（change）

alter table 表名 change  列名 新的列名 列的类型( 列的约束);

alter table student change sex gender varchar(2);

4.删除列（drop）
alter table 表名 drop  列名;

alter table student drop chengji;

5.修改表名（rename）

rename table  旧表名 to 新的表名

尽量不使用，避免因为修改，引起大量麻烦！

6.修改表的字符集

alter table 表名 character set 字符集

alter table student character set gbk;

show create table student;

```
