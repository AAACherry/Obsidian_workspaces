
## 前言

我们知道，一台主机向另外一台主机发送报文的时候，需要一层层经过自己的协议栈进行数据封装，到达最后一层（四层协议的网络接口层）时需要在帧尾部添加 FCS 校验码（通过 CRC 算法得出）。当对端主机收到时，在接收端同样通过 CRC 算法进行验证，确认传输过程中是否出现错误。它只能确认一个帧是否存在比特差错，但没有提供解决措施。


## 循环冗余校验的原理

在发送端，先把数据划分为组（即：一帧）。假定每组 k 个比特。
在每组后面，添加供差错检测用的 n 位冗余码一起发送。即：实际发送长度为：k+n 比特。
发送前双方协商 n+1 位的除数 P，方便接收方收到后校验。
给 K 比特的数据添加除数减一个 0（P-1）作为被除数，与第三步确定的除数做“模 2 除法”。得出的余数即 FCS 校验序列，它的位数也必须是（P-1）。
将 FCS 校验序列添加至 K 个比特位的后面发送出去。
接收方对接收到的每一帧进行校验，若得出的余数 R = 0，则判定这个帧没有差错，就接受 (accept)。若余数 R ≠ 0，则判定这个帧有差错，就丢弃。

##### 对“模 2 除法”进行说明：

“模 2 除法”与“算术除法”类似，但它既不向上位借位，也不比较除数和被除数的相同位数值的大小，只要以相同位数进行相除即可。<font color="#ff0000">模 2 加法运算为：1+1=0，0+1=1，0+0=0，无进位，也无借位；模 2 减法运算为：1-1=0，0-1=1，1-0=1，0-0=0，也无进位，无借位。</font>相当于二进制中的逻辑异或运算（相同为 0，不同为 1）。

计算示例
![[Pasted image 20230424223022.png]]
那么接收方拿到的就是：101001 001。（初始被除数+余数）再以它为被除数，1101 为除数进行“模 2 除法”。
注意：**余数的位数一定是比除数少一位**，不够的在前面补“0”。
————————————————
版权声明：本文为 CSDN 博主「pointer_y」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接： https://blog.csdn.net/pointer_y/article/details/60332956


#### 循环冗余校验码的定义
循环冗余校验码由信息码 n 位和校验码 k 位构成。K 位校验位拼接在 n 位数据位后面，n+k 为循环冗余校验码的字长，又称这个校验码（n+k,n）码。
N 位信息位可以表示成为一个报文多项式 M (x)，最高幂次是 xn-1。约定的生成多项式 G (x)是一个 k+1 位的二进制数，最高幂次是 xk。将 M (x)乘以 xk，即左移 k 位后，除以 G (x)，得到的 k 位余数就是校验位。这里的除法运算是模 2 除法，即当部分余数首位是 1 时商取 1，反之商取 0。然后每一位的减法运算是按位减，不产生借位。

#### 循环冗余校验码的特点
理论上可以证明循环冗余校验码的检错能力有以下特点：①可检测出所有奇数位错；②可检测出所有双比特的错；③可检测出所有小于、等于校验位长度的突发错。

#### 什么是模 2 运算
![[Pasted image 20230424223157.png]]

#### CRC 码的计算
![[Pasted image 20230424223214.png]]
下面有两个多项式，<font color="#ff0000">M（x）代表发送信息的多项式，G（x）代表校验位信息</font>
M（x）作为被除数，G（x）作为除数
![[Pasted image 20230424223222.png]]

上面两个式子所代表的二进制吗<font color="#ff0000">根据多项式每项的系数得出</font>
![[Pasted image 20230424223229.png]]

为什么是要在信息的二进制码上加 3 个 0，是根据<font color="#ff0000">右边式子的最高次幂是 3，所以左边的式子乘以 2 的 3 次方</font>
![[Pasted image 20230424223236.png]]

再将上面的两个二进制数做<font color="#ff0000">模二除法</font>
![[Pasted image 20230424223242.png]]
这里有一个规则，<font color="#ff0000">每一步得出的二进制数将抹掉一位，此时如果它的首位是 0，那么除数就商 0，如果是 1，就商 1, 得出下一个被除数</font>。
![[Pasted image 20230424223249.png]]
当得到的<font color="#ff0000">结果小于除数时，就是余数</font>
![[Pasted image 20230424223257.png]]
循环冗余校验码就是这样的出来的

#### 具体怎么校验 ((循环冗余校验码)CRC 校验码能不能整数 G (x))
![[Pasted image 20230424223311.png]]


上图是黄色的是发送塔，蓝色的是接收塔，发送方和接收方的一个约定是 G（x），（两方都知道）
![[Pasted image 20230424223320.png]]
**如果接收方收到的信息不能整除检验码，就说明信息有错，反之如上**
————————————————
版权声明：本文为 CSDN 博主「_阿锋丶」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接： https://blog.csdn.net/weixin_43342105/article/details/108717695